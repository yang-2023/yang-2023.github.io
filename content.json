{"meta":{"title":"😀","subtitle":"一些study的过程","description":"","author":"yangyan","url":"http://example.com","root":"/"},"pages":[{"title":"","date":"2023-10-26T14:35:39.492Z","updated":"2023-10-26T14:17:46.536Z","comments":true,"path":"jquery.min.js","permalink":"http://example.com/jquery.min.js","excerpt":"","text":"/*! jQuery v2.1.3 | (c) 2005, 2014 jQuery Foundation, Inc. | jquery.org/license */ !function(a,b){\"object\"==typeof module&&\"object\"==typeof module.exports?module.exports=a.document?b(a,!0):function(a){if(!a.document)throw new Error(\"jQuery requires a window with a document\");return b(a)}:b(a)}(\"undefined\"!=typeof window?window:this,function(a,b){var c=[],d=c.slice,e=c.concat,f=c.push,g=c.indexOf,h={},i=h.toString,j=h.hasOwnProperty,k={},l=a.document,m=\"2.1.3\",n=function(a,b){return new n.fn.init(a,b)},o=/^[\\s\\uFEFF\\xA0]+|[\\s\\uFEFF\\xA0]+$/g,p=/^-ms-/,q=/-([\\da-z])/gi,r=function(a,b){return b.toUpperCase()};n.fn=n.prototype={jquery:m,constructor:n,selector:\"\",length:0,toArray:function(){return d.call(this)},get:function(a){return null!=a?0>a?this[a+this.length]:this[a]:d.call(this)},pushStack:function(a){var b=n.merge(this.constructor(),a);return b.prevObject=this,b.context=this.context,b},each:function(a,b){return n.each(this,a,b)},map:function(a){return this.pushStack(n.map(this,function(b,c){return a.call(b,c,b)}))},slice:function(){return this.pushStack(d.apply(this,arguments))},first:function(){return this.eq(0)},last:function(){return this.eq(-1)},eq:function(a){var b=this.length,c=+a+(0>a?b:0);return this.pushStack(c>=0&&b>c?[this[c]]:[])},end:function(){return this.prevObject||this.constructor(null)},push:f,sort:c.sort,splice:c.splice},n.extend=n.fn.extend=function(){var a,b,c,d,e,f,g=arguments[0]||{},h=1,i=arguments.length,j=!1;for(\"boolean\"==typeof g&&(j=g,g=arguments[h]||{},h++),\"object\"==typeof g||n.isFunction(g)||(g={}),h===i&&(g=this,h--);i>h;h++)if(null!=(a=arguments[h]))for(b in a)c=g[b],d=a[b],g!==d&&(j&&d&&(n.isPlainObject(d)||(e=n.isArray(d)))?(e?(e=!1,f=c&&n.isArray(c)?c:[]):f=c&&n.isPlainObject(c)?c:{},g[b]=n.extend(j,f,d)):void 0!==d&&(g[b]=d));return g},n.extend({expando:\"jQuery\"+(m+Math.random()).replace(/\\D/g,\"\"),isReady:!0,error:function(a){throw new Error(a)},noop:function(){},isFunction:function(a){return\"function\"===n.type(a)},isArray:Array.isArray,isWindow:function(a){return null!=a&&a===a.window},isNumeric:function(a){return!n.isArray(a)&&a-parseFloat(a)+1>=0},isPlainObject:function(a){return\"object\"!==n.type(a)||a.nodeType||n.isWindow(a)?!1:a.constructor&&!j.call(a.constructor.prototype,\"isPrototypeOf\")?!1:!0},isEmptyObject:function(a){var b;for(b in a)return!1;return!0},type:function(a){return null==a?a+\"\":\"object\"==typeof a||\"function\"==typeof a?h[i.call(a)]||\"object\":typeof a},globalEval:function(a){var b,c=eval;a=n.trim(a),a&&(1===a.indexOf(\"use strict\")?(b=l.createElement(\"script\"),b.text=a,l.head.appendChild(b).parentNode.removeChild(b)):c(a))},camelCase:function(a){return a.replace(p,\"ms-\").replace(q,r)},nodeName:function(a,b){return a.nodeName&&a.nodeName.toLowerCase()===b.toLowerCase()},each:function(a,b,c){var d,e=0,f=a.length,g=s(a);if(c){if(g){for(;f>e;e++)if(d=b.apply(a[e],c),d===!1)break}else for(e in a)if(d=b.apply(a[e],c),d===!1)break}else if(g){for(;f>e;e++)if(d=b.call(a[e],e,a[e]),d===!1)break}else for(e in a)if(d=b.call(a[e],e,a[e]),d===!1)break;return a},trim:function(a){return null==a?\"\":(a+\"\").replace(o,\"\")},makeArray:function(a,b){var c=b||[];return null!=a&&(s(Object(a))?n.merge(c,\"string\"==typeof a?[a]:a):f.call(c,a)),c},inArray:function(a,b,c){return null==b?-1:g.call(b,a,c)},merge:function(a,b){for(var c=+b.length,d=0,e=a.length;c>d;d++)a[e++]=b[d];return a.length=e,a},grep:function(a,b,c){for(var d,e=[],f=0,g=a.length,h=!c;g>f;f++)d=!b(a[f],f),d!==h&&e.push(a[f]);return e},map:function(a,b,c){var d,f=0,g=a.length,h=s(a),i=[];if(h)for(;g>f;f++)d=b(a[f],f,c),null!=d&&i.push(d);else for(f in a)d=b(a[f],f,c),null!=d&&i.push(d);return e.apply([],i)},guid:1,proxy:function(a,b){var c,e,f;return\"string\"==typeof b&&(c=a[b],b=a,a=c),n.isFunction(a)?(e=d.call(arguments,2),f=function(){return a.apply(b||this,e.concat(d.call(arguments)))},f.guid=a.guid=a.guid||n.guid++,f):void 0},now:Date.now,support:k}),n.each(\"Boolean Number String Function Array Date RegExp Object Error\".split(\" \"),function(a,b){h[\"[object \"+b+\"]\"]=b.toLowerCase()});function s(a){var b=a.length,c=n.type(a);return\"function\"===c||n.isWindow(a)?!1:1===a.nodeType&&b?!0:\"array\"===c||0===b||\"number\"==typeof b&&b>0&&b-1 in a}var t=function(a){var b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u=\"sizzle\"+1*new Date,v=a.document,w=0,x=0,y=hb(),z=hb(),A=hb(),B=function(a,b){return a===b&&(l=!0),0},C=1"},{"title":"","date":"2023-10-26T14:35:39.492Z","updated":"2023-10-26T14:17:46.549Z","comments":true,"path":"main.js","permalink":"http://example.com/main.js","excerpt":"","text":"console.log('js完成'); let input_text = document.querySelector('#text_input') let text_false = false function put(){ if(text_false){ input_text.style.opacity = \"1\" }else { input_text.style.opacity = \"0\" } } put() input_text.addEventListener('mouseenter',function(){ text_false = true; put() }) input_text.addEventListener('mouseleave',function(){ text_false = false; put() }) function LoadSearch(){ var searchFunc = function(path, search_id, content_id) { 'use strict'; //使用严格模式 $.ajax({ url: path, dataType: \"xml\", success: function( xmlResponse ) { // 从xml中获取相应的标题等数据 var datas = $( \"entry\", xmlResponse ).map(function() { return { title: $( \"title\", this ).text(), content: $(\"content\",this).text(), url: $( \"url\" , this).text() }; }).get(); //ID选择器 var $input = document.getElementById(search_id); var $resultContent = document.getElementById(content_id); $input.addEventListener('input', function(){ var str= ` ` var keywords = this.value.trim().toLowerCase().split(/[\\s\\-]+/); $resultContent.innerHTML = \"\"; if (this.value.trim().length /g,\"\").toLowerCase(); var data_url = data.url; var index_title = -1; var index_content = -1; var first_occur = -1; // 只匹配非空文章 if(data_title != '' && data_content != '') { keywords.forEach(function(keyword, i) { index_title = data_title.indexOf(keyword); index_content = data_content.indexOf(keyword); if( index_title < 0 && index_content < 0 ){ isMatch = false; } else { if (index_content < 0) { index_content = 0; } if (i == 0) { first_occur = index_content; } } }); } // 返回搜索结果 if (isMatch) { //结果标签 str += ` ${data_title} √ ` var content = data.content.trim().replace(/]+>/g,\"\"); if (first_occur >= 0) { // 拿出含有搜索字的部分 var start = first_occur - 6; var end = first_occur + 6; if(start < 0){ start = 0; } if(start == 0){ end = 10; } if(end > content.length){ end = content.length; } var match_content = content.substr(start, end); // 列出搜索关键字，定义class加高亮 keywords.forEach(function(keyword){ var regS = new RegExp(keyword, \"gi\"); match_content = match_content.replace(regS, \"\"+keyword+\"\"); }) } } }) $resultContent.innerHTML = str; }) } }) }; var path = \"/search.xml\"; console.log('文章数据加载完毕'); searchFunc(path, 'text_input', 'text_output'); console.log('搜索模块初始化完成'); } $(function() { var $input = $(\"input\"); $input.each(function() { var $title = $(this).attr(\"title\"); $(this).val($title); $(this).focus(function() { if($(this).val() === $title) { $(this).val(''); } }) .blur(function() { if($(this).val() === \"\") { $(this).val($title); } }); }); }); window.onload = function() { LoadSearch(); }"},{"title":"","date":"2023-12-05T12:28:22.197Z","updated":"2023-10-26T14:17:46.567Z","comments":true,"path":"style.css","permalink":"http://example.com/style.css","excerpt":"","text":"/* wenzhang=文章 */ /* pai = 排 */ /* kong = 空 */ /* jiao = 脚 */ /* 主页框框 */ #content-wrap > div { margin: 0 auto; } /* 框框位置 */ #content-wrap > div > div > p{ display: flex; width: 100%; height: 100%; justify-content: space-around; } .Text>a{ color:#000; font-size: 20px; } .pai { display: flex; width: 100%; justify-content: space-around; font-size: 25px; margin: 30px 30px 40px 0px; } a > span { color:#000; } strong > a { color:#000; } h1,h2,h3,h4,h5 > a{ color:#000; } h1>a, h2>a, h3>a, h4>a { color:#000; } .category-list-item>.category-list-link{ color:#000; } .kong{ color:#000; margin: 0px 0px 0px 0px; } .box{ border-style:solid; border-width:medium; } /* 换页 */ /* .jiao{ color:#000; margin: 0px 0px 0px 0px; } */ .konga { display: flex; width: 100%; justify-content: space-around; margin: 5% 0px 0px 0px; color:#000; } /* 搜索框下面的文字 变短原因 span */ .konga2 { display: flex; width: 100%; justify-content: space-around; margin: 5% 0px 0px 0px; color:#000; } #content-wrap > div > div > h1{ display: flex; width: 100%; justify-content: space-around; font-size: 25px; /* margin: 30px 30px 40px 0px; */ } #content-wrap > div > div > h3{ display: flex; width: 100%; justify-content: space-around; font-size: 25px; } img{ width: 100%; } /* 日期框框 */ .bx{ border-style:solid; border-width:medium; font-size: 1px; font-weight: bold; color:#000; } p > a{ color:#000; } /* 文章布局 */ .wenzhang-container { margin: auto; max-width: 960px; padding: 16px 16px; overflow-wrap: break-word; word-break: break-word; line-height: 1.6; font-size: larger; } /* 表格 */ #content-wrap > div > div > wenzhang > table > tbody > tr > td{ border: 1px solid; border-spacing: 2px; border-color: #000; } /* 分类中间对其 */ #content-wrap > div > span > h2 > ul { display: flex; justify-content: center; flex-wrap: wrap; } #content-wrap > div > span > h2 > ul > li{ /* 阴影 */ box-shadow: 0 .5em 1em -.125em rgba(10, 10, 10, .1), 0 0 0 1px rgba(10, 10, 10, .02); /* margin-bottom: 1.6rem; */ /* border-style:solid; */ /* color:#000; */ /* overflow-wrap: break-word; */ /* word-break: break-word; */ font-size: larger; /* 长度 */ margin-bottom: 1.6rem; /* 边框 */ border: 2px solid #000000; padding: 10px 10px 10px 10px; background: #fffefe; border-radius: 10px; border-style:solid; border-width:medium; display: inline-block; margin: 10px 10px 10px 10px; text-decoration: none; color: #000; } /* 关于框框 */ #text1{ border-spacing: 2px; border: 3px solid; background: #fffefe; border-color: #000; border-radius: 10px; padding: 30px; } /* 框框文字 */ #text2{ margin: 0 auto; text-align: center; font-weight:900; font-size: 2rem;; } /* 分类框框 */ #text3{ min-width: 100vh; display: flex; justify-content: center; align-items: center; } /* 分页字体 */ #text4{ /* font-size: 75%; margin: 10px 10px 10px 10px; */ /* 阴影 */ display: flex; justify-content: center; box-shadow: 0 .5em 1em -.125em rgba(10, 10, 10, .1), 0 0 0 1px rgba(10, 10, 10, .02); /* margin-bottom: 1.6rem; */ /* border-style:solid; */ /* color:#000; */ /* overflow-wrap: break-word; */ /* word-break: break-word; */ font-size: larger; /* 长度 */ margin-bottom: 1.6rem; /* 边框 */ border: 2px solid #000000; padding: 10px 10px 10px 10px; background: #fffefe; border-radius: 10px; border-style:solid; border-width:medium; display: inline-block; margin: 10px 10px 10px 10px; text-decoration: none; color: #000; } /* 搜索 */ /* 换页 */ #text_input, .jiao { /* 边框 */ border: 3px solid #000000; background: #fffefe; border-radius: 10px; color: #000; text-align: center; margin: 0 auto; display:flex; } #footer > span > a{ font-size: 2.1875rem; } /* 输出 */ #text_output{ text-align: center; margin: 0 auto; } #text_output > div > div{ border: 2px solid #000000; color: #000; font-size:25px; border-radius: 10px; margin: 10px 10px 10px 10px; padding: 1px 1px 1px 1px; } /* 框框位置上下位置 */ .box:not(:last-child){ margin-bottom: 1.6rem; } body { color: #4a4a4a; font-size: 1em; font-weight: 500px; line-height: 1.5 } a { cursor: pointer; text-decoration: none } .box { background-color: #ffffff; border-radius: 6px; box-shadow: 0 .5em 1em -.125em rgba(10, 10, 10, .1), 0 0 0 1px rgba(10, 10, 10, .02); color: #4a4a4a; display: block; padding: 1.25rem } /* 框框宽度 */ @media screen and (min-width:64.0625rem) { .container { max-width: 64.0625rem !important; } } /* 代码框背景颜色 */ /* #content-wrap > div > div > wenzhang > figure{ background-color: rgb(249, 249, 249); } */ /* 文章分类 */ #content-wrap > div > div > ul > li > a{ border-style:solid; border-width:medium; -webkit-text-stroke: 0.3px !important; background-color: #ffffff; border-radius: 6px; box-shadow: 0 .5em 1em -.125em rgba(10, 10, 10, .1), 0 0 0 1px rgba(10, 10, 10, .02); color: #4a4a4a; display: block; padding: 1.25rem; margin: 1rem; } /* 文章分类文字加深 */ #content-wrap > div > div > ul > li > a{ color: #000; font-size: 20px; } /* 文章时间 */ #content-wrap > div > div > wenzhang > div > div > a{ padding: 1px !important; margin-bottom: 4px !important; border-radius: 4px; } /* 关于的框框 */ #content-wrap > div > div > wenzhang > kuankuan { border-style:solid; border-width:medium; background-color: #ffffff; border-radius: 6px; color: #4a4a4a; display: block; padding: 1.25rem; } /* 博客版权 */ body > bokebangquan,#content-wrap > bokebangquan > p{ background-color: #ffffff; color: #4a4a4a; display: flex; align-items: center; justify-content: center; } #content-wrap > div > div > wenzhang > figure > table{ border-style:solid; border-width:medium; background-color: #ffffff; border-radius: 6px; color: #4a4a4a; display: block; padding: 1.25rem; } /* 屏蔽来必力广告 */ #trc_wrapper_52443{ display: none !important; } #trc_header_56062 > span{ display: none !important; } #taboola-livere > div{ display: none !important; } /* 评论区黑白 */ /* #lv-container{ filter: grayscale(100%) !important; color: #000 !important; } */ /* 时间正序 时间倒序 同感正序 */ /* #container { display: none !important; filter: grayscale(100%) !important; color: #000 !important; } */ /* 图片变黑白 */ /* img{ filter: grayscale(100%) !important; } #sns-login > button{ filter: grayscale(100%) !important; } #list > div > div > div > ul > li > button > img{ filter: grayscale(100%) !important; } */ /* 评论变黑白 body整个变成黑白 因为实在太多了 所以懒得选 */ body{ filter: grayscale(100%) !important; color: rgb(8, 4, 4) !important; } /* 代码高暗 */ /* */ .hljs-name { color: #6b6b6b } /* 斜体 */ .hljs-emphasis，.hljs-meta, .hljs-tag { font-style: italic } .hljs { color: #444; } .hljs-comment { color: #888 } .hljs-attribute, .hljs-doctag, .hljs-keyword, .hljs-meta .hljs-keyword, .hljs-name, .hljs-selector-tag { font-weight: 700 } .hljs-deletion, .hljs-number, .hljs-quote, .hljs-selector-class, .hljs-selector-id, .hljs-string, .hljs-template-tag, .hljs-type { color: #444d5c } .hljs-section, .hljs-title { color: #323233; font-weight: 700 } .hljs-link, .hljs-regexp, .hljs-selector-attr, .hljs-selector-pseudo, .hljs-symbol, .hljs-template-variable, .hljs-variable { color: #5c5151 } .hljs-literal { color: #202020 } .hljs-addition, .hljs-built_in, .hljs-bullet, .hljs-code { color: #0b1414 } .hljs-meta .hljs-string { color: #000000 } .hljs-emphasis { font-style: italic } .hljs-strong { font-weight: 700 }"},{"title":"标签","date":"2023-12-05T14:00:43.000Z","updated":"2023-12-05T15:56:13.113Z","comments":true,"path":"tags/index.html","permalink":"http://example.com/tags/index.html","excerpt":"","text":""},{"title":"分类","date":"2023-12-05T15:11:08.000Z","updated":"2023-12-05T15:59:36.842Z","comments":true,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""},{"title":"about","date":"2023-12-05T14:02:30.000Z","updated":"2023-12-05T14:04:01.430Z","comments":true,"path":"about/index.html","permalink":"http://example.com/about/index.html","excerpt":"","text":"其实没什么写的，但是不写，点了就会404.😶 ░░░░░░░░░░░▄▄░░░░░░░░░░░█░█░░░░░░░░░░░█░█░░░░░░░░░░█░░█░░░░░░░░░█░░░████████▄▄█░░░██████▄▓▓▓▓▓▓█░░░░░░░░░░░░█▓▓▓▓▓▓█░░░░░░░░░░░░█▓▓▓▓▓▓█░░░░░░░░░░░░█▓▓▓▓▓▓█░░░░░░░░░░░░█▓▓▓▓▓▓█░░░░░░░░░░░░█▓▓▓▓▓▓█████░░░░░░░░███████▀░░░▀▀██████▀"}],"posts":[{"title":"区块链的存储读取和管理","slug":"区块链的存储读取和管理","date":"2024-01-18T01:15:49.000Z","updated":"2024-01-31T04:55:32.046Z","comments":true,"path":"2024/01/18/区块链的存储读取和管理/","link":"","permalink":"http://example.com/2024/01/18/%E5%8C%BA%E5%9D%97%E9%93%BE%E7%9A%84%E5%AD%98%E5%82%A8%E8%AF%BB%E5%8F%96%E5%92%8C%E7%AE%A1%E7%90%86/","excerpt":"","text":"Go语言实现区块链存储、读取与管理。之前了解的基本结构，我们每次调试都要创建，重构区块链，但是区块链并没有的到保存，这与实际的区块链系统不符，伴随我们扩展我们的区块链，我们需要一个统一的功能管理模块来操作。 Badger键值对数据库对于区块链的储存，一种想法是序列化，然后用每个区块的哈希值作为文件名储存在磁盘上，但是考虑到我们频繁的对已经存储的区块进行查询，我们用数据库方式存储管理区块。 Badger是dgraph.io开发的一款基于 Log Structured Merge (LSM) Tree 的 key-value 本地数据库，什么键值对对应存储对应区块链的存储还是非常有意义的。 非常让人难以接受就是前几天写好的东西，关机忘了保存了，都得重新写，又不能因为已经学了一点了就写的唐突，想死。 1go get github.com/dgraph-io/badger 这个是安装的命令，安装还是比较简单的。但是不知道之前的版本为什么安装不了，可能是版本有点老了吧，然后换了个最新版的，问题就解决了。 存储地址设定创建一个tmp文件夹，就用来储存我们将要存储的区块链了。 打开constcoe.go设定一些全局变量。 123const TransactionPoolFile = &quot;./tmp/transaction_pool.data&quot; //缓冲池存放交易信息const BCPath = &quot;./tmp/blocks&quot;const BCFile = &quot;./tmp/blocks/MANIFEST&quot; 这三个是新的，而且这里当时也出问题了，问题就出在下文验证区块链存不存在的代码里，因为路径错了写成了.tmp然后一直就是验证文件不存在&#x3D; &#x3D;。我还去搜了是不是权限的问题或者其他的东西都占用了，果然代码这东西差之毫厘失之千里了。 BCPath与BCFile都是指向的我们即将创建的区块链数据库的相关地址。 util.go中增加一个检查文件地址下文件是否存在的函数。 123456func FileExists(fileAddr string) bool &#123; if _, err := os.Stat(fileAddr); os.IsNotExist(err) &#123; return false &#125; return true&#125; stat是获取文件信息的，不存在就返回错误，然后后边的isnotexist就是检车错误是不是代表文件不存在了。 区块改动奥对了，就是我写的代码都没有引入库因为软件自己就给我整了，不过用最基本的那个好像要手写引入的库的。 首先是创始区块的构建函数，我们希望他现在可以更加个性化一点，让创始交易信息指向我们提供的地址。 1234567//block.gofunc GenesisBlock(address []byte) *Block &#123; tx := transaaction.BaseTx(address)//初始交易 genesis := CreateBlock([]byte(&quot;YY&quot;), []*transaction.Transaction&#123;tx&#125;) genesis.SetHash() return genesis&#125; 然后我们的createblock函数是要用上一个区块的哈希和这个区块数据的，创世区块没有上一个区块，哈希就可以随便定义了。 123456789101112131415//block.gofunc (b *Block) Serialize() []byte &#123; var res bytes.Buffer//字节缓冲区 encoder := gob.NewEncoder(&amp;res)//编码器 err := encoder.Encode(b)//写入缓冲区 utils.Handle(err) return res.Bytes()&#125;func DeSerializeBlock(data []byte) *Block &#123; var block Block decoder := gob.NewDecoder(bytes.NewReader(data)) err := decoder.Decode(&amp;block) utils.Handle(err) return &amp;block 添加两个函数用来序列化和反序列化，数据库只能支持字节串的存储形式。 区块链结构体重构之前我们的区块链结构体是区块组成的切片，现在我们的区块存储在数据库中，所以我们的区块链结构体应该指向存储区块的数据库，重构我们的结构体 12345//blockchain.gotype BlockChain struct &#123; LastHash []byte Database *badger.DB&#125; LastHash属性是指当前区块链最后一个区块的哈希值，它并不是必须的，但可以避免我们在后面的函数编写中每次都去数据库中查找LastHash。 然后我们更改掉我们的CreateBlockChain，这个函数是创建一个区块链然后返回区块链的指针的，我们要实现区块链的创建存储和读取，就要删掉这个了。 123456789101112131415161718192021222324252627282930func InitBlockChain(address []byte) *BlockChain &#123; var lastHash []byte if utils.FileExists(constcoe.BCFile) &#123; fmt.Println(&quot;blockchain already exists&quot;) runtime.Goexit()//安全退出 &#125;//验证是不是已经创建了区块链了 opts := badger.DefaultOptions(constcoe.BCPath)//返回一个结构体就可以用来操作了 opts.Logger = nil//操作信息 db, err := badger.Open(opts) utils.Handle(err) err = db.Update(func(txn *badger.Txn) error &#123; genesis := GenesisBlock(address)//创建创世区块 fmt.Println(&quot;Genesis Created&quot;) err = txn.Set(genesis.Hash, genesis.Serialize())//哈希值和序列化后的数据 utils.Handle(err) err = txn.Set([]byte(&quot;lh&quot;), genesis.Hash) //store the hash of the block in blockchain utils.Handle(err) err = txn.Set([]byte(&quot;ogprevhash&quot;), genesis.PrevHash) //store the prevhash of genesis(original) block utils.Handle(err) lastHash = genesis.Hash return err &#125;) utils.Handle(err) blockchain := BlockChain&#123;lastHash, db&#125; return &amp;blockchain&#125; update把函数作为参数， 12345678910111213func (db *DB) Update(fn func(txn *Txn) error) error &#123; if db.opt.managedTxns &#123; panic(&quot;Update can only be used with managedDB=false.&quot;) &#125; txn := db.NewTransaction(true)//把引入的值txn作为一个事务这样你才可以在update内部的函数进行数据库操作。 defer txn.Discard() if err := fn(txn); err != nil &#123; return err &#125; return txn.Commit()&#125; 我们现在期望能够通过已有的数据库读取并加载我们的区块链，这就需要构建ContinueBlockChain函数。 1234567891011121314151617181920212223242526272829func ContinueBlockChain() *BlockChain &#123; if utils.FileExists(constcoe.BCFile) == false &#123; fmt.Println(&quot;No blockchain found, please create one first&quot;) runtime.Goexit() &#125; var lastHash []byte opts := badger.DefaultOptions(constcoe.BCPath) opts.Logger = nil db, err := badger.Open(opts) utils.Handle(err)//这上边跟上边一样 //view调取视图 err = db.View(func(txn *badger.Txn) error &#123; item, err := txn.Get([]byte(&quot;lh&quot;))//获取lh对应的最后区块的值，get获取键值对 utils.Handle(err)//处理错误 err = item.Value(func(val []byte) error &#123; lastHash = val return nil &#125;)//这一步作用就是提取这个item里的值，因为item是一个包括键和值的类型。 utils.Handle(err) return err &#125;) utils.Handle(err) chain := BlockChain&#123;lastHash, db&#125; return &amp;chain&#125; 要将一个区块加入到区块链中，就需要通过数据库来完成。修改AddBlock函数。 123456789101112131415161718192021222324252627282930//blockchain.gofunc (bc *BlockChain) AddBlock(newBlock *Block) &#123; var lastHash []byte//获取上一个区块的哈希值 err := bc.Database.View(func(txn *badger.Txn) error &#123; item, err := txn.Get([]byte(&quot;lh&quot;)) utils.Handle(err) err = item.Value(func(val []byte) error &#123; lastHash = val return nil &#125;) utils.Handle(err) return err &#125;) utils.Handle(err) if !bytes.Equal(newBlock.PrevHash, lastHash) &#123; fmt.Println(&quot;This block is out of age&quot;) runtime.Goexit() &#125;//判断新区快和上个区块哈希值是否对应 err = bc.Database.Update(func(transaction *badger.Txn) error &#123; err := transaction.Set(newBlock.Hash, newBlock.Serialize()) utils.Handle(err) err = transaction.Set([]byte(&quot;lh&quot;), newBlock.Hash) bc.LastHash = newBlock.Hash//将bc.LastHash设置为新区块的哈希值 return err &#125;) utils.Handle(err)&#125; 区块链的遍历尽管拥有ContinueBlockChain函数后我们实现了对区块链的加载，但是我们发现对于区块链的遍历不像之前那么方便了，FindUnspentTransactions函数一时不知如何修改。这里我们创建一个基于区块的迭代器来实现区块链的遍历。在blockchain.go中创建结构体。 12345//blockchain.gotype BlockChainIterator struct &#123; CurrentHash []byte Database *badger.DB&#125; 创建迭代器的初始化函数,在初始化时，将链的最后一个哈希值和数据库实例传递给迭代器。 12345//blockchain.gofunc (chain *BlockChain) Iterator() *BlockChainIterator &#123; iterator := BlockChainIterator&#123;chain.LastHash, chain.Database&#125; return &amp;iterator&#125; 创建迭代器的迭代函数，让每次迭代返回一个block，然后迭代器指向前一个区块的哈希值。 123456789101112131415161718192021//blockchain.gofunc (iterator *BlockChainIterator) Next() *Block &#123; var block *Block err := iterator.Database.View(func(txn *badger.Txn) error &#123; item, err := txn.Get(iterator.CurrentHash) utils.Handle(err) err = item.Value(func(val []byte) error &#123; block = DeSerializeBlock(val)//反序列化成为一个区块对象 return nil &#125;) utils.Handle(err) return err &#125;) utils.Handle(err) iterator.CurrentHash = block.PrevHash return block&#125; 接下来我们创建一个辅助函数来帮助判断迭代器是否终止。 12345678910111213141516171819//blockchain.gofunc (chain *BlockChain) BackOgPrevHash() []byte &#123; var ogprevhash []byte err := chain.Database.View(func(txn *badger.Txn) error &#123; item, err := txn.Get([]byte(&quot;ogprevhash&quot;)) utils.Handle(err) err = item.Value(func(val []byte) error &#123; ogprevhash = val return nil &#125;) utils.Handle(err) return err &#125;) utils.Handle(err) return ogprevhash&#125; 通过比较迭代器的CurrentHash与数据库存储的OgPrevHash是否相等就能够判断迭代器是否已经迭代到创始区块。 现在我们可以修改FindUnspentTransactions函数了。 12345678910111213141516171819202122232425262728293031323334353637383940414243//blockchain.gofunc (bc *BlockChain) FindUnspentTransactions(address []byte) []transaction.Transaction &#123; var unSpentTxs []transaaction.Transaction spentTxs := make(map[string][]int) // can&#x27;t use type []byte as key value iter := bc.Iterator()all: for &#123; block := iter.Next() for _, tx := range block.Transactions &#123; txID := hex.EncodeToString(tx.ID) IterOutputs: for outIdx, out := range tx.Outputs &#123; if spentTxs[txID] != nil &#123; for _, spentOut := range spentTxs[txID] &#123; if spentOut == outIdx &#123; continue IterOutputs &#125; &#125; &#125; if out.ToAddressRight(address) &#123; unSpentTxs = append(unSpentTxs, *tx) &#125; &#125; if !tx.IsBase() &#123; for _, in := range tx.Inputs &#123; if in.FromAddressRight(address) &#123; inTxID := hex.EncodeToString(in.TxID) spentTxs[inTxID] = append(spentTxs[inTxID], in.OutIdx) &#125; &#125; &#125; &#125; if bytes.Equal(block.PrevHash, bc.BackOgPrevHash()) &#123; break all &#125; &#125; return unSpentTxs&#125; 这里之前讲过了，还是很难理解的，还有那个迭代器&#x3D; &#x3D;。 交易信息池我们是一个区块内装好多交易信息，放在一个交易信息池中，当储存的信息达到一定量就进行挖矿操作，把节点加入区块链。 我们创建一个交易信息池的结构体。 1234//transactionpool.gotype TransactionPool struct &#123; PubTx []*transaction.Transaction&#125; PubTx用于储存节点收集到的交易信息。 1234//transactionpool.gofunc (tp *TransactionPool) AddTransaction(tx *transaction.Transaction) &#123; tp.PubTx = append(tp.PubTx, tx)&#125; 我们希望存储我们新收集到的交易信息，就需要能够保存我们的交易信息池这一结构体。 123456789//transactionpool.gofunc (tp *TransactionPool) SaveFile() &#123; var content bytes.Buffer encoder := gob.NewEncoder(&amp;content) err := encoder.Encode(tp) utils.Handle(err) err = ioutil.WriteFile(constcoe.TransactionPoolFile, content.Bytes(), 0644) utils.Handle(err)&#125; 加载我们的交易信息池。 12345678910111213141516171819202122func (tp *TransactionPool) LoadFile() error &#123; if !utils.FileExists(constcoe.TransactionPoolFile) &#123; return nil &#125; var transactionPool TransactionPool fileContent, err := ioutil.ReadFile(constcoe.TransactionPoolFile) if err != nil &#123; return err &#125; decoder := gob.NewDecoder(bytes.NewBuffer(fileContent)) err = decoder.Decode(&amp;transactionPool) if err != nil &#123; return err &#125; tp.PubTx = transactionPool.PubTx return nil&#125; 123456func CreateTransactionPool() *TransactionPool &#123; transactionPool := TransactionPool&#123;&#125; err := transactionPool.LoadFile() utils.Handle(err) return &amp;transactionPool&#125;","categories":[{"name":"区块链","slug":"区块链","permalink":"http://example.com/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/"}],"tags":[{"name":"区块链","slug":"区块链","permalink":"http://example.com/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"},{"name":"goland","slug":"goland","permalink":"http://example.com/tags/goland/"}]},{"title":"算法","slug":"算法","date":"2023-12-18T11:27:53.000Z","updated":"2024-01-11T06:44:18.762Z","comments":true,"path":"2023/12/18/算法/","link":"","permalink":"http://example.com/2023/12/18/%E7%AE%97%E6%B3%95/","excerpt":"","text":"1.P1000 超级玛丽游戏P1000 超级玛丽游戏 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn) 1234567package mainimport &quot;fmt&quot;func main() &#123;fmt.Println(&quot; ********\\n ************\\n ####....#.\\n #..###.....##....\\n ###.......###### ### ###\\n ........... #...# #...#\\n ##*####### #.#.# #.#.#\\n ####*******###### #.#.# #.#.#\\n ...#***.****.*###.... #...# #...#\\n ....**********##..... ### ###\\n ....**** *****....\\n #### ####\\n ###### ######\\n##############################################################\\n#...#......#.##...#......#.##...#......#.##------------------#\\n###########################################------------------#\\n#..#....#....##..#....#....##..#....#....#####################\\n########################################## #----------#\\n#.....#......##.....#......##.....#......# #----------#\\n########################################## #----------#\\n#.#..#....#..##.#..#....#..##.#..#....#..# #----------#\\n########################################## ############&quot;)&#125; 2.P1001 A+B ProblemP1001 A+B Problem - 洛谷 | 计算机科学教育新生态 (luogu.com.cn) 1234567891011package mainimport &quot;fmt&quot;func main() &#123; var a int var b int_,_=fmt.Scanln(&amp;a,&amp;b) var sum = a+bfmt.Println(sum)&#125; 3.P4327 [COCI2006-2007#1] Okviri[P4327 COCI2006-2007#1] Okviri - 洛谷 | 计算机科学教育新生态 (luogu.com.cn) 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768package mainimport ( &quot;fmt&quot; &quot;strings&quot;)func main() &#123; var input string fmt.Scan(&amp;input) input = strings.ToUpper(input) for g, _ := range input &#123; fmt.Print(&quot;.&quot;) if (g+1)%3 == 0 &#123; fmt.Print(&quot;.*.&quot;) continue &#125; fmt.Print(&quot;.#.&quot;) &#125; fmt.Print(&quot;.&quot;) fmt.Println(&quot;&quot;) fmt.Print(&quot;.&quot;) for g, _ := range input &#123; if (g+1)%3 == 0 &#123; fmt.Print(&quot;*.*.&quot;) continue &#125; fmt.Print(&quot;#.#.&quot;) &#125; fmt.Println(&quot;&quot;) fmt.Print(&quot;#&quot;) for g, va := range input &#123; if (g+2)%3 == 0 || (g+1)%3==0&#123; if g+1==len(input)&amp;&amp;(g+1)%3!=0 &#123; fmt.Printf(&quot;.%c.#&quot;, va) continue &#125; fmt.Printf(&quot;.%c.*&quot;, va) continue &#125; fmt.Printf(&quot;.%c.#&quot;,va) &#125; fmt.Println(&quot;&quot;) fmt.Print(&quot;.&quot;) for g, _ := range input &#123; if (g+1)%3 == 0 &#123; fmt.Print(&quot;*.*.&quot;) continue &#125; fmt.Print(&quot;#.#.&quot;) &#125; fmt.Println(&quot;&quot;) for g, _ := range input &#123; fmt.Print(&quot;.&quot;) if (g+1)%3 == 0 &#123; fmt.Print(&quot;.*.&quot;) continue &#125; fmt.Print(&quot;.#.&quot;) &#125; fmt.Print(&quot;.&quot;)&#125; 真的麻烦啊我超，差点没死了，不过就是控制语句的充分利用，成功了就觉得其实没什么难度了😶。 4.P1003 [NOIP2011 提高组] 铺地毯[P1003 NOIP2011 提高组] 铺地毯 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn) 1234567891011121314151617181920212223242526272829303132333435363738package mainimport (&quot;fmt&quot;)type di struct &#123;ditans []*ditan&#125;//这里定义的是数组类型的结构体嵌套？type ditan struct &#123; a int b int g int k int&#125;func creatditan(a,b,g,k int) *ditan &#123; ditan:=ditan&#123;a,b,g,k&#125; return &amp;ditan&#125;//输入数据输出一个ditan类型的结构体func (dit *di)addditan(a,b,g,k int)&#123;newditan:=creatditan(a,b,g,k)dit.ditans=append(dit.ditans,newditan)&#125;//把ditan加到di里，就可以数组调用了。func main() &#123; var ( n int l int a, b, g, k int ) fmt.Scan(&amp;n) var newditan di for l = 0; l &lt; n; l++ &#123;fmt.Scan(&amp;a, &amp;b, &amp;g, &amp;k) newditan.addditan(a, b, g, k) &#125; var (x,y int) fmt.Scan(&amp;x,&amp;y) var q = 0 for num,bb:=range newditan.ditans&#123; if (x&gt;=bb.a || x&lt;=(bb.g+bb.a))||(y&gt;=bb.b || y&lt;=(bb.k+bb.b))&#123; q+=1 fmt.Print(n-num) break&#125; &#125; if q==0 &#123;fmt.Print(-1)&#125;&#125; 这第一种方法，对结构体嵌套的那个算个扩展，实际下边的方法对于切片的使用更合适。 还有第二个方法 123456789101112131415161718192021222324252627282930313233343536package mainimport ( &quot;fmt&quot;)type Carpet struct &#123;x1, y1, x2, y2 int&#125;func main() &#123; var x,y intn := 0fmt.Scan(&amp;n)carpets := make([]Carpet, n)//这里可以直接定义一个数组类型的结构体。比上边方便多了for i := 0; i &lt; n; i++ &#123;fmt.Scan(&amp;carpets[i].x1, &amp;carpets[i].y1, &amp;carpets[i].x2, &amp;carpets[i].y2)&#125;fmt.Scan(&amp;x, &amp;y)maxCovered := -1covered := falsefor i := n - 1; i &gt;= 0; i-- &#123;if x &gt;= carpets[i].x1 &amp;&amp; x &lt;= (carpets[i].x2+carpets[i].x1) &amp;&amp; y &gt;= carpets[i].y1 &amp;&amp; y &lt;= (carpets[i].y2+carpets[i].y1) &#123;covered = truemaxCovered = i + 1break&#125;&#125;if covered &#123;fmt.Println(maxCovered)&#125; else &#123;fmt.Println(-1)&#125;&#125; 下边的方法更简单，因为上边的是我从区块链学的，忘了怎么整这个切片了😔。 5.P1035 [NOIP2002 普及组] 级数求和[P1035 NOIP2002 普及组] 级数求和 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn) 1234567891011121314151617package mainimport &quot;fmt&quot;func main() &#123; var k float64 var num float64 var n float64 = 1 fmt.Scan(&amp;k) for ; ; n++ &#123; num += (1 / n) if num &gt; k &#123; fmt.Println(n) break &#125; &#125;&#125; 这道题很简单啊，错误点就是会一直循环这是因为我们定义的数据类型是整形数据，改成浮点型就好了。 6.P1046 [NOIP2005 普及组] 陶陶摘苹果[P1046 NOIP2005 普及组] 陶陶摘苹果 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn) 1234567891011121314151617181920package mainimport &quot;fmt&quot;func main() &#123; var x1, x2, x3, x4, x5, x6, x7, x8, x9, x10 int fmt.Scan(&amp;x1, &amp;x2, &amp;x3, &amp;x4, &amp;x5, &amp;x6, &amp;x7, &amp;x8, &amp;x9, &amp;x10) a := []int&#123;x1, x2, x3, x4, x5, x6, x7, x8, x9, x10&#125; var high int var n int fmt.Scan(&amp;high) for _, h := range a &#123; if high &gt;= h &#123; n++ &#125; else if high+30 &gt;= h &#123; n++ &#125; &#125; fmt.Print(n)&#125; 很简单的一题，没什么强调的。 7.P1047 [NOIP2005 普及组] 校门外的树[P1047 NOIP2005 普及组] 校门外的树 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn) 12345678910111213141516171819202122232425package mainimport ( &quot;fmt&quot;)func main() &#123; var l, m int fmt.Scan(&amp;l, &amp;m) var a, b int list := make([]int, l+1) for ; m &gt; 0; m-- &#123; a = 0 b = 0 fmt.Scan(&amp;a, &amp;b) for ; a &lt;= b; a++ &#123; list[a] = 1 &#125; &#125; var num int for _, n := range list &#123; num += n &#125; fmt.Print(l + 1 - num)&#125; 这道题如果用那种划分范围的比大小太麻烦了，这种用切片的方法好像更好一点。 这道题出现一个错误就是定义list切片那一行，不然树木总数不一样。因为容量是从1开始的如果不加1的话就少一个了。 8.P1075 [NOIP2012 普及组] 质因数分解[P1075 NOIP2012 普及组] 质因数分解 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn) 傻方法但是超时 1234567891011121314151617181920212223242526272829303132333435package mainimport &quot;fmt&quot;func zhishu(int2 int) bool &#123; if int2 &lt;= 1 &#123; return false &#125; for i := 2; i &lt; int2; i++ &#123; if int2%i == 0 &#123; return false &#125; &#125; return true&#125;func maxzhishu(int2 int) (int, bool) &#123; for n := int2; n &gt;= 0; n-- &#123; if zhishu(n) &#123; if int2%n == 0 &#123; if zhishu(int2 / n) &#123; return n, true &#125; &#125; &#125; &#125; return 0, false&#125;func main() &#123; var num int fmt.Scan(&amp;num) num, bool := maxzhishu(num) if bool &#123; fmt.Print(num) &#125;&#125; 二解，其实我觉得他这个不太合适这个题。可能题目有问题。 1234567891011121314package mainimport &quot;fmt&quot;func main() &#123; var n, i int64 fmt.Scan(&amp;n) for i = 2; i &lt;= n; i++ &#123; if n%i == 0 &#123; fmt.Println(n / i) break &#125; &#125;&#125; 9.P1085 [NOIP2004 普及组] 不高兴的津津[P1085 NOIP2004 普及组] 不高兴的津津 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn) 12345678910111213141516171819202122232425262728package mainimport ( &quot;fmt&quot;)func main() &#123; var a, b, num int var n []int for i := 1; i &lt;= 7; i++ &#123; fmt.Scan(&amp;a, &amp;b) num = a + b n = append(n, num) &#125; max := 8 xingqi := 0 for we, time := range n &#123; if time &gt; max &#123; max = time xingqi = we + 1 &#125; &#125; if max &gt; 8 &#123; fmt.Print(xingqi) &#125; else &#123; fmt.Print(0) &#125;&#125; 注意比较大小，没有难度。 10.P1089 [NOIP2004 提高组] 津津的储蓄计划[P1089 NOIP2004 提高组] 津津的储蓄计划 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn) 1234567891011121314151617181920212223242526272829303132333435363738package mainimport &quot;fmt&quot;func main() &#123; var money int var sum int var lost int var a [12]int i := 1 for ; i &lt;= 12; i++ &#123; fmt.Scan(&amp;money) lost = lost + 300 - money if lost &gt;= 100 &#123; sum += lost - lost%100 lost = lost % 100 &#125; if lost &lt; 0 &#123; a[i] = 1 &#125; &#125; q := 0 for w, nu := range a &#123; if nu == 1 &#123; fmt.Print(-w) return &#125; if nu == 0 &#123; q++ if q == 12 &#123; var over1 float64 = float64(lost) var over float64 = float64(sum) fmt.Print(1.2*over + over1) &#125; &#125; &#125;&#125; 重点在类型转换和最后要加上12月没用完的钱呢。 11.P1150 Peter 的烟P1150 Peter 的烟 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn) 1234567891011121314151617181920212223242526package mainimport &quot;fmt&quot;func main() &#123; var n, k int fmt.Scan(&amp;n, &amp;k) var sum int var l, o int o = n for &#123; if o &lt; k &#123; o += l l = 0 &#125; if o &lt; k &#123; break &#125; if o &gt;= k &#123; o -= k l++ sum++ &#125; &#125; fmt.Print(n + sum)&#125; 没难度，就是有点绕弯。 12.P1151 子数整数P1151 子数整数 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn) 1234567891011121314151617181920212223package mainimport &quot;fmt&quot;func main() &#123; var k int fmt.Scan(&amp;k) var o int = 0 for i := 10000; i &lt;= 30000; i++ &#123; var s1, s2, s3 int s1 = (i - i%100) / 100 s2 = ((i % 10000) - (i%10000)%10) / 10 s3 = i % 1000 if s1%k == 0 &amp;&amp; s2%k == 0 &amp;&amp; s3%k == 0 &#123; fmt.Println(i) o++ &#125; &#125; if o == 0 &#123; fmt.Print(&quot;No&quot;) &#125;&#125; 没难度 13.P1152 欢乐的跳P1152 欢乐的跳 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn) 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647package mainimport ( &quot;fmt&quot;)func isAvailable(alpha []int, str int) bool &#123; for i := 0; i &lt; len(alpha); i++ &#123; if alpha[i] == str &#123; return true &#125; &#125; return false&#125;func main() &#123; var n, num int fmt.Scan(&amp;n) list := make([]int, n) for i := 0; i &lt;= n-1; i++ &#123; fmt.Scan(&amp;num) list[i] = num &#125; var cha []int var chazhi int for i := 0; i &lt;= n-2; i++ &#123; chazhi = list[i+1] - list[i] cha = append(cha, chazhi) &#125; for x, y := range cha &#123; if y &lt; 0 &#123; cha[x] = -y &#125; &#125; var t int for m := 1; m &lt;= n-1; m++ &#123; if isAvailable(cha, m) &#123; t = t + 1 &#125; if isAvailable(cha, m) == false &#123; fmt.Println(&quot;Not jolly&quot;) return &#125; &#125; if t &gt;= n-1 &#123; fmt.Print(&quot;Jolly&quot;) &#125;&#125; 没难度，添加个函数就过了。 14.P1161 开灯P1161 开灯 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn) 12345678910111213141516171819202122232425262728package mainimport &quot;fmt&quot;func main() &#123; var n int fmt.Scan(&amp;n) var t float64 var a float64 light := make(map[int]int) for i := 0; i &lt; n; i++ &#123; fmt.Scan(&amp;a, &amp;t) for n := 1.0; n &lt;= t; n++ &#123; b := int(a * n) if light[b] == 1 &#123; light[b] = 0 continue &#125; light[b] = 1 &#125; &#125; for k, l := range light &#123; if l == 1 &#123; fmt.Println(k) &#125; &#125;&#125; 从未有如此顺利的一道题，一次直接过，我只能说这题用映射真的没毛病。 15.P1179 [NOIP2010 普及组] 数字统计[P1179 NOIP2010 普及组] 数字统计 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn) 123456789101112131415161718192021222324252627package mainimport ( &quot;fmt&quot;)func main() &#123; var l, r, n, a int fmt.Scan(&amp;l, &amp;r) for e := r; e &gt;= 10; &#123; e = e / 10 a++ &#125; for ; l &lt;= r; l++ &#123; q := l if q%10 == 2 &#123; n++ &#125; for i := 1; i &lt;= a; i++ &#123; q = q / 10 if q%10 == 2 &#123; n++ &#125; &#125; &#125; fmt.Println(n)&#125; 到最后超时了，本来那个计算a的for循环是在下边的for里边的，不过感觉现在这个还是有好多计算是没用的，不过效率居然提高了一半多。 16.P1200 [USACO1.1] 你的飞碟在这儿 Your Ride Is Here[P1200 USACO1.1] 你的飞碟在这儿 Your Ride Is Here - 洛谷 | 计算机科学教育新生态 (luogu.com.cn) 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556package mainimport ( &quot;fmt&quot; &quot;math&quot;)func main() &#123; map1 := make(map[string]int) map1[&quot;A&quot;] = 1 map1[&quot;B&quot;] = 2 map1[&quot;C&quot;] = 3 map1[&quot;D&quot;] = 4 map1[&quot;E&quot;] = 5 map1[&quot;F&quot;] = 6 map1[&quot;G&quot;] = 7 map1[&quot;H&quot;] = 8 map1[&quot;I&quot;] = 9 map1[&quot;J&quot;] = 10 map1[&quot;K&quot;] = 11 map1[&quot;L&quot;] = 12 map1[&quot;M&quot;] = 13 map1[&quot;N&quot;] = 14 map1[&quot;O&quot;] = 15 map1[&quot;P&quot;] = 16 map1[&quot;Q&quot;] = 17 map1[&quot;R&quot;] = 18 map1[&quot;S&quot;] = 19 map1[&quot;T&quot;] = 20 map1[&quot;U&quot;] = 21 map1[&quot;V&quot;] = 22 map1[&quot;W&quot;] = 23 map1[&quot;X&quot;] = 24 map1[&quot;Y&quot;] = 25 map1[&quot;Z&quot;] = 26 var hui, dui string fmt.Scan(&amp;hui) fmt.Scan(&amp;dui) huin := 1 duin := 1 for _, Q := range hui &#123; P := string(Q) huin *= map1[P] &#125; for _, Q := range dui &#123; P := string(Q) duin *= map1[P] &#125; var duif = float64(duin) var huif = float64(huin) if math.Mod(duif, 47) == math.Mod(huif, 47) &#123; fmt.Println(&quot;GO&quot;) &#125; else &#123; fmt.Println(&quot;STAY&quot;) &#125;&#125; 类型转换多一点 17.P1304 哥德巴赫猜想P1304 哥德巴赫猜想 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn) 12345678910111213141516171819202122232425262728293031323334package mainimport ( &quot;fmt&quot;)func zhishu(n int) bool &#123; if n &lt;= 1 &#123; return false &#125; for i := 2; i &lt; n; i++ &#123; if n%i == 0 &#123; return false &#125; &#125; return true&#125;func zhishuhe(int2 int) (int, int) &#123; for i := 2; i &lt;= int2; i++ &#123; if zhishu(i) &amp;&amp; zhishu(int2-i) &#123; return i, (int2 - i) &#125; &#125; return 0, 0&#125;func main() &#123; var N int fmt.Scan(&amp;N) for i := 4; i &lt;= N; i += 2 &#123; x, y := zhishuhe(i) fmt.Print(i, &quot;=&quot;, x, &quot;+&quot;, y) fmt.Println() &#125;&#125; 写一个判断是否是质数的函数就ok了","categories":[{"name":"算法","slug":"算法","permalink":"http://example.com/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"goland","slug":"goland","permalink":"http://example.com/tags/goland/"},{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"Badger学习使用","slug":"Badger学习使用","date":"2023-12-18T08:49:04.000Z","updated":"2023-12-22T12:14:50.788Z","comments":true,"path":"2023/12/18/Badger学习使用/","link":"","permalink":"http://example.com/2023/12/18/Badger%E5%AD%A6%E4%B9%A0%E4%BD%BF%E7%94%A8/","excerpt":"","text":"BADGER简单实用简介一种kv引擎，KV 引擎是一种键值存储引擎，用于存储键值对。其中，键是唯一的标识符，值是任意数据类型。KV 引擎通常用于缓存、数据库等场景。是 go 生态中比较生产级的存储引擎。 安装指令输入 1go get github.com/dgraph-io/badger 在这里我的安装出了一些错误，所以我是自己下载的然后自己安装的，如果你也出错了可以下载仓库 · Gitee 极速下载&#x2F;Badger - Gitee.com下载之后，通过goland的命令行cd到你下载&#x2F;badger里，然后命令行输入go install就好了。 数据库操作打开数据库123456789101112131415161718func Open(path string) (*badger.DB, error) &#123; if _, err := os.Stat(path); os.IsNotExist(err) &#123; os.MkdirAll(path, 0755) &#125; opts := badger.DefaultOptions(path) opts.Dir = path opts.ValueDir = path opts.SyncWrites = false opts.ValueThreshold = 256 opts.CompactL0OnClose = true db, err := badger.Open(opts) if err != nil &#123; log.Println(&quot;badger open failed&quot;, &quot;path&quot;, path, &quot;err&quot;, err) return nil, err &#125; return db, nil&#125; 用于打开或创建Badger数据库的函数。 函数名为Open，接受一个字符串类型的参数path，表示数据库文件的路径。函数返回一个指向badger.DB类型的指针和一个错误信息。 函数首先使用os.Stat(path)检查指定路径是否存在。如果不存在，则使用os.MkdirAll(path, 0755)创建该路径及其所有父目录，并设置权限为755。 接下来，函数创建一个badger.DefaultOptions(path)对象，用于配置Badger数据库的选项。这些选项包括： Dir: 数据库文件所在的目录。 ValueDir: 存储值的目录。 SyncWrites: 是否同步写入磁盘。设置为false可以提高性能，但可能会降低数据的一致性。 ValueThreshold: 触发L0压缩的阈值。当存储的值数量超过这个阈值时，会触发L0压缩以释放空间。 CompactL0OnClose: 是否在关闭数据库时自动进行L0压缩。设置为true可以在程序结束时自动压缩，减少磁盘空间的使用。 然后，函数使用badger.Open(opts)打开或创建数据库，并将结果赋值给变量db。如果打开过程中出现错误，函数会记录错误信息，并返回nil和错误信息。 最后，函数返回指向数据库的指针和nil作为错误信息，表示成功打开了数据库。 内存模式&#x2F;无盘模式默认Badger 所有数据都保存在磁盘上。它还支持纯内存模式。当 Badger 在内存模式下运行时，所有数据都存储在内存中。在内存模式下读写速度要快得多，但在崩溃或关闭的情况下，存储在 Badger 中的所有数据都会丢失。要在内存模式下打开 badger，设置InMemory选项。 1opts := badger.DefaultOptions(path).WithInMemory(true) 关闭数据库12345678func Close() &#123; err := badgerDB.Close() if err == nil &#123; log.Println(&quot;database closed&quot;, &quot;err&quot;, err) &#125; else &#123; log.Println(&quot;failed to close database&quot;, &quot;err&quot;, err) &#125;&#125; 的作用是关闭一个名为badgerDB的数据库连接。在函数内部，首先调用badgerDB.Close()方法来关闭数据库连接，并将返回的错误信息存储在变量err中。然后，通过判断err是否为nil来确定关闭操作是否成功。如果err为nil，则表示关闭操作成功，使用log.Println打印一条日志信息，显示”database closed”和错误信息；否则，表示关闭操作失败，同样使用log.Println打印一条日志信息，显示”failed to close database”和错误信息。 存储操作写入数据保存键值对，使用下面Txn.Set()方法。 12345678910111213func Set(key []byte, value []byte) &#123; wb := badgerDB.NewWriteBatch() defer wb.Cancel() err := wb.SetEntry(badger.NewEntry(key, value).WithMeta(0)) if err != nil &#123; log.Println(&quot;Failed to write data to cache.&quot;,&quot;key&quot;, string(key), &quot;value&quot;, string(value), &quot;err&quot;, err) &#125; err = wb.Flush() if err != nil &#123; log.Println(&quot;Failed to flush data to cache.&quot;,&quot;key&quot;, string(key), &quot;value&quot;, string(value), &quot;err&quot;, err) &#125;&#125; 这段代码是一个用于将键值对存储到Badger数据库中的函数。函数名为Set，接受两个参数：key和value，它们都是字节切片类型。 函数内部首先创建了一个badgerDB.WriteBatch()对象，命名为wb。然后使用defer wb.Cancel()来确保在函数执行完毕后取消批处理操作。 接下来，通过调用wb.SetEntry(badger.NewEntry(key, value).WithMeta(0))将键值对存储到数据库中。这里使用了badger.NewEntry(key, value)来创建一个键值对条目，并通过.WithMeta(0)设置元数据为0。 如果存储过程中出现错误，会捕获异常并打印日志信息，包括”Failed to write data to cache.”、键、值和错误信息。 最后，调用wb.Flush()将批处理中的所有更改刷新到数据库中。如果刷新过程中出现错误，同样会捕获异常并打印日志信息，包括”Failed to flush data to cache.”、键、值和错误信息。 请注意，这段代码中的badgerDB是一个未定义的变量，你需要在使用之前进行初始化或导入相应的库。 通过使用defer关键字，可以在函数执行完毕后自动调用wb.Cancel()方法来释放这些资源，避免资源泄漏和系统性能下降。 设置TTL的写入数据Badger 允许在键上设置可选的生存时间 (TTL) 值。一旦 TTL 过去，密钥将不再可检索，并且将有资格进行垃圾收集。 可以使用和API 方法将 TTL 设置为time.Duration值。 123456789101112func SetWithTTL(key []byte, value []byte, ttl int64) &#123; wb := badgerDB.NewWriteBatch() defer wb.Cancel() err := wb.SetEntry(badger.NewEntry(key, value).WithMeta(0).WithTTL(time.Duration(ttl * time.Second.Nanoseconds()))) if err != nil &#123; log.Println(&quot;Failed to write data to cache.&quot;,&quot;key&quot;, string(key), &quot;value&quot;, string(value), &quot;err&quot;, err) &#125; err = wb.Flush() if err != nil &#123; log.Println(&quot;Failed to flush data to cache.&quot;,&quot;key&quot;, string(key), &quot;value&quot;, string(value), &quot;err&quot;, err) &#125;&#125; 名为SetWithTTL的函数，它接受三个参数：key、value和ttl。该函数的作用是将键值对存储到Badger数据库中，并设置一个过期时间（TTL）。 函数内部首先创建了一个badgerDB.WriteBatch()对象，命名为wb。然后使用defer wb.Cancel()来确保在函数执行完毕后取消批处理操作。 接下来，通过调用wb.SetEntry()方法将键值对存储到数据库中。在该方法中，使用badger.NewEntry(key, value)创建一个键值对条目，并通过.WithMeta(0)设置元数据为0。然后，使用.WithTTL(time.Duration(ttl * time.Second.Nanoseconds()))设置过期时间为传入的ttl参数所表示的时间。 如果在存储过程中出现错误，会捕获异常并打印日志信息，包括”Failed to write data to cache.”、键、值和错误信息。 最后，调用wb.Flush()将批处理中的更改刷新到数据库中。如果刷新过程中出现错误，同样会捕获异常并打印日志信息，包括”Failed to flush data to cache.”、键、值和错误信息。 请注意，这段代码中的badgerDB是一个未定义的变量，需要在使用之前进行初始化或导入相应的库。 读取数据要读取数据，我们可以使用以下Txn.Get()方法 123456789101112131415func Get(key []byte) string &#123; var ival []byte err := badgerDB.View(func(txn *badger.Txn) error &#123; item, err := txn.Get(key) if err != nil &#123; return err &#125; ival, err = item.ValueCopy(nil) return err &#125;) if err != nil &#123; log.Println(&quot;Failed to read data from the cache.&quot;,&quot;key&quot;, string(key), &quot;error&quot;, err) &#125; return string(ival)&#125; 接受一个字节切片作为参数（key），并返回一个字符串。这个函数的主要目的是从名为badgerDB的数据库中读取数据。 函数首先声明了一个空的字节切片ival，用于存储从数据库中获取的值。然后，它调用badgerDB的View方法，该方法接受一个匿名函数作为参数。这个匿名函数接受一个badger.Txn类型的参数txn，并返回一个错误。 在匿名函数内部，首先尝试从数据库中获取与给定键关联的项目。如果发生错误，函数将立即返回错误。否则，它将使用item.ValueCopy方法将项目的值复制到ival切片中。如果在复制过程中发生错误，函数也将返回错误。 最后，如果在整个过程中发生任何错误，函数将使用log.Println打印一条错误消息，包括键和错误信息。如果没有错误，函数将返回ival切片转换为字符串的结果。 存在键1234567891011121314151617func Has(key []byte) (bool, error) &#123; var exist bool = false err := badgerDB.View(func(txn *badger.Txn) error &#123; _, err := txn.Get(key) if err != nil &#123; return err &#125; else &#123; exist = true &#125; return err &#125;) // align with leveldb, if the key doesn&#x27;t exist, leveldb returns nil if strings.HasSuffix(err.Error(), &quot;not found&quot;) &#123; err = nil &#125; return exist, err&#125; 名为Has的函数，它接受一个字节切片类型的参数key，并返回一个布尔值和一个错误。该函数的作用是检查给定的键是否存在于数据库中。 函数内部首先声明了一个布尔变量exist并将其初始化为false。然后，使用badgerDB.View方法来遍历数据库中的每个事务。在每个事务中，通过调用txn.Get(key)来获取与给定键关联的值。如果获取成功，则将exist设置为true。如果在获取过程中发生错误，则直接返回该错误。 最后，根据错误信息判断是否找到了对应的键。如果错误信息以”not found”结尾，说明没有找到对应的键，此时将错误设置为nil。最终，函数返回exist和err两个值，其中exist表示键是否存在，err表示可能发生的错误。 删除键使用Txn.Delete()方法删除 key。 12345func Delete(key []byte) error &#123; wb := badgerDB.NewWriteBatch() defer wb.Cancel() return wb.Delete(key)&#125; 这段代码是一个用于删除键值对的函数。它使用了BadgerDB数据库，并使用Delete方法来删除指定的键。 函数的参数是key，它是一个字节切片（[]byte），表示要删除的键。 函数内部首先创建了一个WriteBatch对象wb，然后使用defer wb.Cancel()确保在函数执行完毕后取消批处理操作。最后，通过调用wb.Delete(key)来删除指定的键，并返回错误信息。 请注意，这段代码中的badgerDB是一个未定义的变量，你需要在使用之前将其初始化为一个有效的BadgerDB实例。 查询操作遍历key和value要迭代键，我们可以使用Iterator，可以使用 Txn.NewIterator()方法获得。迭代以按字节排序的字典顺序发生。 12345678910111213141516171819202122232425func IteratorKeysAndValues()&#123; err := badgerDB.View(func(txn *badger.Txn) error &#123; opts := badger.DefaultIteratorOptions opts.PrefetchSize = 10 it := txn.NewIterator(opts) defer it.Close() for it.Rewind(); it.Valid(); it.Next() &#123; item := it.Item() k := item.Key() err := item.Value(func(v []byte) error &#123; fmt.Printf(&quot;key=%s, value=%s\\n&quot;, k, v) return nil &#125;) if err != nil &#123; return err &#125; &#125; return nil &#125;) if err != nil &#123; log.Println(&quot;Failed to iterator keys and values from the cache.&quot;,&quot;error&quot;, err) &#125;&#125; 名为IteratorKeysAndValues。它的作用是遍历BadgerDB数据库中的所有键值对，并打印出每个键和对应的值。 函数内部使用了badgerDB.View方法来创建一个事务视图，然后使用txn.NewIterator方法创建一个新的迭代器对象it。通过设置迭代器的选项opts，可以指定预取大小为10。 接下来，函数使用it.Rewind()将迭代器重置到第一个元素，然后使用it.Valid()判断是否还有下一个元素。如果有，就使用it.Next()移动到下一个元素。在每次迭代中，函数使用it.Item()获取当前元素的键值对，并将其存储在变量item中。 然后，函数使用item.Key()获取键，并将其存储在变量k中。接着，函数使用item.Value()获取值，并将其存储在一个匿名函数中。在这个匿名函数中，使用fmt.Printf打印出键和值。 如果在获取值的过程中发生错误，函数会返回该错误。如果迭代完成，函数会返回nil。 最后，函数使用log.Println记录日志信息，如果迭代过程中发生错误，会输出”Failed to iterator keys and values from the cache.”以及错误信息。 遍历keysBadger 支持一种独特的迭代模式，称为key-only迭代。它比常规迭代快几个数量级，因为它只涉及对 LSM 树的访问，它通常完全驻留在 RAM 中。要启用仅键迭代，您需要将该IteratorOptions.PrefetchValues 字段设置为false. 这也可用于在迭代期间对选定键进行稀疏读取，item.Value()仅在需要时调用。 123456789101112131415161718func IteratorKeys()&#123; err := badgerDB.View(func(txn *badger.Txn) error &#123; opts := badger.DefaultIteratorOptions opts.PrefetchValues = false it := txn.NewIterator(opts) defer it.Close() for it.Rewind(); it.Valid(); it.Next() &#123; item := it.Item() k := item.Key() fmt.Printf(&quot;key=%s\\n&quot;, k) &#125; return nil &#125;) if err != nil &#123; log.Println(&quot;Failed to iterator keys from the cache.&quot;,&quot;error&quot;, err) &#125;&#125; 这段代码是一个名为IteratorKeys的函数，它用于遍历BadgerDB数据库中的所有键。函数内部使用了badgerDB.View方法来创建一个事务视图，然后使用txn.NewIterator方法创建一个新的迭代器对象it。通过设置迭代器的选项opts，可以指定预取值（PrefetchValues）为false。 在迭代过程中，函数使用it.Rewind()将迭代器重置到第一个元素，然后使用it.Valid()判断是否还有下一个元素。如果有，就使用it.Next()移动到下一个元素。在每次迭代中，函数使用it.Item()获取当前元素的键值对，并将其存储在变量item中。然后，使用item.Key()获取键，并将其存储在变量k中。最后，使用fmt.Printf打印出键。 如果迭代过程中发生错误，函数会返回该错误。如果迭代完成，函数会返回nil。 如果在执行过程中出现错误，函数会使用log.Println记录日志信息，并输出”Failed to iterator keys from the cache.”以及错误信息。 前缀扫描要遍历一个键前缀，您可以组合Seek()and ValidForPrefix()： 12345678910111213141516171819202122func SeekWithPrefix(prefixStr string)&#123; err := badgerDB.View(func(txn *badger.Txn) error &#123; it := txn.NewIterator(badger.DefaultIteratorOptions) defer it.Close() prefix := []byte(prefixStr) for it.Seek(prefix); it.ValidForPrefix(prefix); it.Next() &#123; item := it.Item() k := item.Key() err := item.Value(func(v []byte) error &#123; fmt.Printf(&quot;key=%s, value=%s\\n&quot;, k, v) return nil &#125;) if err != nil &#123; return err &#125; &#125; return nil &#125;) if err != nil &#123; log.Println(&quot;Failed to seek prefix from the cache.&quot;, &quot;prefix&quot;, prefixStr,&quot;error&quot;, err) &#125;&#125; 这段代码是一个名为SeekWithPrefix的函数，它接受一个字符串参数prefixStr。该函数使用BadgerDB数据库进行操作，并遍历所有以给定前缀开头的键值对。 函数内部首先创建一个迭代器对象it，然后使用txn.NewIterator(badger.DefaultIteratorOptions)方法初始化迭代器。接下来，将prefixStr转换为字节切片prefix，并使用it.Seek(prefix)方法从第一个匹配的前缀开始遍历。 在循环中，每次迭代都会检查当前项是否仍然具有相同的前缀，这是通过调用it.ValidForPrefix(prefix)实现的。如果当前项仍然具有相同的前缀，则继续执行循环体中的代码。 在循环体中，首先获取当前项的键和值，分别存储在变量k和v中。然后，使用item.Value()方法获取值，并将其打印出来。最后，返回nil表示成功处理了当前项。 如果在处理过程中发生错误，函数会立即返回错误信息。否则，在循环结束后返回nil表示成功完成遍历。 如果在执行过程中出现任何错误，函数会使用log.Println()记录日志信息，包括前缀字符串、错误信息等。","categories":[{"name":"区块链","slug":"区块链","permalink":"http://example.com/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/"}],"tags":[{"name":"区块链","slug":"区块链","permalink":"http://example.com/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"},{"name":"goland","slug":"goland","permalink":"http://example.com/tags/goland/"},{"name":"数据库","slug":"数据库","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"}]},{"title":"UTXO代码的加入","slug":"fileUTXO代码的加入","date":"2023-12-03T05:28:37.000Z","updated":"2023-12-13T12:59:11.245Z","comments":true,"path":"2023/12/03/fileUTXO代码的加入/","link":"","permalink":"http://example.com/2023/12/03/fileUTXO%E4%BB%A3%E7%A0%81%E7%9A%84%E5%8A%A0%E5%85%A5/","excerpt":"","text":"交易信息与UTXO模型区块链中的货币存储是记录交易的过程，而非记录最终的货币数量。平时使用支付宝和微信支付时，货币的存储在中央，所以调用和更改很容易，在确保中心诚实可信的情况下，我们的货币才是安全的，但是一旦它被攻破或者服务器出现问题，那么交易就会被终止，我们的货币也处在一种不安全的状态。uxto记录的交易过程拥有一个存在输入和输出的账本，剩余的货币则会在创建一个输出到自己的过程。 首先创建交易信息的两部分，input和output。 首先创建一个transaction文件夹，用于分类，装我们要用的交易内容一类。 首先创建inoutput.go创建结构体作交易账本。分为两部分。 123456789type TXoutput struct &#123; Value int Toaddress []byte&#125;type TXintput struct&#123; TXid []byte Outidx int Fromaddress []byte&#125; 输入的有txid是上一次交易的信息，还有有发起人的地址和位于上次交易的第几条。输出的是输出多少币和接收者的地址。 创建transaction.go，放入本次交易的结构体 12345type Transaction struct &#123; Id []byte Inputs []TXintput Outputs []TXoutput&#125; 首字母大写才能在别的file里边用这些参数，不然没办法引用的。 transaction里由本身的哈希值和输入输出的交易。inouts则会记载上一次交易中对本id进行的outputs。txoutput则可以实现找零，即多出来的币要交易给自己。 首先计算每个transaction的哈希值。然后返回充当id。 12345678910111213func (tx *Transaction)TXhash() []byte &#123; var encoded bytes.Buffer var hash [32]byte encoder:=gob.NewEncoder(&amp;encoded) err:=encoder.Encode(tx) utils.Handle(err) hash=sha256.Sum256(encoded.Bytes()) return hash[:]&#125;func (tx* Transaction)Setid() &#123; tx.Id=tx.TXhash()&#125; var encoded bytes.Buffer创建一个字节缓冲区，用于事后的编码和哈希值的计算。而handle我们之前已经说过了，是处理错误的函数 第二步setid将计算好的哈希值返回给结构体。 之前创建了初始区块，现在丰富一下初始区块的交易信息作为内容，之前的date得淘汰了。 123456789func BaseTX (toaddress []byte) *Transaction &#123; txin:=TXintput&#123;[]byte&#123;&#125;,-1,[]byte&#123;&#125;&#125; txout:=TXoutput&#123;constcoe.Initcoin,toaddress&#125; tx:=Transaction&#123;[]byte(&quot;god&quot;),[]TXintput&#123;txin&#125;,[]TXoutput&#123;txout&#125;&#125; return &amp;tx&#125;func (tx *Transaction )Isbase() bool&#123; return len(tx.Inputs)==1 &amp;&amp; tx.Inputs[0].Outidx==-1 创建一个basetx的函数，输入第一笔交易要给的地址，因为第一笔交易之前没有交易，所以-1表示。constcoe则是我们定义的常量用作我们创建时的总的比特币数目，我们转到之前就创建的constcoe.go中设置。 12const Difficulty = 10const Initcoin=500 isbase则判断是否是初始交易，用作之后的计算utxo的辅助。只用判断长度是不是1，和内容的outidx是不是-1就好了。 我们上边设置了第一笔交易的内容，id我们也可以自己设置。这是一种特权。 123456func (in *TXintput)Fromaddressright(address []byte) bool&#123; return bytes.Equal(in.Fromaddress,address)&#125;func (out *TXoutput)Toaddressright(address []byte) bool&#123;return bytes.Equal(out.Toaddress,address)&#125; 转到inoutput.go创建上边的俩个函数，以后计算utxo时能起到辅助作用。 现在代码写完了，重构一下之前的内容。首先是结构体block。 12345678type Block struct &#123; Timestamp int64 Hash []byte PrevHash []byte Target []byte Nonce int64 transactions []*transaaction.Transaction&#125; 在返回区块哈希的函数中，我们创建一个函数来处理交易信息，让它成为一个序列。 12345678910111213func (b *Block)Backtrasactionsummary() []byte &#123; txids:=make([][]byte,0) for _,tx:=range b.transactions&#123; txids=append(txids,tx.Id) &#125; summary:=bytes.Join(txids,[]byte&#123;&#125;) return summary&#125;func (b *Block) SetHash() &#123; information := bytes.Join([][]byte&#123;utils.ToHexInt(b.Timestamp), b.PrevHash, b.Target,utils.ToHexInt(b.Nonce),b.Backtrasactionsummary()&#125;, []byte&#123;&#125;) hash := sha256.Sum256(information) b.Hash = hash[:]&#125; 内容就是先创建一个空切片用来装集合起来的交易数据，遍历整个交易数据，将输入输出的哈希值也就是id集合起来进行哈希值的计算。 用到的append函数和join函数都与切片的操作有关系，append函数如果原始切片有足够的容量，新元素会被添加到原切片的后面；如果没有足够容量，则会重新分配内存并拷贝原有元素和新元素。此外，append函数还可以用于合并多个数组或切片。它是一个内置函数，无需引入任何包即可使用。join函数不是Go语言的标准库函数，因此可能需要根据具体的应用场景来实现。一般来说，join可能用于将多个字符串或其他类型的元素连接成一个单独的字符串或元素。 在这里的append输出切片没办法勇总哈希值计算，所以用bytes.join转为字节切片再输出。 然后修改CreateBlock与GenesisBlock两个函数。 123456789101112func CreateBlock(prevhash []byte, txs []*transaaction.Transaction) *Block &#123; block := Block&#123;time.Now().Unix(), []byte&#123;&#125;, prevhash, []byte&#123;&#125;, 0, txs&#125; block.Target = block.GetTarget() block.Nonce=block.FindNonce() block.SetHash() return &amp;block&#125;func GenesisBlock() *Block &#123;tx:=transaaction.BaseTX([]byte(&quot;yangyan&quot;)) return CreateBlock([]byte&#123;&#125;, []*transaaction.Transaction&#123;tx&#125;)&#125; 我们在创建创世区块的同时一并创建了初始交易信息，并且把所有的币都转了。 现在转到proofofwork.go修改getbse4nonce函数。 函数用作合成带随机数的数据。 123456789101112func (b *Block) GetBase4Nonce(nonce int64) []byte &#123; data := bytes.Join([][]byte&#123; utils.ToHexInt(b.Timestamp), b.PrevHash, utils.ToHexInt(int64(nonce)), b.Target, b.Backtrasactionsummary(), &#125;, []byte&#123;&#125;, ) return data&#125; 修改AddBlock与CreateBlockChain两个函数。 12345678910func (bc *BlockChain) AddBlock(txs []*transaaction.Transaction) &#123; newBlock := CreateBlock(bc.Blocks[len(bc.Blocks)-1].Hash, txs) bc.Blocks = append(bc.Blocks, newBlock)&#125;func CreateBlockChain() *BlockChain &#123; blockchain := BlockChain&#123;&#125; blockchain.Blocks = append(blockchain.Blocks, GenesisBlock()) return &amp;blockchain&#125; 接下来如果创建createtransaction这样的函数，创建交易信息重点就在于找到足够的前置交易信息来支撑本次交易。 12345678910111213141516171819202122232425262728293031323334func (bc *BlockChain)Findunspentransactions(address []byte)[]transaaction.Transaction &#123;var unspenttxs []transaaction.Transaction spenttxs:=make(map[string][]int) for idx:=len(bc.Blocks)-1;idx&gt;=0;idx-- &#123; block:=bc.Blocks[idx] for _,tx:=range block.transactions&#123; txid:=hex.EncodeToString(tx.Id) interoutputs: for outidx,out:=range tx.Outputs&#123; if spenttxs[txid]!=nil &#123; for _,spentout:=range spenttxs[txid]&#123; if spentout == outidx&#123; continue interoutputs &#125; &#125; &#125; if out.Toaddressright(address)&#123; unspenttxs=append(unspenttxs,*tx) &#125; &#125; if !tx.Isbase() &#123; for _,in:=range tx.Inputs&#123; if in.Fromaddressright(address)&#123; intxid:=hex.EncodeToString(in.TXid) spenttxs[intxid]=append(spenttxs[intxid],in.Outidx) &#125; &#125; &#125; &#125; &#125;return unspenttxs&#125; 这段代码解读就是先创建一个没有花费的结构体集合和一个用于装已经花费的映射，映射里是id映射前置第几比交易。进行区块的倒循环，遍历没一个区块的id。然后遍历输出的地址在映射里是不是能找得到，找得到的话切片里也对的上也是前置交易的第几比交易，那么就是已经花费并且已经记录的交易。如果不一样那么看是不是输入到这个地址，如果是那就是没被花费的。判断是否是初始交易如果不是即遍历前置交易，如果是对应的地址就代表已经花费，则计入映射和来自前置交易第几比交易。 有点乱，理解一下就懂了 利用findunspenttransactions函数返回的没消费的交易，我们可以计算一个地址的所有uxto。 123456789101112131415161718func (bc *BlockChain) FindUTXOs(address []byte) (int, map[string]int) &#123; unspentOuts := make(map[string]int) unspentTxs := bc.Findunspentransactions(address) accumulated := 0Work: for _, tx := range unspentTxs &#123; txID := hex.EncodeToString(tx.Id) for outIdx, out := range tx.Outputs &#123; if out.Toaddressright(address) &#123; accumulated += out.Value unspentOuts[txID] = outIdx//如果一笔交易有好多次转向这个地址的交易，只会记录最后一笔的outidx continue Work &#125; &#125; &#125; return accumulated, unspentOuts&#125; 遍历没有花费的交易里边的outputs，遍历一下把value汇总一下，地址添加到索引里。每个交易只能有一个输出跟给定的地址相关联。 123456789101112131415161718192021func (bc *BlockChain)Findspendableoutputs(address []byte,amount int)(int,map[string]int) &#123; unspentouts := make(map[string]int) unspenttxs := bc.Findunspentransactions(address) accumulated:=0 work: for _,tx:=range unspenttxs&#123; txid:=hex.EncodeToString(tx.Id) for outidx,out:=range tx.Outputs&#123; if out.Toaddressright(address)&amp;&amp;accumulated&lt;amount&#123; accumulated+=out.Value unspentouts[txid]=outidx if accumulated&gt;=amount&#123;break work &#125; continue work &#125; &#125; &#125; return accumulated,unspentouts 只需要找到资产总量大于本次交易转账的一部分utxo就可以了，没必要每一笔都计算在内。 1234567891011121314151617181920212223func (bc *BlockChain)Creatransaction(from,to []byte,amount int)(*transaaction.Transaction,bool) &#123; var inputs []transaaction.TXintput var outputs []transaaction.TXoutput acc,validoutputs:=bc.Findspendableoutputs(from,amount) if acc&lt;amount&#123; fmt.Println(&quot;不够&quot;) return &amp;transaaction.Transaction&#123;&#125;,false &#125; for txid,outidx:=range validoutputs &#123; txid,err:=hex.DecodeString(txid) utils.Handle(err) intput:=transaaction.TXintput&#123;txid,outidx,from&#125; inputs=append(inputs,intput) &#125; outputs = append(outputs, transaaction.TXoutput&#123;amount, to&#125;) if acc &gt; amount &#123; outputs = append(outputs, transaaction.TXoutput&#123;acc - amount, from&#125;) &#125; tx := transaaction.Transaction&#123;nil, inputs, outputs&#125; tx.Setid() return &amp;tx, true&#125; 这一段函数比较简单，先小于再等于再大于，小于就报错返回不够，等于就直接输出，大于就在等于的基础上添加一笔将剩余币返回给自己的程序。 123func (bc *BlockChain)Mine(txs []*transaaction.Transaction) &#123; bc.AddBlock(txs)&#125; 这段函数模拟矿工的打包过程 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879func main() &#123; txPool := make([]*transaaction.Transaction, 0) var tempTx *transaaction.Transaction var ok bool var property int chain := blockchain.CreateBlockChain() property, _ = chain.FindUTXOs([]byte(&quot;yangyan&quot;)) fmt.Println(&quot;Balance of yangyan: &quot;, property) tempTx, ok = chain.Creatransaction([]byte(&quot;yangyan&quot;), []byte(&quot;K&quot;), 100) if ok &#123; txPool = append(txPool, tempTx) &#125; chain.Mine(txPool) txPool = make([]*transaaction.Transaction, 0) property, _ = chain.FindUTXOs([]byte(&quot;Leo Cao&quot;)) fmt.Println(&quot;Balance of yangyan: &quot;, property) tempTx, ok = chain.Creatransaction([]byte(&quot;K&quot;), []byte(&quot;E&quot;), 200) // this transaction is invalid if ok &#123; txPool = append(txPool, tempTx) &#125; tempTx, ok = chain.Creatransaction([]byte(&quot;K&quot;), []byte(&quot;E&quot;), 50) if ok &#123; txPool = append(txPool, tempTx) &#125; tempTx, ok = chain.Creatransaction([]byte(&quot;yangyan&quot;), []byte(&quot;E&quot;), 100) if ok &#123; txPool = append(txPool, tempTx) &#125; chain.Mine(txPool) txPool = make([]*transaaction.Transaction, 0) property, _ = chain.FindUTXOs([]byte(&quot;yangyan&quot;)) fmt.Println(&quot;Balance of Leo Cao: &quot;, property) property, _ = chain.FindUTXOs([]byte(&quot;K&quot;)) fmt.Println(&quot;Balance of Krad: &quot;, property) property, _ = chain.FindUTXOs([]byte(&quot;E&quot;)) fmt.Println(&quot;Balance of Exia: &quot;, property) for _, block := range chain.Blocks &#123; fmt.Printf(&quot;Timestamp: %d\\n&quot;, block.Timestamp) fmt.Printf(&quot;hash: %x\\n&quot;, block.Hash) fmt.Printf(&quot;Previous hash: %x\\n&quot;, block.PrevHash) fmt.Printf(&quot;nonce: %d\\n&quot;, block.Nonce) fmt.Println(&quot;Proof of Work validation:&quot;, block.ValidatePoW()) &#125; //展示一下双花问题 tempTx, ok = chain.Creatransaction([]byte(&quot;Krad&quot;), []byte(&quot;E&quot;), 30) if ok &#123; txPool = append(txPool, tempTx) &#125; tempTx, ok = chain.Creatransaction([]byte(&quot;Krad&quot;), []byte(&quot;yangyan&quot;), 30) if ok &#123; txPool = append(txPool, tempTx) &#125; chain.Mine(txPool) txPool = make([]*transaaction.Transaction, 0) for _, block := range chain.Blocks &#123; fmt.Printf(&quot;Timestamp: %d\\n&quot;, block.Timestamp) fmt.Printf(&quot;hash: %x\\n&quot;, block.Hash) fmt.Printf(&quot;Previous hash: %x\\n&quot;, block.PrevHash) fmt.Printf(&quot;nonce: %d\\n&quot;, block.Nonce) fmt.Println(&quot;Proof of Work validation:&quot;, block.ValidatePoW()) &#125; property, _ = chain.FindUTXOs([]byte(&quot;yangyan&quot;)) fmt.Println(&quot;Balance of Leo Cao: &quot;, property) property, _ = chain.FindUTXOs([]byte(&quot;K&quot;)) fmt.Println(&quot;Balance of Krad: &quot;, property) property, _ = chain.FindUTXOs([]byte(&quot;E&quot;)) fmt.Println(&quot;Balance of Exia: &quot;, property)&#125; 这是调试的过程 创建一个空的交易池（txPool）和一个临时交易变量（tempTx）。 创建一个区块链实例（chain）。 查找名为”yangyan”的地址的UTXOs（未使用的交易输出），并打印其余额。 尝试创建一个从”yangyan”到”K”的转账交易，金额为100，如果成功则将其添加到交易池中。 对交易池中的交易进行挖矿操作。 清空交易池，再次查找”L”的地址的UTXOs，并打印其余额。 尝试创建一个无效的交易，从”K”到”E”的转账交易，金额为200，如果成功则将其添加到交易池中。 尝试创建一个有效的交易，从”K”到”E”的转账交易，金额为50，如果成功则将其添加到交易池中。 尝试创建一个有效的交易，从”yangyan”到”E”的转账交易，金额为100，如果成功则将其添加到交易池中。 对交易池中的交易进行挖矿操作。 清空交易池。 遍历区块链中的所有区块，打印每个区块的时间戳、哈希值、前一个区块的哈希值、随机数以及工作量证明验证结果。 尝试创建一个从”K”到”E”的转账交易，金额为30，如果成功则将其添加到交易池中。 尝试创建一个从”K”到”yangyan”的转账交易，金额为30，如果成功则将其添加到交易池中。 对交易池中的交易进行挖矿操作。 清空交易池。 遍历区块链中的所有区块，打印每个区块的时间戳、哈希值、前一个区块的哈希值、随机数以及工作量证明验证结果。 查找各个地址的UTXOs，并打印其余额。","categories":[{"name":"区块链","slug":"区块链","permalink":"http://example.com/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/"}],"tags":[{"name":"区块链","slug":"区块链","permalink":"http://example.com/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"},{"name":"goland","slug":"goland","permalink":"http://example.com/tags/goland/"}]},{"title":"简单区块链的pow验证机制的添加","slug":"简单区块链的pow验证机制的添加","date":"2023-12-02T13:04:48.000Z","updated":"2023-12-06T08:13:25.561Z","comments":true,"path":"2023/12/02/简单区块链的pow验证机制的添加/","link":"","permalink":"http://example.com/2023/12/02/%E7%AE%80%E5%8D%95%E5%8C%BA%E5%9D%97%E9%93%BE%E7%9A%84pow%E9%AA%8C%E8%AF%81%E6%9C%BA%E5%88%B6%E7%9A%84%E6%B7%BB%E5%8A%A0/","excerpt":"","text":"pow工作量证明机制工作量证明机制加到区块链里就是整个随机数，随机数在矿工挖矿时决定了下一个区块会给到谁的手里，随机数加到数据里边然后进行哈希值的计算，看看是不是在一个范围里边。 进行pow扩展之前先给代码规范一下，创建一些文件夹进行代码的管理 先整个文件夹constcoe然后整个全局变量，用来装挖矿的难度。 1234567//constcoe.gopackage constcoeconst ( Difficulty = 12) 整个函数包。先整个错误函数，错误直接停止。 12345func Handle(err error) &#123; if err != nil &#123; log.Panic(err) &#125;&#125; 把int64位转字节串函数移动过来和那个结构体什么的。 候选区块加入到区块链是需要pow证明的，如果一个区块可以控制下一个区块是不是自己的时候，他就有了可以双重支付的能力。如果用了工作量证明机制，就可以避免这种情况的发生，首先矿工会筛选交易，然后因为存在随机值，谁也不能确定到底谁会获得下一个区块，这时候就可以解决双花问题了。 首先我们要增加一些区块的头部信息。 12345678type Block struct &#123; Timestamp int64 Hash []byte PrevHash []byte Target []byte //This line is new Nonce int64 //This line is new Data []byte&#125; target作为结果哈希值的比较难度。nonce作为计算哈希值的随机数。 创建一个proofofwork.go，内容放我们之前说的pow共识机制。 首先我们需要一个可以返回目标难度值得函数，我们使用之前设定的一个常量difficulty来构造目标难度，在实际区块链中目标难度之会根据网络情况定时进行调整。 12345func (b *Block) GetTarget() []byte &#123; target := big.NewInt(1) target.Lsh(target, uint(256-constcoe.Difficulty)) return target.Bytes()&#125; Lsh函数就是向左移位，移的越多目标难度值越大，哈希取值落在的空间就更多也就越容易找到符合条件的nonce。 下面的函数是用作输入一段nonce值，进行区块的哈希值运算。不同的nonce值会返回不同的哈希值 123456789101112func (b *Block) GetBase4Nonce(nonce int64) []byte &#123; data := bytes.Join([][]byte&#123; utils.ToHexInt(b.Timestamp), b.PrevHash, utils.ToHexInt(int64(nonce)), b.Target, b.Data, &#125;, []byte&#123;&#125;, ) return data&#125; 现在对于任意一个区块，我们都能去寻找一个合适的nonce了。 1234567891011121314151617181920func (b *Block) FindNonce() int64 &#123; var intHash big.Int var intTarget big.Int var hash [32]byte var nonce int64 nonce = 0 intTarget.SetBytes(b.Target) for nonce &lt; math.MaxInt64 &#123; data := b.GetBase4Nonce(nonce) hash = sha256.Sum256(data) intHash.SetBytes(hash[:]) if intHash.Cmp(&amp;intTarget) == -1 &#123; break &#125; else &#123; nonce++ &#125; &#125; return nonce&#125; 比较两个整数的大小。如果intHash.Cmp(&amp;intTarget)返回-1，表示intHash小于intTarget。 这是一个验证的函数，用作验证是否随机数正确 12345678910111213func (b *Block) ValidatePoW() bool &#123; var intHash big.Int var intTarget big.Int var hash [32]byte intTarget.SetBytes(b.Target) data := b.GetBase4Nonce(b.Nonce) hash = sha256.Sum256(data) intHash.SetBytes(hash[:]) if intHash.Cmp(&amp;intTarget) == -1 &#123; return true &#125; return false&#125; PoW我们已经实现了。回到block.go，调整以下函数。 12345678910111213func (b *Block) SetHash() &#123; information := bytes.Join([][]byte&#123;utils.ToHexInt(b.Timestamp), b.PrevHash, b.Target, utils.ToHexInt(b.Nonce), b.Data&#125;, []byte&#123;&#125;) hash := sha256.Sum256(information) b.Hash = hash[:]&#125;func CreateBlock(prevhash, data []byte) *Block &#123; block := Block&#123;time.Now().Unix(), []byte&#123;&#125;, prevhash, []byte&#123;&#125;, 0, data&#125; block.Target = block.GetTarget() block.Nonce = block.FindNonce() block.SetHash() return &amp;block&#125; 然后就可以启动系统了，通过更改difficulty来调整难度。","categories":[{"name":"区块链","slug":"区块链","permalink":"http://example.com/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/"}],"tags":[{"name":"区块链","slug":"区块链","permalink":"http://example.com/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"},{"name":"goland","slug":"goland","permalink":"http://example.com/tags/goland/"}]},{"title":"goland-goroutine和channel：并发的基础","slug":"filegoland-goroutine和channel：并发的基础","date":"2023-11-29T13:37:11.000Z","updated":"2023-12-06T07:51:52.480Z","comments":true,"path":"2023/11/29/filegoland-goroutine和channel：并发的基础/","link":"","permalink":"http://example.com/2023/11/29/filegoland-goroutine%E5%92%8Cchannel%EF%BC%9A%E5%B9%B6%E5%8F%91%E7%9A%84%E5%9F%BA%E7%A1%80/","excerpt":"","text":"goroutine和channel：并发的基础啥是并发听说很有特点的就是goland的并发，所写的代码都按照顺序执行，也就是上一句代码执行完，才会执行下一句，这样的代码逻辑简单，也符合我们的阅读习惯。但这样是不够的，因为计算机很强大，如果只让它干完一件事情再干另外一件事情就太浪费了。比如一款音乐软件，使用它听音乐的时候还想让它下载歌曲，同一时刻做了两件事，在编程中，这就是并发。并发可以让你编写的程序在同一时刻多做几件事情。 进程和线程进程操作系统中，进程是非常重要的概念。当你启动一个软件，操作同会自动创建一个进程，进程是如阿健的工作空间，它包含了软件运行所需的所有资源。 线程线程是进程的执行空间，一个进程可以有多个线程，线程被操作系统调度执行，一些计算机桑德行为就会有多个线程被操作系统同时调度执行的情况，这就是线程的并发。 协程Go语言中没有线程的概念，只有协程，也称为goroutine。相比线程来说，协程更加轻量，一个程序可以随意启动成千上万个goroutine。 goroutine被Go runtime所调度，这一点与线程不一样。也就是说，Go语言的并发是由Go自己调度的，自己决定同时执行多少个goroutine、什么时候执行哪几个。这些对于我们开发者来说完全透明，只需要在编码的时候告诉Go语言要启动几个goroutine，至于如何调度执行，我们不用关心。 启动一个goroutine非常简单，go语言为我们提供了go关键字，相比其他语言简单许多。 123go fmt.Println(&quot;sad&quot;)fmt.Println(&quot;qwe&quot;)time.Sleep(time.Second) 这样启动一个协程，调用fmt.println函数打印sad。所以这段代码有两个协程，一个是main的，一个是go挂剪子启动的。 语法就是go之后跟一个方法或者函数的调用。 上边代码的输出情况是qwe 然后sad， 示例中的time.Sleep(time.Second)表示等待一秒，这里是让main goroutine等一秒，不然main goroutine执行完毕程序就退出了 意思就是另外找个线路执行我的sad，所以先后顺序看情况吧可能。 管道如果很多个协程，他们怎么通信呢？这就是channel要结局的问题 声明一个管道声明一个管道很简单 1pipe:make(chan string) chan是一个关键字，表示是channel类型。后面的string表示channel里的数据是string。通过channel声明可以看到，chan是一个集合类型。 定义好一个管道就可以操作了。 它只有两种操作，接受和发送 1)接收：获取chan中的值，操作符为＜-chan。 2)发送：向chan发送值，把值放在chan中，操作符为chan＜-。 12345678910func main() &#123;ch:=make(chan string)go func() &#123; fmt.Println(&quot;asd00&quot;) ch &lt;-&quot;okokok&quot;&#125;()fmt.Println(&quot;我是协程&quot;)v:=&lt;-chfmt.Println(&quot;接受chan中的值是：&quot;,v)&#125; 程序不会在新的goroutine完成之前退出了，因为通过make创建的chan中没有值，而main goroutine又想从chan中获取值，获取不到就一直等待，等到另一个goroutine向chan发送值为止。 因为最后一个print里的是想要接受v的值，但是v此时此刻没有值，所以一直等到另一个协程给v输送值。 无缓冲管道在上面的示例中，使用make创建的chan就是一个无缓冲管道，它的容量是0，不能存储任何数据。所以无缓冲管道只起到传输数据的作用，数据并不会在管道中做任何停留。这也意味着，无缓冲管道的发送和接收操作是同时进行的，它也可以称为同步管道。 有缓冲管道有缓冲通道是类似于一个可阻塞的队列，内部的元素先进先出。通过make第二个参数可以指定容量，进而创建一个有缓冲的管道。 1ch:=make(chan int,5) 我创建了一个容量为5的管道，内部的元素类型是int，也就是说管道内部存放5个类型的int元素，先进先出。 一个有缓冲管道具备以下特点： 1)有缓冲管道的内部有一个缓冲队列。 2)发送操作是向队列的尾部插入元素，如果队列已满，则阻塞等待，直到另一个goroutine执行接收操作释放队列的空间。 3)接收操作是从队列的头部获取元素并把它从队列中删除，如果队列为空，则阻塞等待，直到另一个goroutine执行，发送操作插入新的元素。 缓冲管道类似一个队列，可以获取他的容量和里面元素的个数和容量。 1234ch:=make(chan int,5)ch&lt;-2ch&lt;-3fmt.Println(cap(ch),len(ch)) 无缓冲管道其实就是一个容量大小为0的管道。比如make(chan int，0)。 关闭通道1close(ch) 如果一个管道被关闭，就不能向里面发送数据了，如果发送的话，会引起panic异常。但是我们还可以接收管道里的数据，如果管道里没有数据的话，接收的数据是元素类型的零值。 单向通道maybe有时候我们的特殊需求限制一个管道只能接受不能发送，或者限制一个管道只能发送不能接收，就叫做单向管道 12onlysend:=make(chan&lt;- int,5)onlyreceive:=make(&lt;-chan int,5) 单向管道的声明也很简单，只需要在声明的时候带上＜-操作符即可。 12func conter(out chan&lt;- int) &#123;&#125; 函数体内所用的参数out是一个只能发送的管道，所以函数体内只能对out函数进行发送操作，如果执行接受操作就不能编译通过了。 select+channel示例假设要从网上下载一个文件，我启动了3个goroutine进行下载，并把结果发送到3个channel（管道）中。其中，哪个先下载好，就会使用哪个channel的结果。 在这种情况下，如果我们尝试获取第一个channel的结果，程序就会被阻塞，无法获取剩下两个channel的结果，也无法判断哪个先下载好。这个时候就需要用到多路复用操作了，在Go语言中，通过select语句可以实现多路复用 12345678910111213var urls = []string&#123;&quot;http://example.com/file1&quot;, &quot;http://example.com/file2&quot;, &quot;http://example.com/file3&quot;&#125; var resultChannels = make([]chan string, 3) for i := 0; i &lt; 3; i++ &#123; go downloadFile(urls[i], resultChannels[i]) &#125; for i := 0; i &lt; 3; i++ &#123; select &#123; case result := &lt;-resultChannels[i]: fmt.Println(&quot;Downloaded file:&quot;, result) &#125; &#125; 1 在上面的代码中，我们定义了一个downloadFile函数来模拟文件下载任务，并将结果发送到对应的通道中。在main函数中，我们创建了3个通道，并启动了3个goroutine来执行下载任务。然后，我们使用select语句来监听每个通道，当某个通道有数据时，就立即获取到结果并打印出来。","categories":[{"name":"goland","slug":"goland","permalink":"http://example.com/categories/goland/"}],"tags":[{"name":"goland","slug":"goland","permalink":"http://example.com/tags/goland/"}]},{"title":"初识区块链-动手制作一个简单的区块链","slug":"file初识区块链-动手制作一个简单的区块链","date":"2023-11-27T14:58:45.000Z","updated":"2023-12-06T07:51:24.149Z","comments":true,"path":"2023/11/27/file初识区块链-动手制作一个简单的区块链/","link":"","permalink":"http://example.com/2023/11/27/file%E5%88%9D%E8%AF%86%E5%8C%BA%E5%9D%97%E9%93%BE-%E5%8A%A8%E6%89%8B%E5%88%B6%E4%BD%9C%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E5%8C%BA%E5%9D%97%E9%93%BE/","excerpt":"","text":"尝试制作一个简单的区块链其实主要是对于go的基础语法刚刚学完所以拿来练手 1.用struct函数制作一个块，块在区块链中用来储存数据信息，它内部包含上一个区块的hash值连接上一个区块，包含头部信息总结区块，然后再区块数据的存放区存放要保存的重要数据。 123456type Block struct &#123; Timestamp int64//时间戳 Hash []byte//本身哈希值 PrevHash []byte//指向上一个区块 Data []byte//属性&#125; 2.得到区块之后我们就可以定义一条区块链了。 123type BlockChain struct &#123; Blocks []*Block&#125; 这里我们可以看到区块链就是区块的一个集合。创建一个切片用来储存每个区块。 掌握了块和区块链就可以给区块家电细节，观察他们是如何连接起来的。对于一个区块而言，可以通过哈希算法概括全部的信心，哈希值就是区块的id值，同时用来检查区块所包含的信息的完整性。 3.hash函数 首先创造一个函数，接受区块的信息。区块的信息要讲所有的信息合并成一条字节串供计算哈希值。join函数是bytes包中的一个函数，用作将许多的切片连接在一起。 然后利用哈希计算出哈希值， 1234567func (b *Block) SetHash() &#123; information :=bytes.Join([][]byte&#123;ToHexInt(b.Timestamp),b.PrevHash,b.Data&#125;,[]byte&#123;&#125;) //information是把区块各项属性串联之后的字节串 //bytes.join可以把多个字符串链接 hash:=sha256.Sum256(information) b.Hash=hash[:]&#125; TOHexInt我们自定义一个函数用作将int类型转换byte类型。 12345678func ToHexInt(num int64) []byte &#123; buff := new(bytes.Buffer) err := binary.Write(buff, binary.BigEndian, num) if err != nil &#123; log.Panic(err) &#125; return buff.Bytes()&#125; 创建bytes.Buffer变量的主要用途是用于高效地处理字节数据。 大端字节序（Big Endian）是指最高位字节在内存中的低地址处，低位字节在高地址处。与之相对的是小端字节序（Little Endian），即最低位字节在内存中的低地址处，高位字节在高地址处。 1log.Panic(err) 用来停止程序输出错误。 如果需要频繁进行字符串拼接操作，使用普通的字符串拼接方式会导致效率低下。这时就可以使用缓冲区（Buffer）来优化。因为bytes.Buffer是一个具有读取和写入方法的可变大小的字节缓冲区。例如，可以先将需要拼接的字符串写入到缓冲区中，当缓冲区满了或者需要将缓冲区的内容输出时，再进行实际的IO操作。这样就可以大大提高程序的运行效率。 而缓冲区是一个可以接受多个值的通道，用作可变大小的切片，不强制必须完成发送和接受。 4.区块创建与创始区块 可以获得区块的哈希值了，我们就能够创建区块了。 12345func CreateBlock(prevhash, data []byte) *Block &#123; block := Block&#123;time.Now().Unix(), []byte&#123;&#125;, prevhash, data&#125; block.SetHash() return &amp;block&#125; 一定要引用前一个区块的哈希值。 新的区块要有时间戳和上一个区块的哈希值，以及这个区块的数据 1234func GenesisBlock() *Block &#123; genesisWords := &quot;Hello, blockchain!&quot; return CreateBlock([]byte&#123;&#125;, []byte(genesisWords))&#125; 创世区块里存放hello这段信息，构建函数使得区块链可以根据其他的信息创建区块进行储存。 1234func (bc *BlockChain) AddBlock(data string) &#123; newBlock := CreateBlock(bc.Blocks[len(bc.Blocks)-1].Hash, []byte(data)) bc.Blocks = append(bc.Blocks, newBlock)&#125; append用来在列表末尾添加一个或者多个元素。 创建区块链函数，首先把创世区块作为第一个区块 12345func CreateBlockChain() *BlockChain &#123; blockchain := BlockChain&#123;&#125; blockchain.Blocks = append(blockchain.Blocks, GenesisBlock()) return &amp;blockchain&#125; 运作一下。 12345678910111213141516171819func main() &#123; blockchain := CreateBlockChain()// 创建一个区块链对象 time.Sleep(time.Second)// 等待一段时间（1秒） blockchain.AddBlock(&quot;A&quot;) time.Sleep(time.Second)// 等待一段时间（1秒） blockchain.AddBlock(&quot;B&quot;) time.Sleep(time.Second)// 等待一段时间（1秒） blockchain.AddBlock(&quot;C&quot;) time.Sleep(time.Second)// 等待一段时间（1秒）//遍历区块 for _, block := range blockchain.Blocks &#123; fmt.Printf(&quot;Timestamp: %d\\n&quot;, block.Timestamp) fmt.Printf(&quot;hash: %x\\n&quot;, block.Hash) fmt.Printf(&quot;Previous hash: %x\\n&quot;, block.PrevHash) fmt.Printf(&quot;data: %s\\n&quot;, block.Data) &#125;&#125;","categories":[{"name":"区块链","slug":"区块链","permalink":"http://example.com/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/"}],"tags":[{"name":"区块链","slug":"区块链","permalink":"http://example.com/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"},{"name":"goland","slug":"goland","permalink":"http://example.com/tags/goland/"}]},{"title":"goland-错误","slug":"goland-错误","date":"2023-11-26T08:33:26.000Z","updated":"2023-12-06T07:56:45.872Z","comments":true,"path":"2023/11/26/goland-错误/","link":"","permalink":"http://example.com/2023/11/26/goland-%E9%94%99%E8%AF%AF/","excerpt":"","text":"错误在Go语言中，错误是通过内置的error接口表示的。 只有一个Error()方法用来返回具体的错误信息。 error工厂函数除了可以使用其他函数，自己定义的函数也可以发挥错误信息给调用者。 add函数会在a或者b任何一个为负数的情况下，返回一个错误信息；如果a、b都不为负数，错误信息部分会返回nil，这也是常见的做法。所以调用者可以通过错误信息是否为nil进行判断。下面的add函数示例是使用errors.New这个工厂函数来生成错误信息的。errors.New函数接收一个字符串参数，返回一个error接口。 1234567func add(a,b int) (int,error)&#123; if a&lt;0||b&lt;0&#123; return 0,errors.New(&quot;a.b不能为负数&quot;) &#125;else&#123; return a+b,nil &#125;&#125; 123456sum,err:=add(-1,2)if err!=nil&#123; fmt.Println(err)&#125;else &#123; fmt.Println(sum)&#125; 自定义error上面的工厂函数返回错误信息只能穿第一个字符串，如果i昂要携带更多信息，姿势自定义error。 1234567891011121314151617type commonerror struct &#123; errorcode int//错误编号 errormsg string//报错内容&#125;func (ce *commonerror) Error()string &#123; return ce.errormsg&#125;func add(a,b int) (int,error)&#123; if a&lt;0||b&lt;0&#123; return 0,&amp;commonerror&#123; errormsg: &quot;asd&quot;, errorcode:1&#125; &#125;else&#123; return a+b,nil &#125;&#125; 意思就是我程序犯错，commonerror就会把内容写成asd和1。 error断言拥有了自定义的error，携带了更多的错误信息后，就可以使用这些信息。需要先把返回的error接口转换为自定义的错误类型。 123456sum,err:=add(-1,20)if cm,ok:=err.(*commonerror);ok&#123; fmt.Println(&quot;错误代码&quot;,cm.errorcode,&quot;错误信息&quot;,cm.errormsg)&#125;else &#123; fmt.Println(sum)&#125; 意思就是实现了error接口，我们可以自定义error的效果。 读起来真是不太理解，找半天我的Error用在哪了，原来是实现了底层的接口，我干。😓 1cm,ok:=err.(*commonerror) 更是重量级，这是个类型断言，如果err是这个的类型，就给赋值cm。不然就输出sum了。 不实现那个Error接口就不能返回error值，就不能自定义了。 存个档，错误太抽象了。现在用不到太多，以下的部分以后再来探索吧——2023.11.29 错误嵌套error wrapping功能errors.unwrap函数errors.ls函数errors.As函数defer函数panic函数","categories":[{"name":"goland","slug":"goland","permalink":"http://example.com/categories/goland/"}],"tags":[{"name":"goland","slug":"goland","permalink":"http://example.com/tags/goland/"}]},{"title":"goland-struct和interface","slug":"goland-struct和interface","date":"2023-11-23T04:30:38.000Z","updated":"2023-12-06T07:51:00.711Z","comments":true,"path":"2023/11/23/goland-struct和interface/","link":"","permalink":"http://example.com/2023/11/23/goland-struct%E5%92%8Cinterface/","excerpt":"","text":"结构体结构体的定义这里我们定义了一个结构体类型，名称为IPhone，含有字段name 123type Phone struct &#123; name string&#125; 在定义结构体时，字段的声明方法与平时声明一个变量是一样的，都是变量名在前，类型在后，只不过在结构体中，变量名称为成员名或字段名。 声明和使用123p:=IPhone&#123; name: &quot;ASD&quot;&#125;fmt.Println(p.name) 1p:=IPhone&#123;&quot;ASD&quot;&#125; 两种情况都可以编译通过，甚至可以只声明其中的一部分，那么没声明的部分就默认零值 结构体的字段123456type IPhone struct &#123; name string aa kk&#125;type kk struct &#123; id int 用代码描述现实中的实体会更匹配，复用程度也更高。对于嵌套结构体字段的结构体，其初始化与正常的结构体大同小异，只需要根据字段对应的类型初始化即可。 12345p:=IPhone&#123;name: &quot;s&quot;,aa: kk&#123;6&#125;,&#125; 利用点操作符调用字段的值 1fmt.Println(p.aa.id) 接口接口的定义接口要做的是定义好约定，告诉调用方自己可以做什么，但调用方不用知道它的内部实现。 接口的定义与结构体稍微有些差别，虽然都以type关键字开始，但接口的关键字是interface。 123type Phone interface &#123; speak()&#125; 定义一个接口Phone 拥有speak方法，Phone接口告诉调用者他拥有方法speak，至于谁speak如何speak调用者不用关心，这是由接口实现者来做的。 接口的实现接口的实现者必须是一个具体的类型 123func (a IPhone) speak() string&#123; return &quot;iiii&quot;&#125; 这里用Iphone来做示例，让他实现Phone接口。 给Iphone定义一个方法，这个方法与接口里的方法的签名一样，这样的结构体Iphone就实现了这个Phone的接口，接口并没有通过任何的关键词来实现，所以go的接口是隐式实现的。 如果一个接口有许多个方法，那么需要实现接口的每个方法才是实现了这个接口。 实现了接口之后我们就可以使用它了。 123func print(p Phone)&#123; fmt.Println(p.speak())&#125; 定义一个接口可以用来打印实现Phone接口的函数，它接受一个Phone接口类型的参数，然后打印出，不用考虑具体的类型实现。 12a:=IPhone&#123;&quot;ASD&quot;&#125;print(a) 值和指针类型接收者有值类型接收者和指针类型接收者两种。二者都可以调用方法，因为Go语言编译器自动做了转换，所以值类型接收者和指针类型接收者是等价的。但是在接口的实现中，值类型接收者和指针类型接收者不一样。 把实现过程改成指针，依旧可以编译运行正常。这就证明了以值类型接收者实现接口的时候，不管是类型本身，还是该类型的指针类型，都实现了该接口。 1print(&amp;a) 实例中接收者（a Iphone）实现了Phone接口，那么Iphone和他的指针类型*Iphone都实现了Phone接口。 接下来把接收者改为指针类型。 123func (a *IPhone) speak() string&#123; return &quot;iiii&quot;&#125; 修改成指针赖兴接收者后会发现，实例中的print（a），没办法编译成功，错误是IPhone没有实现Phone接口，这就证明了以指针类型接收者实现接口的时候，只有对应的指针类型才被认为实现了接口。 可以这样解读：当值类型作为接收者时，person类型和person类型都实现了该接口。当指针类型作为接收者时，只有person类型实现了该接口。可以发现，实现接口的类型都有*person，这也表明指针类型比较万能，不管哪一种接收者，它都能实现该接口。 接口的理解是一个困难的过程,以下是我理解接口的过程和程序。1.使用接口和不使用接口的两种方式： 使用接口： 12345678910111213141516171819202122232425262728293031package mainimport &quot;fmt&quot;type Doer interface &#123; Do()&#125;type Foo struct&#123;&#125;func (f Foo) Do() &#123; fmt.Println(&quot;Foo does something.&quot;)&#125;type Bar struct&#123;&#125;func (b Bar) Do() &#123; fmt.Println(&quot;Bar does something else.&quot;)&#125;func DoSomething(d Doer) &#123; d.Do()&#125;func main() &#123; f := Foo&#123;&#125; b := Bar&#123;&#125; DoSomething(f) DoSomething(b)&#125; 在这个例子中，我们定义了一个接口 Doer 和两个结构体 Foo 和 Bar。Foo 和 Bar 分别实现了 Doer 接口。在 DoSomething 函数中，我们接收一个 Doer 类型的参数，并调用其 Do 方法。这样，我们可以在 main 函数中传入 Foo 或 Bar 的实例，从而使得代码具有更好的灵活性。 不使用接口： 12345678910111213141516171819202122232425262728293031package mainimport &quot;fmt&quot;type Foo struct&#123;&#125;func (f Foo) Do() &#123; fmt.Println(&quot;Foo does something.&quot;)&#125;type Bar struct&#123;&#125;func (b Bar) Do() &#123; fmt.Println(&quot;Bar does something else.&quot;)&#125;func DoSomethingWithFoo(f Foo) &#123; f.Do()&#125;func DoSomethingWithBar(b Bar) &#123; b.Do()&#125;func main() &#123; f := Foo&#123;&#125; b := Bar&#123;&#125; DoSomethingWithFoo(f) DoSomethingWithBar(b)&#125; 在这个例子中，我们没有使用接口。取而代之的是，我们为 Foo 和 Bar 分别定义了两个函数 DoSomethingWithFoo 和 DoSomethingWithBar。这样，我们也可以在 main 函数中调用这些函数，但相比于使用接口的方式，这种设计缺乏灵活性，因为每个函数只能处理一种类型的值。 通过以上两个示例的对比，我们可以看到，使用接口可以使得我们的代码更具有抽象性、可替换性和灵活性。在需要抽象、可替换性或灵活性的场景中，使用接口是一个不错的选择。 实现接口的作用是让用户的代码更具可读性，相同的代码出现的频率变低，更低的耦合度。 工厂函数工厂函数一般用于创建自定义的结构体，便于使用者调用。 123func new(a string) *IPhone&#123; return &amp;IPhone&#123;name: a&#125;&#125; 我定义了一个工厂函数new,接受一个string的类型的参数，用于表示手机的名字，同时返回一个*Iphone。 通过工厂函数创建自定义结构的方式，让调用者不用太关注结构体内部的字段，只用传给工厂函数就可以了。 1234567891011121314151617181920212223242526272829303132333435363738package mainimport &quot;fmt&quot;type Animal interface &#123; Speak() string&#125;type Dog struct&#123;&#125;func (d Dog) Speak() string &#123; return &quot;Woof!&quot;&#125;type Cat struct&#123;&#125;func (c Cat) Speak() string &#123; return &quot;Meow!&quot;&#125;func CreateAnimal(kind string) Animal &#123; switch kind &#123; case &quot;dog&quot;: return Dog&#123;&#125; case &quot;cat&quot;: return Cat&#123;&#125; default: return nil &#125;&#125;func main() &#123; dog := CreateAnimal(&quot;dog&quot;) fmt.Println(dog.Speak()) // 输出：Woof! cat := CreateAnimal(&quot;cat&quot;) fmt.Println(cat.Speak()) // 输出：Meow!&#125; 我们并不需要在意结构体内部的字段，只需要传给工厂函数就行了。 继承和组合在Go语言中没有继承的概念，所以结构体、接口之间也没有父子关系，Go语言提倡的是组合，利用组合达到代码复用的目的，这也更灵活。类型的组合就是可以称之为嵌套。 当然可以。以下是一个使用 Go 语言实现的简单嵌套示例。这个例子定义了一个嵌套结构体，用于表示学生和课程信息。 123456789101112131415package mainimport &quot;fmt&quot;type Student struct &#123; Name string Age int Course []Course&#125;type Course struct &#123; Name string Credit int&#125;&#125; 我们先定义了一个名为 Student 的结构体，其中包含了姓名（Name）、年龄（Age）和课程（Course）信息。课程信息是由一个嵌套结构体 Course 表示。 类型断言有了接口和实现接口的类型，就会有类型断言。类型断言用来判断一个接口的值是否是实现该接口的某个具体类型。类型断言（Type Assertion）用于确定一个接口变量（interface{}）实际指向的类型。类型断言的语法形式如下： 1value, ok := interface&#123;&#125;.(T) 其中的 value 是类型为 T 的值，ok 是一个布尔值，表示断言是否成功。如果断言成功，ok 为 true，value 包含接口变量实际指向的值；如果断言失败，ok 为 false，value 为 T 类型的零值。 以下是一个使用类型断言的示例： 123456789101112131415161718192021package mainimport &quot;fmt&quot;func main() &#123; var x interface&#123;&#125; = &quot;Hello, World!&quot; s, ok := x.(string) if ok &#123; fmt.Println(s) &#125; else &#123; fmt.Println(&quot;断言失败&quot;) &#125; i, ok := x.(int) if ok &#123; fmt.Println(i) &#125; else &#123; fmt.Println(&quot;断言失败&quot;) &#125;&#125; 在这个例子中，我们首先定义了一个接口变量 x，并将其赋值为字符串 “Hello, World!”。然后，我们使用类型断言尝试将该接口变量转换为字符串类型和整数类型。成功时，ok 为 true，value 包含实际值；失败时，ok 为 false，value 为相应类型的零值。。","categories":[{"name":"goland","slug":"goland","permalink":"http://example.com/categories/goland/"}],"tags":[{"name":"goland","slug":"goland","permalink":"http://example.com/tags/goland/"}]},{"title":"goland-函数和方法","slug":"goland-函数和方法","date":"2023-11-21T11:52:23.000Z","updated":"2023-12-06T07:50:26.577Z","comments":true,"path":"2023/11/21/goland-函数和方法/","link":"","permalink":"http://example.com/2023/11/21/goland-%E5%87%BD%E6%95%B0%E5%92%8C%E6%96%B9%E6%B3%95/","excerpt":"","text":"函数函数声明12func sum(a int,b int) int&#123; return a+b 注意形参名后加类型 函数定义以下部分： 1.关键词func 2.函数名sum 3.函数参数a，b 4.返回值 5.代码实体 多值返回123func sum(a int,b int) (int,error)&#123; return a+b,errors.New(&quot;f&quot;)&#125; error是go语言内置的错误信息 可变参数123456func sum(a ...int) int&#123; sum:=0 for _,a:= range params&#123; sum +=a &#125; return sum 该可变参数通过for range函数循环计算这些参数值和，可变参数类型其实就是切片，a的参数类型是【】int，所以可以通过for range进行循环。 注意：如果参数中有可变参数和普通参数，那么可变参数放在末尾。 包级函数不落实我们使用的sum还是println，都是从属于一个包，sum函数属于main包，println属于fmt包，同一个包可以调用，当不同的包函数要调用，必须是属于共有的，也就是函数的首字母要大写。 go语言没有public和private来区别共有私有 匿名函数和闭包匿名函数就是没有名字的函数，这是它与正常函数的区别。 1234567func main() &#123; sum:= func(a,b int) int &#123; return a+b &#125; fmt.Println(sum(1,2))&#125; sum就是弥明函数，有了匿名函数就可以在函数中进行函数嵌套，定义的匿名函数叫做内部函数，更重要的是，函数内定义的内部函数，可以用外部函数的变量，这种方式也叫做闭包 方法方法和函数的区别在于方法必须要有一个接收者，接收者是一个类型，这样方法就与这个类型绑定在一起，称为这个类型的方法 12345678910import &quot;fmt&quot;type Age uintfunc (age Age)String()&#123; fmt.Println(age)&#125;func main() &#123;a:=Age(1)a.String()&#125; 如同于类一样，必须使用特定类型的接收者才能被调用 具有更好的可读性，简便性。 值和指针类型的接收者123func (age *Age)S()&#123; *age=Age(30)&#125; 1234a := Age(25)a.String()a.S()a.String() 发现值变化了，因为指针对应的更改。 示例中的变量a并不是指针类型，而是go自动更改的。 也可以这样 1(&amp;a).S() 所以使用时，根据自己的需求进行接收者类型的选择，调用者的类型会自己转变，大大提高效率。","categories":[{"name":"goland","slug":"goland","permalink":"http://example.com/categories/goland/"}],"tags":[{"name":"goland","slug":"goland","permalink":"http://example.com/tags/goland/"}]},{"title":"goland-集合类型","slug":"goland-集合类型","date":"2023-11-21T10:37:49.000Z","updated":"2023-12-06T07:50:15.679Z","comments":true,"path":"2023/11/21/goland-集合类型/","link":"","permalink":"http://example.com/2023/11/21/goland-%E9%9B%86%E5%90%88%E7%B1%BB%E5%9E%8B/","excerpt":"","text":"数组的声明1array:=[5]string&#123;&quot;s&quot;,&quot;a&quot;,&quot;a&quot;,&quot;f&quot;&#125; 数组在内存中是连续存放的.每个元素有自己的下标i（ndex），从0开始 长度在定义时可以取消，它会根据内容数量自己进行计数。 1array:=[]string&#123;&quot;s&quot;,&quot;a&quot;,&quot;a&quot;,&quot;f&quot;&#125; 只用于所有元素都被初始化的场景，如果有特定的索引元素被初始化的情况，就不适合了 1array:=[]string&#123;1:&quot;s&quot;,3:&quot;a&quot;&#125; 元素长度为4，不一定符合标准 数组的循环利用range进行遍历，i是索引值，v是具体值 1234array:=[]string&#123;1:&quot;s&quot;,3:&quot;a&quot;&#125;for i,v:=range array&#123; fmt.Printf(&quot;索引 :%d,对应 :%v\\n&quot;,i,v) &#125; 相比之下for range更为简便 1234for _,v:=range array &#123; fmt.Printf(&quot;值:%v\\n&quot;,v)&#125; _表示被丢弃的值 切片底层就是数组，对数组的任意分割得到切片，动态数组 123array:=[]string&#123;&quot;s&quot;,&quot;a&quot;,&quot;q&quot;,&quot;g&quot;&#125;slice:= array[2:4]fmt.Println(slice) 包含2不包含4索引下的值 切片和数组的操作是差不多的，同样可以经过索引定位值，只不过这里的值是重新从0开始定位的 切片的修改1234array:=[]string&#123;&quot;s&quot;,&quot;a&quot;,&quot;q&quot;,&quot;g&quot;&#125;slice:= array[2:4]slice[0]=&quot;l&quot;fmt.Println(array) 切片所运用的依旧是数组的底层数据，切片的值更改，相应的数组也会被修改 切片的声明1slice:=make([]string,1,2) 1是长度，2是容量，意思是开阔一个容量为8的空间，但是只有一个有数据，其他的属于空闲状态 切片属于动态数组，相比于数组更为灵活，数组属于值类型，动态数组是指针类型 切片的追加123 silce2:=append(slice1,&quot;f&quot;)silce2:=append(slice1,&quot;f&quot;,&quot;g&quot;)silce2:=append(slice1,slice3...) 映射1nameAgeMap:=make(map[string]int) key值是string类型，value则是int类型,然后可以进行操作了 1nameAgeMap[&quot;SS&quot;=2] 验证是否存在，asd是value值，ok是key值 123456nameAgeMap:=make(map[string]int)nameAgeMap[&quot;SS&quot;]=2asd,ok:=nameAgeMap[&quot;SS&quot;]if ok&#123; fmt.Println(asd) &#125; map是可以用for range遍历的，主义的是遍历是无序的","categories":[{"name":"goland","slug":"goland","permalink":"http://example.com/categories/goland/"}],"tags":[{"name":"goland","slug":"goland","permalink":"http://example.com/tags/goland/"}]},{"title":"goland-控制结构","slug":"goland-控制结构","date":"2023-11-21T10:15:47.000Z","updated":"2023-12-06T07:49:54.740Z","comments":true,"path":"2023/11/21/goland-控制结构/","link":"","permalink":"http://example.com/2023/11/21/goland-%E6%8E%A7%E5%88%B6%E7%BB%93%E6%9E%84/","excerpt":"","text":"1.if语句123456if 条件语句 &#123; &#125;erse if 条件语句&#123; &#125;else &#123; &#125; 2.switch选择语句1.分支较多选择switch语句.默认从上到下逐一分析.一旦满足条件就会执行并且返回.自带break。 12345678switch i:=6; &#123; case i&gt;10: fmt.Println(i) case i&gt;5 &amp;&amp; i&lt;10: fmt.Println(i) default: fmt.Println(&quot;i&lt;=5&quot;)&#125; 2.switch后带表达式. 1switch i:=6;j 假如设置 1var j=3.66 那么 12345678switch i:=6;j &#123; case i&gt;10: fmt.Println(i) case i&gt;5 &amp;&amp; i&lt;10: fmt.Println(i) default: fmt.Println(&quot;i&lt;=5&quot;)&#125; 会整体报错.因为case后的值的类型必须是和；后的j类型一样 同样也可以是字符串类型等 3.switch语句较为强大 所以表达式可以很随意 123456789switch 1&lt;5 &#123; case true: fmt.Println(&quot;t&quot;) case false: fmt.Println(&quot;f&quot;) default: fmt.Println(&quot;n&quot;) &#125; 3.for语句123for 简单语句;条件;更新语句 &#123; &#125;","categories":[{"name":"goland","slug":"goland","permalink":"http://example.com/categories/goland/"}],"tags":[{"name":"goland","slug":"goland","permalink":"http://example.com/tags/goland/"}]},{"title":"goland-变量常量","slug":"goland-变量常量","date":"2023-11-17T06:32:30.000Z","updated":"2023-12-06T07:50:49.533Z","comments":true,"path":"2023/11/17/goland-变量常量/","link":"","permalink":"http://example.com/2023/11/17/goland-%E5%8F%98%E9%87%8F%E5%B8%B8%E9%87%8F/","excerpt":"","text":"变量常量定义1.普通定义方法 1var i int = 2 2.默认int类型.go语言有类型推导的作用 1var i=10 3.简短声明 1i:=10 4.一次多个声明 1234var(j int=0k =0) 类型1.整形：分为有符号和无符号类型 有符号类型int,int8,int16…无符号类型uint,uint8… 差别在于有符号整形的表示可以为负数 2.浮点型：相较于float32而言float64是更常用的浮点型.相比之下精度更高.误差更小 123var f32 float32 =6.3663363663var f64 float64 =5.662626fmt.Println(f32,f64) 实行代码发现64位丢失数据更少 3.布尔类型 布尔类型只有false和true两种.也可用于一元操作符！ 二元操作符&amp;&amp;和||逻辑与和逻辑或 4.字符串 字符串类型通过string来声明.+号可以用来字符串的相加 123var s1=&quot;sss&quot;var s2 = &quot;aaa&quot;println(s1+s2) 地址12pi:=&amp;i//pi指向i的地址 常量123456789101112//const定义常量//iota用来初始化常量的const(one=1two=2three=3)const(one=1+itoatwo three)//两个代码效果是一样的 格式转换go进行使用和计算式同类型的变量必须进行转换 下面是int类型和string类型的转换方式 1234var i=3s:=strconv.Itoa(i)d,err:=strconv.Atoi(s)fmt.Println(s,d,err) 强制转换int和float类型 12i2f:=float64(i)f2i:=int(f64)","categories":[{"name":"goland","slug":"goland","permalink":"http://example.com/categories/goland/"}],"tags":[{"name":"goland","slug":"goland","permalink":"http://example.com/tags/goland/"}]},{"title":"爬虫爬取b站视频","slug":"爬虫爬取b站视频","date":"2023-11-15T04:25:28.000Z","updated":"2023-12-06T07:49:28.988Z","comments":true,"path":"2023/11/15/爬虫爬取b站视频/","link":"","permalink":"http://example.com/2023/11/15/%E7%88%AC%E8%99%AB%E7%88%AC%E5%8F%96b%E7%AB%99%E8%A7%86%E9%A2%91/","excerpt":"","text":"尝试用python爬取bilibili的视频。123456789101112131415161718192021222324252627282930313233343536373839404142434445import os#用于操作系统的交换模块import requests#发送http请求模块import json#解析jsonimport re#正则表达式from pprint import pprint#美观打印输出json#输入视频网址.只输入前半部分。#网址格式最后到/BV****/url=r&#x27;https://www.bilibili.com/video/BV15H4y1o7UH/&#x27;#设置请求头header=&#123; &quot;User-Agent&quot;:&quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/119.0.0.0 Safari/537.36 Edg/119.0.0.0&quot;, &quot;Preferer&quot;:&quot;https://www.bilibili.com/&quot;&#125;resp=requests.get(url=url,headers=header)#获取http#print(resp.text)# 获取网页.baseurl是视频地址obj=re.compile(r&#x27;window.__playinfo__=(.*?)&lt;/script&gt;&#x27;,re.S)html_data=re.findall(obj,resp.text)[0]#返回一个列表#正则表达式对应匹配网页视频音频#转字符串到json#print(html_data)json_data=json.loads(html_data)#pprint(json_data)#格式化输出#video和audio分别是视频和音频.爬取下来需要合成videos=json_data[&#x27;data&#x27;][&#x27;dash&#x27;][&#x27;video&#x27;]#列表video_url=videos[0][&#x27;baseUrl&#x27;]#视频地址audios=json_data[&#x27;data&#x27;][&#x27;dash&#x27;][&#x27;audio&#x27;]audios_url=audios[0][&#x27;baseUrl&#x27;]#音频地址#下载视频音频resp1=requests.get(url=video_url,headers=header)with open(&#x27;test.mp4&#x27;,mode=&#x27;wb&#x27;) as f: f.write(resp1.content)resp2=requests.get(url=audios_url,headers=header)with open (&#x27;test.mp3&#x27;,mode=&#x27;wb&#x27;) as f: f.write(resp2.content)#爬取完成合并视频音频#利用ffmpeg合并command=r&#x27;ffmpeg -i test.mp4 -i test.mp3 -acodec copy -vcodec copy testout.mp4&#x27;os.system(command=command) 然后左侧文件夹出现爬取的视频音频和合成的视频。 关于我代码过程中出现的错误和解决的过程1.网页开发者模式获取过程中难以找到请求头.刷新解决。2.ffmpeg的环境搭建出问题.通过官网下载插件.将文件夹中bin位置添加到path变量中。 1.cmd测试安装 1&gt;ffmpeg 2.pip安装ffmpy 1pip install ffmpy 3.pip安装ffmpy3（目前 ffmpy3 具有ffmpeg和ffprobe命令的包装器） 1pip install ffmpy3 * 我的问题这里就解决了.无法解决还有配置路径的方法* 3.代码容易出现拼写错误。4.附加ffmpy的下载途径。 Builds - CODEX FFMPEG @ gyan.dev 下载注意不要下载源码版本 5.出现中文乱码.设置调utl-8和电脑设置里的区域中勾选utl-8。6.注意load和loads的用法load的是文件流另一个是字符串，注意甄别。7.首先正则表达式获取才能用相应的字符串代码进行操作。","categories":[{"name":"python","slug":"python","permalink":"http://example.com/categories/python/"}],"tags":[{"name":"python","slug":"python","permalink":"http://example.com/tags/python/"},{"name":"爬虫","slug":"爬虫","permalink":"http://example.com/tags/%E7%88%AC%E8%99%AB/"}]}],"categories":[{"name":"区块链","slug":"区块链","permalink":"http://example.com/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/"},{"name":"算法","slug":"算法","permalink":"http://example.com/categories/%E7%AE%97%E6%B3%95/"},{"name":"goland","slug":"goland","permalink":"http://example.com/categories/goland/"},{"name":"python","slug":"python","permalink":"http://example.com/categories/python/"}],"tags":[{"name":"区块链","slug":"区块链","permalink":"http://example.com/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"},{"name":"goland","slug":"goland","permalink":"http://example.com/tags/goland/"},{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"数据库","slug":"数据库","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"python","slug":"python","permalink":"http://example.com/tags/python/"},{"name":"爬虫","slug":"爬虫","permalink":"http://example.com/tags/%E7%88%AC%E8%99%AB/"}]}