<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>😀</title>
  
  <subtitle>一些study的过程</subtitle>
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2024-03-02T03:01:00.635Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>yangyan</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>goland flag注册命令行</title>
    <link href="http://example.com/2024/01/22/goland-flag%E6%B3%A8%E5%86%8C%E5%91%BD%E4%BB%A4%E8%A1%8C/"/>
    <id>http://example.com/2024/01/22/goland-flag%E6%B3%A8%E5%86%8C%E5%91%BD%E4%BB%A4%E8%A1%8C/</id>
    <published>2024-01-22T06:37:38.000Z</published>
    <updated>2024-03-02T03:01:00.635Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Golang-Flag包使用介绍"><a href="#Golang-Flag包使用介绍" class="headerlink" title="Golang Flag包使用介绍"></a>Golang Flag包使用介绍</h1><p>最简单的命令不需要任何参数和选项，复杂一点，要支持参数和选项的配置。</p><p>模仿一下 <code>ls</code> 命令的参数，示例如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// 直接定义 flag，返回值为指针</span></span><br><span class="line">all := flag.Bool(<span class="string">&quot;all&quot;</span>, <span class="literal">true</span>, <span class="string">&quot;do not ignore entries starting with .&quot;</span>)</span><br><span class="line">color := flag.String(<span class="string">&quot;color&quot;</span>, <span class="string">&quot;omitted&quot;</span>, <span class="string">&quot;colorize the output&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 也可以将 flag 绑定到变量</span></span><br><span class="line"><span class="keyword">var</span> almostAll <span class="type">bool</span></span><br><span class="line">flag.BoolVar(&amp;almostAll, <span class="string">&quot;almost-all&quot;</span>, <span class="literal">false</span>, <span class="string">&quot;do not list implied . and ..&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 除过上面的 Bool String 还有 Int Float64 等其他常用类型</span></span><br><span class="line"></span><br><span class="line">flag.Parse()</span><br><span class="line"></span><br><span class="line"><span class="comment">// Parse 后就可以获取到具体参数的值</span></span><br><span class="line">fmt.Println(*all, *color, almostAll)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://img2022.cnblogs.com/blog/1459179/202207/1459179-20220707200256072-346338494.png" alt="image-20220627175129721"></p><p>支持 <code>-</code> 和 <code>--</code> （效果是一致的），对于非 bool 类型的 flag 其值支持 <code>-flag=val</code> 或者 <code>-flag val</code>。</p><h2 id="长短选项"><a href="#长短选项" class="headerlink" title="长短选项"></a>长短选项</h2><p>短选项书写快捷，适合在终端下面执行，而长选项可读性高，适合在脚本中书写，通过共享一个变量，即可达到此效果</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> name <span class="type">string</span></span><br><span class="line">defaultVal := <span class="string">&quot;tom&quot;</span></span><br><span class="line">useage := <span class="string">&quot;your name&quot;</span></span><br><span class="line">flag.StringVar(&amp;name, <span class="string">&quot;n&quot;</span>, defaultVal, useage+<span class="string">&quot; (shorthand)&quot;</span>)</span><br><span class="line">flag.StringVar(&amp;name, <span class="string">&quot;name&quot;</span>, defaultVal, useage)</span><br><span class="line">flag.Parse()</span><br><span class="line"></span><br><span class="line">fmt.Println(name)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="自定义类型"><a href="#自定义类型" class="headerlink" title="自定义类型"></a>自定义类型</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Durations []time.Duration</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *Durations)</span></span> String() <span class="type">string</span> &#123;</span><br><span class="line"><span class="keyword">return</span> fmt.Sprint(*d)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *Durations)</span></span> Set(value <span class="type">string</span>) <span class="type">error</span> &#123;</span><br><span class="line"><span class="comment">// 支持逗号分割的参数，如：-d 1m,2s,1h</span></span><br><span class="line"><span class="comment">// 也支持 -d 1m -d 2s -d 1h 这种写法</span></span><br><span class="line"><span class="comment">// 如果不想 -d 被指定多次，可以加上这段 if 逻辑</span></span><br><span class="line"><span class="comment">// if len(*d) &gt; 0 &#123;</span></span><br><span class="line"><span class="comment">// return errors.New(&quot;-d flag already set&quot;)</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> _, v := <span class="keyword">range</span> strings.Split(value, <span class="string">&quot;,&quot;</span>) &#123;</span><br><span class="line">duration, err := time.ParseDuration(v)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line">*d = <span class="built_in">append</span>(*d, duration)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> param Durations</span><br><span class="line"><span class="comment">// 第一个参数是接口类型，我们自定义的 Durations 只需要实现 String() 和 Set() 方法即可</span></span><br><span class="line">flag.Var(&amp;param, <span class="string">&quot;d&quot;</span>, <span class="string">&quot;time duration, comma-separated list&quot;</span>)</span><br><span class="line">flag.Parse()</span><br><span class="line">fmt.Println(param)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>os.Args</code>的作用是获取和处理通过命令行传递给程序的参数，使得程序可以根据用户的输入执行相应的操作。</p><p>使用命令行调用函数通常涉及到编写一个可执行的命令行程序。以下是一个简单的步骤：</p><ol><li><strong>导入必要的包</strong>：首先，你需要导入<code>os</code>和<code>flag</code>包，它们分别用于处理操作系统相关的功能和解析命令行参数。</li><li><strong>定义主函数</strong>：在Go中，程序的入口点是<code>main</code>函数。你需要定义一个<code>main</code>函数，并在其中处理命令行参数。</li><li><strong>解析命令行参数</strong>：使用<code>flag</code>包来定义和解析命令行参数。你可以使用<code>flag.String</code>、<code>flag.Int</code>等函数来定义不同类型的参数，并使用<code>flag.Parse()</code>来解析这些参数。</li><li><strong>调用相应的函数</strong>：根据解析得到的命令行参数，你可以调用相应的函数来执行具体的操作。</li></ol><p>以下是一个简单的示例代码，演示了如何在Go语言中使用命令行调用函数：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">        <span class="keyword">go</span>复制代码运行<span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;flag&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// 定义一个字符串类型的命令行参数</span></span><br><span class="line"><span class="keyword">var</span> name <span class="type">string</span></span><br><span class="line">flag.StringVar(&amp;name, <span class="string">&quot;name&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;Name to display&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解析命令行参数</span></span><br><span class="line">flag.Parse()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据解析得到的参数调用相应的函数</span></span><br><span class="line"><span class="keyword">if</span> name != <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">greet(name)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;No name provided.&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">greet</span><span class="params">(name <span class="type">string</span>)</span></span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;Hello, %s!</span></span><br><span class="line"><span class="string">&quot;</span>, name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    </span><br></pre></td></tr></table></figure><p>在这个示例中，我们定义了一个名为<code>name</code>的字符串类型的命令行参数，并使用<code>flag.StringVar</code>来指定它的名称、默认值和描述信息。然后，我们调用<code>flag.Parse()</code>来解析命令行参数。最后，根据解析得到的参数，我们调用<code>greet</code>函数来打印问候语。</p><p>要运行这个程序，你可以将其保存为<code>main.go</code>，然后在命令行中执行以下命令：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">bash复制代码运行<span class="keyword">go</span> run main.<span class="keyword">go</span> -name <span class="string">&quot;John Doe&quot;</span></span><br><span class="line"></span><br><span class="line">    </span><br></pre></td></tr></table></figure><p>这将输出：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">复制代码运行Hello, John Doe!</span><br><span class="line"></span><br><span class="line">    </span><br></pre></td></tr></table></figure><p>你可以根据自己的需求修改和扩展这个示例，以实现更复杂的命令行程序。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Golang-Flag包使用介绍&quot;&gt;&lt;a href=&quot;#Golang-Flag包使用介绍&quot; class=&quot;headerlink&quot; title=&quot;Golang Flag包使用介绍&quot;&gt;&lt;/a&gt;Golang Flag包使用介绍&lt;/h1&gt;&lt;p&gt;最简单的命令不需要任何参数和</summary>
      
    
    
    
    <category term="区块链" scheme="http://example.com/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
    
    <category term="区块链" scheme="http://example.com/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
    <category term="goland" scheme="http://example.com/tags/goland/"/>
    
  </entry>
  
  <entry>
    <title>github转gitee</title>
    <link href="http://example.com/2024/01/21/github%E8%BD%ACgitee/"/>
    <id>http://example.com/2024/01/21/github%E8%BD%ACgitee/</id>
    <published>2024-01-21T05:28:54.000Z</published>
    <updated>2024-02-02T05:38:03.294Z</updated>
    
    <content type="html"><![CDATA[<p>github转gitee讲真的体验真的不好，先是两天的身份认证慢的一批然后就是每次更新内容都要进网页重新创建一下静态网站，而且主题也好似不兼容？创建的时候还有什么磁盘内存不够的报错，搜了半天也没有解决办法，好多还有违禁词的提示，真的很鸡肋一想到这么麻烦我还是用github好点，顶多卡一点的事。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;github转gitee讲真的体验真的不好，先是两天的身份认证慢的一批然后就是每次更新内容都要进网页重新创建一下静态网站，而且主题也好似不兼容？创建的时候还有什么磁盘内存不够的报错，搜了半天也没有解决办法，好多还有违禁词的提示，真的很鸡肋一想到这么麻烦我还是用github好</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>区块链的存储读取和管理</title>
    <link href="http://example.com/2024/01/18/%E5%8C%BA%E5%9D%97%E9%93%BE%E7%9A%84%E5%AD%98%E5%82%A8%E8%AF%BB%E5%8F%96%E5%92%8C%E7%AE%A1%E7%90%86/"/>
    <id>http://example.com/2024/01/18/%E5%8C%BA%E5%9D%97%E9%93%BE%E7%9A%84%E5%AD%98%E5%82%A8%E8%AF%BB%E5%8F%96%E5%92%8C%E7%AE%A1%E7%90%86/</id>
    <published>2024-01-18T01:15:49.000Z</published>
    <updated>2024-03-02T01:54:26.571Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Go语言实现区块链存储、读取与管理。"><a href="#Go语言实现区块链存储、读取与管理。" class="headerlink" title="Go语言实现区块链存储、读取与管理。"></a>Go语言实现区块链存储、读取与管理。</h3><p>之前了解的基本结构，我们每次调试都要创建，重构区块链，但是区块链并没有的到保存，这与实际的区块链系统不符，伴随我们扩展我们的区块链，我们需要一个统一的功能管理模块来操作。</p><h4 id="Badger键值对数据库"><a href="#Badger键值对数据库" class="headerlink" title="Badger键值对数据库"></a>Badger键值对数据库</h4><p>对于区块链的储存，一种想法是序列化，然后用每个区块的哈希值作为文件名储存在磁盘上，但是考虑到我们频繁的对已经存储的区块进行查询，我们用数据库方式存储管理区块。</p><p>Badger是<a href="https://link.zhihu.com/?target=https://dgraph.io/">dgraph.io</a>开发的一款基于 Log Structured Merge (LSM) Tree 的 key-value 本地数据库，什么键值对对应存储对应区块链的存储还是非常有意义的。</p><p><em>非常让人难以接受就是前几天写好的东西，关机忘了保存了，都得重新写，又不能因为已经学了一点了就写的唐突，想死。</em></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go get github.com/dgraph-io/badger</span><br></pre></td></tr></table></figure><p>这个是安装的命令，安装还是比较简单的。但是不知道之前的版本为什么安装不了，可能是版本有点老了吧，然后换了个最新版的，问题就解决了。</p><h4 id="存储地址设定"><a href="#存储地址设定" class="headerlink" title="存储地址设定"></a>存储地址设定</h4><p>创建一个tmp文件夹，就用来储存我们将要存储的区块链了。</p><p>打开constcoe.go设定一些全局变量。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> TransactionPoolFile = <span class="string">&quot;./tmp/transaction_pool.data&quot;</span> <span class="comment">//缓冲池存放交易信息</span></span><br><span class="line"><span class="keyword">const</span> BCPath = <span class="string">&quot;./tmp/blocks&quot;</span></span><br><span class="line"><span class="keyword">const</span> BCFile = <span class="string">&quot;./tmp/blocks/MANIFEST&quot;</span></span><br></pre></td></tr></table></figure><p>这三个是新的，而且这里当时也出问题了，问题就出在下文验证区块链存不存在的代码里，因为路径错了写成了.tmp然后一直就是验证文件不存在&#x3D; &#x3D;。我还去搜了是不是权限的问题或者其他的东西都占用了，果然代码这东西差之毫厘失之千里了。</p><p>BCPath与BCFile都是指向的我们即将创建的区块链数据库的相关地址。</p><p>util.go中增加一个检查文件地址下文件是否存在的函数。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">FileExists</span><span class="params">(fileAddr <span class="type">string</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> _, err := os.Stat(fileAddr); os.IsNotExist(err) &#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>stat是获取文件信息的，不存在就返回错误，然后后边的isnotexist就是检车错误是不是代表文件不存在了。</p><h4 id="区块改动"><a href="#区块改动" class="headerlink" title="区块改动"></a>区块改动</h4><p>奥对了，就是我写的代码都没有引入库因为软件自己就给我整了，不过用最基本的那个好像要手写引入的库的。</p><p>首先是创始区块的构建函数，我们希望他现在可以更加个性化一点，让创始交易信息指向我们提供的地址。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//block.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GenesisBlock</span><span class="params">(address []<span class="type">byte</span>)</span></span> *Block &#123;</span><br><span class="line">tx := transaaction.BaseTx(address)<span class="comment">//初始交易</span></span><br><span class="line">genesis := CreateBlock([]<span class="type">byte</span>(<span class="string">&quot;YY&quot;</span>), []*transaction.Transaction&#123;tx&#125;)</span><br><span class="line">genesis.SetHash()</span><br><span class="line"><span class="keyword">return</span> genesis</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后我们的createblock函数是要用上一个区块的哈希和这个区块数据的，创世区块没有上一个区块，哈希就可以随便定义了。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//block.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Block)</span></span> Serialize() []<span class="type">byte</span> &#123;</span><br><span class="line"><span class="keyword">var</span> res bytes.Buffer<span class="comment">//字节缓冲区</span></span><br><span class="line">encoder := gob.NewEncoder(&amp;res)<span class="comment">//编码器</span></span><br><span class="line">err := encoder.Encode(b)<span class="comment">//写入缓冲区</span></span><br><span class="line">utils.Handle(err)</span><br><span class="line"><span class="keyword">return</span> res.Bytes()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">DeSerializeBlock</span><span class="params">(data []<span class="type">byte</span>)</span></span> *Block &#123;</span><br><span class="line"><span class="keyword">var</span> block Block</span><br><span class="line">decoder := gob.NewDecoder(bytes.NewReader(data))</span><br><span class="line">err := decoder.Decode(&amp;block)</span><br><span class="line">utils.Handle(err)</span><br><span class="line"><span class="keyword">return</span> &amp;block</span><br></pre></td></tr></table></figure><p>添加两个函数用来序列化和反序列化，数据库只能支持字节串的存储形式。</p><h4 id="区块链结构体重构"><a href="#区块链结构体重构" class="headerlink" title="区块链结构体重构"></a>区块链结构体重构</h4><p>之前我们的区块链结构体是区块组成的切片，现在我们的区块存储在数据库中，所以我们的区块链结构体应该指向存储区块的数据库，重构我们的结构体</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//blockchain.go</span></span><br><span class="line"><span class="keyword">type</span> BlockChain <span class="keyword">struct</span> &#123;</span><br><span class="line">LastHash []<span class="type">byte</span></span><br><span class="line">Database *badger.DB</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>LastHash属性是指当前区块链最后一个区块的哈希值，它并不是必须的，但可以避免我们在后面的函数编写中每次都去数据库中查找LastHash。</p><p>然后我们更改掉我们的CreateBlockChain，这个函数是创建一个区块链然后返回区块链的指针的，我们要实现区块链的创建存储和读取，就要删掉这个了。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">InitBlockChain</span><span class="params">(address []<span class="type">byte</span>)</span></span> *BlockChain &#123;</span><br><span class="line"><span class="keyword">var</span> lastHash []<span class="type">byte</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> utils.FileExists(constcoe.BCFile) &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;blockchain already exists&quot;</span>)</span><br><span class="line">runtime.Goexit()<span class="comment">//安全退出</span></span><br><span class="line">&#125;<span class="comment">//验证是不是已经创建了区块链了</span></span><br><span class="line"></span><br><span class="line">opts := badger.DefaultOptions(constcoe.BCPath)<span class="comment">//返回一个结构体就可以用来操作了</span></span><br><span class="line">opts.Logger = <span class="literal">nil</span><span class="comment">//操作信息</span></span><br><span class="line"></span><br><span class="line">db, err := badger.Open(opts)</span><br><span class="line">utils.Handle(err)</span><br><span class="line"></span><br><span class="line">err = db.Update(<span class="function"><span class="keyword">func</span><span class="params">(txn *badger.Txn)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">genesis := GenesisBlock(address)<span class="comment">//创建创世区块</span></span><br><span class="line">fmt.Println(<span class="string">&quot;Genesis Created&quot;</span>)</span><br><span class="line">err = txn.Set(genesis.Hash, genesis.Serialize())<span class="comment">//哈希值和序列化后的数据</span></span><br><span class="line">utils.Handle(err)</span><br><span class="line">err = txn.Set([]<span class="type">byte</span>(<span class="string">&quot;lh&quot;</span>), genesis.Hash) <span class="comment">//store the hash of the block in blockchain</span></span><br><span class="line">utils.Handle(err)</span><br><span class="line">err = txn.Set([]<span class="type">byte</span>(<span class="string">&quot;ogprevhash&quot;</span>), genesis.PrevHash) <span class="comment">//store the prevhash of genesis(original) block</span></span><br><span class="line">utils.Handle(err)</span><br><span class="line">lastHash = genesis.Hash</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;)</span><br><span class="line">utils.Handle(err)</span><br><span class="line">blockchain := BlockChain&#123;lastHash, db&#125;</span><br><span class="line"><span class="keyword">return</span> &amp;blockchain</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>update把函数作为参数，</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(db *DB)</span></span> Update(fn <span class="function"><span class="keyword">func</span><span class="params">(txn *Txn)</span></span> <span class="type">error</span>) <span class="type">error</span> &#123;</span><br><span class="line"><span class="keyword">if</span> db.opt.managedTxns &#123;</span><br><span class="line"><span class="built_in">panic</span>(<span class="string">&quot;Update can only be used with managedDB=false.&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">txn := db.NewTransaction(<span class="literal">true</span>)<span class="comment">//把引入的值txn作为一个事务这样你才可以在update内部的函数进行数据库操作。</span></span><br><span class="line"><span class="keyword">defer</span> txn.Discard()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> err := fn(txn); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> txn.Commit()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们现在期望能够通过已有的数据库读取并加载我们的区块链，这就需要构建ContinueBlockChain函数。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ContinueBlockChain</span><span class="params">()</span></span> *BlockChain &#123;</span><br><span class="line">    <span class="keyword">if</span> utils.FileExists(constcoe.BCFile) == <span class="literal">false</span> &#123;</span><br><span class="line">       fmt.Println(<span class="string">&quot;No blockchain found, please create one first&quot;</span>)</span><br><span class="line">       runtime.Goexit()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> lastHash []<span class="type">byte</span></span><br><span class="line"></span><br><span class="line">    opts := badger.DefaultOptions(constcoe.BCPath)</span><br><span class="line">    opts.Logger = <span class="literal">nil</span></span><br><span class="line">    db, err := badger.Open(opts)</span><br><span class="line">    utils.Handle(err)</span><br><span class="line"><span class="comment">//这上边跟上边一样</span></span><br><span class="line">    <span class="comment">//view调取视图</span></span><br><span class="line">    err = db.View(<span class="function"><span class="keyword">func</span><span class="params">(txn *badger.Txn)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">       item, err := txn.Get([]<span class="type">byte</span>(<span class="string">&quot;lh&quot;</span>))<span class="comment">//获取lh对应的最后区块的值，get获取键值对</span></span><br><span class="line">       utils.Handle(err)<span class="comment">//处理错误</span></span><br><span class="line">       err = item.Value(<span class="function"><span class="keyword">func</span><span class="params">(val []<span class="type">byte</span>)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">          lastHash = val</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">       &#125;)<span class="comment">//这一步作用就是提取这个item里的值，因为item是一个包括键和值的类型。</span></span><br><span class="line">       utils.Handle(err)</span><br><span class="line">       <span class="keyword">return</span> err</span><br><span class="line">    &#125;)</span><br><span class="line">    utils.Handle(err)</span><br><span class="line"></span><br><span class="line">    chain := BlockChain&#123;lastHash, db&#125;</span><br><span class="line">    <span class="keyword">return</span> &amp;chain</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>要将一个区块加入到区块链中，就需要通过数据库来完成。修改AddBlock函数。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//blockchain.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(bc *BlockChain)</span></span> AddBlock(newBlock *Block) &#123;</span><br><span class="line"><span class="keyword">var</span> lastHash []<span class="type">byte</span></span><br><span class="line"><span class="comment">//获取上一个区块的哈希值</span></span><br><span class="line">err := bc.Database.View(<span class="function"><span class="keyword">func</span><span class="params">(txn *badger.Txn)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">item, err := txn.Get([]<span class="type">byte</span>(<span class="string">&quot;lh&quot;</span>))</span><br><span class="line">utils.Handle(err)</span><br><span class="line">err = item.Value(<span class="function"><span class="keyword">func</span><span class="params">(val []<span class="type">byte</span>)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">lastHash = val</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;)</span><br><span class="line">utils.Handle(err)</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;)</span><br><span class="line">utils.Handle(err)</span><br><span class="line"><span class="keyword">if</span> !bytes.Equal(newBlock.PrevHash, lastHash) &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;This block is out of age&quot;</span>)</span><br><span class="line">runtime.Goexit()</span><br><span class="line">&#125;<span class="comment">//判断新区快和上个区块哈希值是否对应</span></span><br><span class="line"></span><br><span class="line">err = bc.Database.Update(<span class="function"><span class="keyword">func</span><span class="params">(transaction *badger.Txn)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">err := transaction.Set(newBlock.Hash, newBlock.Serialize())</span><br><span class="line">utils.Handle(err)</span><br><span class="line">err = transaction.Set([]<span class="type">byte</span>(<span class="string">&quot;lh&quot;</span>), newBlock.Hash)</span><br><span class="line">bc.LastHash = newBlock.Hash<span class="comment">//将bc.LastHash设置为新区块的哈希值</span></span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;)</span><br><span class="line">utils.Handle(err)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="区块链的遍历"><a href="#区块链的遍历" class="headerlink" title="区块链的遍历"></a>区块链的遍历</h4><p>尽管拥有ContinueBlockChain函数后我们实现了对区块链的加载，但是我们发现对于区块链的遍历不像之前那么方便了，FindUnspentTransactions函数一时不知如何修改。这里我们创建一个基于区块的迭代器来实现区块链的遍历。在blockchain.go中创建结构体。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//blockchain.go</span></span><br><span class="line"><span class="keyword">type</span> BlockChainIterator <span class="keyword">struct</span> &#123;</span><br><span class="line">CurrentHash []<span class="type">byte</span></span><br><span class="line">Database    *badger.DB</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建迭代器的初始化函数,在初始化时，将链的最后一个哈希值和数据库实例传递给迭代器。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//blockchain.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(chain *BlockChain)</span></span> Iterator() *BlockChainIterator &#123;</span><br><span class="line">iterator := BlockChainIterator&#123;chain.LastHash, chain.Database&#125;</span><br><span class="line"><span class="keyword">return</span> &amp;iterator</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建迭代器的迭代函数，让每次迭代返回一个block，然后迭代器指向前一个区块的哈希值。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//blockchain.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(iterator *BlockChainIterator)</span></span> Next() *Block &#123;</span><br><span class="line"><span class="keyword">var</span> block *Block</span><br><span class="line"></span><br><span class="line">err := iterator.Database.View(<span class="function"><span class="keyword">func</span><span class="params">(txn *badger.Txn)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">item, err := txn.Get(iterator.CurrentHash)</span><br><span class="line">utils.Handle(err)</span><br><span class="line"></span><br><span class="line">err = item.Value(<span class="function"><span class="keyword">func</span><span class="params">(val []<span class="type">byte</span>)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">block = DeSerializeBlock(val)<span class="comment">//反序列化成为一个区块对象</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;)</span><br><span class="line">utils.Handle(err)</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;)</span><br><span class="line">utils.Handle(err)</span><br><span class="line"></span><br><span class="line">iterator.CurrentHash = block.PrevHash</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> block</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来我们创建一个辅助函数来帮助判断迭代器是否终止。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//blockchain.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(chain *BlockChain)</span></span> BackOgPrevHash() []<span class="type">byte</span> &#123;</span><br><span class="line"><span class="keyword">var</span> ogprevhash []<span class="type">byte</span></span><br><span class="line">err := chain.Database.View(<span class="function"><span class="keyword">func</span><span class="params">(txn *badger.Txn)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">item, err := txn.Get([]<span class="type">byte</span>(<span class="string">&quot;ogprevhash&quot;</span>))</span><br><span class="line">utils.Handle(err)</span><br><span class="line"></span><br><span class="line">err = item.Value(<span class="function"><span class="keyword">func</span><span class="params">(val []<span class="type">byte</span>)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">ogprevhash = val</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">utils.Handle(err)</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;)</span><br><span class="line">utils.Handle(err)</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> ogprevhash</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过比较迭代器的CurrentHash与数据库存储的OgPrevHash是否相等就能够判断迭代器是否已经迭代到创始区块。</p><p>现在我们可以修改FindUnspentTransactions函数了。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//blockchain.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(bc *BlockChain)</span></span> FindUnspentTransactions(address []<span class="type">byte</span>) []transaction.Transaction &#123;</span><br><span class="line"><span class="keyword">var</span> unSpentTxs []transaaction.Transaction</span><br><span class="line">spentTxs := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>][]<span class="type">int</span>) <span class="comment">// can&#x27;t use type []byte as key value</span></span><br><span class="line"></span><br><span class="line">iter := bc.Iterator()</span><br><span class="line"></span><br><span class="line">all:</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">block := iter.Next()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> _, tx := <span class="keyword">range</span> block.Transactions &#123;</span><br><span class="line">txID := hex.EncodeToString(tx.ID)</span><br><span class="line"></span><br><span class="line">IterOutputs:</span><br><span class="line"><span class="keyword">for</span> outIdx, out := <span class="keyword">range</span> tx.Outputs &#123;</span><br><span class="line"><span class="keyword">if</span> spentTxs[txID] != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">for</span> _, spentOut := <span class="keyword">range</span> spentTxs[txID] &#123;</span><br><span class="line"><span class="keyword">if</span> spentOut == outIdx &#123;</span><br><span class="line"><span class="keyword">continue</span> IterOutputs</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> out.ToAddressRight(address) &#123;</span><br><span class="line">unSpentTxs = <span class="built_in">append</span>(unSpentTxs, *tx)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> !tx.IsBase() &#123;</span><br><span class="line"><span class="keyword">for</span> _, in := <span class="keyword">range</span> tx.Inputs &#123;</span><br><span class="line"><span class="keyword">if</span> in.FromAddressRight(address) &#123;</span><br><span class="line">inTxID := hex.EncodeToString(in.TxID)</span><br><span class="line">spentTxs[inTxID] = <span class="built_in">append</span>(spentTxs[inTxID], in.OutIdx)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> bytes.Equal(block.PrevHash, bc.BackOgPrevHash()) &#123;</span><br><span class="line"><span class="keyword">break</span> all</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> unSpentTxs</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里之前讲过了，还是很难理解的，还有那个迭代器&#x3D; &#x3D;。</p><h4 id="交易信息池"><a href="#交易信息池" class="headerlink" title="交易信息池"></a>交易信息池</h4><p>我们是一个区块内装好多交易信息，放在一个交易信息池中，当储存的信息达到一定量就进行挖矿操作，把节点加入区块链。</p><p>我们创建一个交易信息池的结构体。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//transactionpool.go</span></span><br><span class="line"><span class="keyword">type</span> TransactionPool <span class="keyword">struct</span> &#123;</span><br><span class="line">PubTx []*transaction.Transaction</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>PubTx用于储存节点收集到的交易信息。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//transactionpool.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(tp *TransactionPool)</span></span> AddTransaction(tx *transaction.Transaction) &#123;</span><br><span class="line">tp.PubTx = <span class="built_in">append</span>(tp.PubTx, tx)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们希望存储我们新收集到的交易信息，就需要能够保存我们的交易信息池这一结构体。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//transactionpool.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(tp *TransactionPool)</span></span> SaveFile() &#123;</span><br><span class="line"><span class="keyword">var</span> content bytes.Buffer</span><br><span class="line">encoder := gob.NewEncoder(&amp;content)</span><br><span class="line">err := encoder.Encode(tp)</span><br><span class="line">utils.Handle(err)</span><br><span class="line">err = ioutil.WriteFile(constcoe.TransactionPoolFile, content.Bytes(), <span class="number">0644</span>)</span><br><span class="line">utils.Handle(err)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每次都将交易信息池保存到constcoe.TransactionPoolFile这个地址中。0644是指八进制的644（110，100，100），指明了不同用户对文件读写执行的权限。</p><p>加载我们的交易信息池。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(tp *TransactionPool)</span></span> LoadFile() <span class="type">error</span> &#123;</span><br><span class="line"><span class="keyword">if</span> !utils.FileExists(constcoe.TransactionPoolFile) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;<span class="comment">//检车文件是否存在。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> transactionPool TransactionPool</span><br><span class="line"></span><br><span class="line">fileContent, err := ioutil.ReadFile(constcoe.TransactionPoolFile)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//读取</span></span><br><span class="line">decoder := gob.NewDecoder(bytes.NewBuffer(fileContent))<span class="comment">//字节缓冲区然后解码</span></span><br><span class="line">err = decoder.Decode(&amp;transactionPool)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">tp.PubTx = transactionPool.PubTx</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用CreateTransactionPool函数，我们可以创建或者加载一个交易信息池了。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CreateTransactionPool</span><span class="params">()</span></span> *TransactionPool &#123;</span><br><span class="line">transactionPool := TransactionPool&#123;&#125;</span><br><span class="line">err := transactionPool.LoadFile()</span><br><span class="line">utils.Handle(err)</span><br><span class="line"><span class="keyword">return</span> &amp;transactionPool</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后考虑当节点在mine后需要清空交易信息池，我们还需要以下函数。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//transactionpool.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">RemoveTransactionPoolFile</span><span class="params">()</span></span> <span class="type">error</span> &#123;</span><br><span class="line">err := os.Remove(constcoe.TransactionPoolFile)</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>删除constcoe.TransactionPoolFile，即可实现交易信息池的清空。</p><h4 id="挖矿Mine"><a href="#挖矿Mine" class="headerlink" title="挖矿Mine"></a>挖矿Mine</h4><p>pow机制用来挖矿，我们将原blockchain.go下的Mine函数删除，在blockchain文件夹下创建mine.go文件，并创建RunMine函数。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(bc *BlockChain)</span></span> RunMine() &#123;</span><br><span class="line">transactionPool := CreateTransactionPool()<span class="comment">//交易池对象。</span></span><br><span class="line">candidateBlock := CreateBlock(bc.LastHash, transactionPool.PubTx) </span><br><span class="line">    <span class="comment">//将区块链最后的哈希值和交易吃中的公共交易数据创建一个新的区块对象，</span></span><br><span class="line">    <span class="comment">//验证随机数那个工作量证明机制是否正确</span></span><br><span class="line"><span class="keyword">if</span> candidateBlock.ValidatePoW() &#123;</span><br><span class="line">bc.AddBlock(candidateBlock)</span><br><span class="line">err := RemoveTransactionPoolFile()</span><br><span class="line">utils.Handle(err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;Block has invalid nonce.&quot;</span>)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我们省略了验证过程。</p><h4 id="命令行Command-Line"><a href="#命令行Command-Line" class="headerlink" title="命令行Command Line"></a>命令行Command Line</h4><p>使我们的区块链系统运作的更像一个系统而非一个脚本，我们期望实现一个命令行（Command Line）模块，通过该模块来管理我们的区块链系统。</p><p>在我们的项目下创建文件夹cli，然后在cli下创建cli.go文件。</p><p>我们创建一个空结构体来表征我们的命令行。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//cli.go</span></span><br><span class="line"><span class="keyword">type</span> CommandLine <span class="keyword">struct</span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>应该是接口类型然后方便调用吧。</p><p>当我们打开一个命令行程序不知道做什么时，命令行程序首先应打印所有的命令及其用法。我们创建printUsage函数。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//cli.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(cli *CommandLine)</span></span> printUsage() &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;Welcome to Leo Cao&#x27;s tiny blockchain system, usage is as follows:&quot;</span>)</span><br><span class="line">fmt.Println(<span class="string">&quot;--------------------------------------------------------------------------------------------------------------&quot;</span>)</span><br><span class="line">fmt.Println(<span class="string">&quot;All you need is to first create a blockchain and declare the owner.&quot;</span>)</span><br><span class="line">fmt.Println(<span class="string">&quot;And then you can make transactions.&quot;</span>)</span><br><span class="line">fmt.Println(<span class="string">&quot;--------------------------------------------------------------------------------------------------------------&quot;</span>)</span><br><span class="line">fmt.Println(<span class="string">&quot;createblockchain -address ADDRESS                   ----&gt; Creates a blockchain with the owner you input&quot;</span>)</span><br><span class="line">fmt.Println(<span class="string">&quot;balance -address ADDRESS                            ----&gt; Back the balance of the address you input&quot;</span>)</span><br><span class="line">fmt.Println(<span class="string">&quot;blockchaininfo                                      ----&gt; Prints the blocks in the chain&quot;</span>)</span><br><span class="line">fmt.Println(<span class="string">&quot;send -from FROADDRESS -to TOADDRESS -amount AMOUNT  ----&gt; Make a transaction and put it into candidate block&quot;</span>)</span><br><span class="line">fmt.Println(<span class="string">&quot;mine                                                ----&gt; Mine and add a block to the chain&quot;</span>)</span><br><span class="line">fmt.Println(<span class="string">&quot;--------------------------------------------------------------------------------------------------------------&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由上可以看到，我们现在的命令行将管理实现五种功能。createblockchain命令会读取一个地址，然后以该地址创建创始交易信息与创始区块完成区块链的初始化。balance命令读取一个地址，然后在区块链中找到该地址的UTXO并统计出其余额。blockchaininfo将会打印区块链中的所有区块。send命令可以产生一个交易信息并将该交易信息存储到交易信息池中。mine命令模拟挖矿过程，将交易信息池中的交易打包成区块加入区块链中。</p><p>首先是createblockchain，调用在blockchain.go中编写的InitBlockChain函数即可实现。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//cli.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(cli *CommandLine)</span></span> createBlockChain(address <span class="type">string</span>) &#123;</span><br><span class="line">newChain := blockchain.InitBlockChain([]<span class="type">byte</span>(address))</span><br><span class="line">newChain.Database.Close()<span class="comment">//关闭的</span></span><br><span class="line">fmt.Println(<span class="string">&quot;Finished creating blockchain, and the owner is: &quot;</span>, address)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现balance功能时，我们先使用ContinueBlockChain函数接入数据库，然后使用FindUTXO函数统计余额并打印。注意我们这里使用了go语言的defer关键字，其后的代码将会在函数运行结束前最后执行(勘误：准确来说是在return关键字后执行)，也就是我们最后将关闭数据库。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//cli.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(cli *CommandLine)</span></span> getBlockChainInfo() &#123;</span><br><span class="line">chain := blockchain.ContinueBlockChain()</span><br><span class="line"><span class="keyword">defer</span> chain.Database.Close()</span><br><span class="line">iterator := chain.Iterator()<span class="comment">//迭代器</span></span><br><span class="line">ogprevhash := chain.BackOgPrevHash()</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">block := iterator.Next()</span><br><span class="line">fmt.Println(<span class="string">&quot;--------------------------------------------------------------------------------------------------------------&quot;</span>)</span><br><span class="line">fmt.Printf(<span class="string">&quot;Timestamp:%d\n&quot;</span>, block.Timestamp)</span><br><span class="line">fmt.Printf(<span class="string">&quot;Previous hash:%x\n&quot;</span>, block.PrevHash)</span><br><span class="line">fmt.Printf(<span class="string">&quot;Transactions:%v\n&quot;</span>, block.Transactions)</span><br><span class="line">fmt.Printf(<span class="string">&quot;hash:%x\n&quot;</span>, block.Hash)</span><br><span class="line">fmt.Printf(<span class="string">&quot;Pow: %s\n&quot;</span>, strconv.FormatBool(block.ValidatePoW()))</span><br><span class="line">fmt.Println(<span class="string">&quot;--------------------------------------------------------------------------------------------------------------&quot;</span>)</span><br><span class="line">fmt.Println()</span><br><span class="line"><span class="keyword">if</span> bytes.Equal(block.PrevHash, ogprevhash) &#123;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>send命令将会调用CreateTransaction函数，并将创建的交易信息保存到交易信息池中。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//cli.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(cli *CommandLine)</span></span> send(from, to <span class="type">string</span>, amount <span class="type">int</span>) &#123;</span><br><span class="line">chain := blockchain.ContinueBlockChain()</span><br><span class="line"><span class="keyword">defer</span> chain.Database.Close()</span><br><span class="line">tx, ok := chain.CreateTransaction([]<span class="type">byte</span>(from), []<span class="type">byte</span>(to), amount)</span><br><span class="line"><span class="keyword">if</span> !ok &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;Failed to create transaction&quot;</span>)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">tp := blockchain.CreateTransactionPool()</span><br><span class="line">tp.AddTransaction(tx)</span><br><span class="line">tp.SaveFile()</span><br><span class="line">fmt.Println(<span class="string">&quot;Success!&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>挖矿就只需要runmine就可以实现了。</p><p>现在，我们只需要使用go语言自带的flag库将各个命令注册就行了。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//cli.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(cli *CommandLine)</span></span> validateArgs() &#123;</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(os.Args) &lt; <span class="number">2</span> &#123;</span><br><span class="line">cli.printUsage()</span><br><span class="line">runtime.Goexit()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(cli *CommandLine)</span></span> Run() &#123;</span><br><span class="line">cli.validateArgs()</span><br><span class="line"></span><br><span class="line">createBlockChainCmd := flag.NewFlagSet(<span class="string">&quot;createblockchain&quot;</span>, flag.ExitOnError)</span><br><span class="line">balanceCmd := flag.NewFlagSet(<span class="string">&quot;balance&quot;</span>, flag.ExitOnError)</span><br><span class="line">getBlockChainInfoCmd := flag.NewFlagSet(<span class="string">&quot;blockchaininfo&quot;</span>, flag.ExitOnError)</span><br><span class="line">sendCmd := flag.NewFlagSet(<span class="string">&quot;send&quot;</span>, flag.ExitOnError)</span><br><span class="line">mineCmd := flag.NewFlagSet(<span class="string">&quot;mine&quot;</span>, flag.ExitOnError)</span><br><span class="line"></span><br><span class="line">createBlockChainOwner := createBlockChainCmd.String(<span class="string">&quot;address&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;The address refer to the owner of blockchain&quot;</span>)</span><br><span class="line">balanceAddress := balanceCmd.String(<span class="string">&quot;address&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;Who need to get balance amount&quot;</span>)</span><br><span class="line">sendFromAddress := sendCmd.String(<span class="string">&quot;from&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;Source address&quot;</span>)</span><br><span class="line">sendToAddress := sendCmd.String(<span class="string">&quot;to&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;Destination address&quot;</span>)</span><br><span class="line">sendAmount := sendCmd.Int(<span class="string">&quot;amount&quot;</span>, <span class="number">0</span>, <span class="string">&quot;Amount to send&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> os.Args[<span class="number">1</span>] &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&quot;createblockchain&quot;</span>:</span><br><span class="line">err := createBlockChainCmd.Parse(os.Args[<span class="number">2</span>:])</span><br><span class="line">utils.Handle(err)</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> <span class="string">&quot;balance&quot;</span>:</span><br><span class="line">err := balanceCmd.Parse(os.Args[<span class="number">2</span>:])</span><br><span class="line">utils.Handle(err)</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> <span class="string">&quot;blockchaininfo&quot;</span>:</span><br><span class="line">err := getBlockChainInfoCmd.Parse(os.Args[<span class="number">2</span>:])</span><br><span class="line">utils.Handle(err)</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> <span class="string">&quot;send&quot;</span>:</span><br><span class="line">err := sendCmd.Parse(os.Args[<span class="number">2</span>:])</span><br><span class="line">utils.Handle(err)</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> <span class="string">&quot;mine&quot;</span>:</span><br><span class="line">err := mineCmd.Parse(os.Args[<span class="number">2</span>:])</span><br><span class="line">utils.Handle(err)</span><br><span class="line"></span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">cli.printUsage()</span><br><span class="line">runtime.Goexit()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> createBlockChainCmd.Parsed() &#123;</span><br><span class="line"><span class="keyword">if</span> *createBlockChainOwner == <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">createBlockChainCmd.Usage()</span><br><span class="line">runtime.Goexit()</span><br><span class="line">&#125;</span><br><span class="line">cli.createBlockChain(*createBlockChainOwner)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> balanceCmd.Parsed() &#123;</span><br><span class="line"><span class="keyword">if</span> *balanceAddress == <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">balanceCmd.Usage()</span><br><span class="line">runtime.Goexit()</span><br><span class="line">&#125;</span><br><span class="line">cli.balance(*balanceAddress)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> sendCmd.Parsed() &#123;</span><br><span class="line"><span class="keyword">if</span> *sendFromAddress == <span class="string">&quot;&quot;</span> || *sendToAddress == <span class="string">&quot;&quot;</span> || *sendAmount &lt;= <span class="number">0</span> &#123;</span><br><span class="line">sendCmd.Usage()</span><br><span class="line">runtime.Goexit()</span><br><span class="line">&#125;</span><br><span class="line">cli.send(*sendFromAddress, *sendToAddress, *sendAmount)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> getBlockChainInfoCmd.Parsed() &#123;</span><br><span class="line">cli.getBlockChainInfo()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> mineCmd.Parsed() &#123;</span><br><span class="line">cli.mine()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;Go语言实现区块链存储、读取与管理。&quot;&gt;&lt;a href=&quot;#Go语言实现区块链存储、读取与管理。&quot; class=&quot;headerlink&quot; title=&quot;Go语言实现区块链存储、读取与管理。&quot;&gt;&lt;/a&gt;Go语言实现区块链存储、读取与管理。&lt;/h3&gt;&lt;p&gt;之前了解的基</summary>
      
    
    
    
    <category term="区块链" scheme="http://example.com/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
    
    <category term="区块链" scheme="http://example.com/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
    <category term="goland" scheme="http://example.com/tags/goland/"/>
    
  </entry>
  
  <entry>
    <title>算法</title>
    <link href="http://example.com/2023/12/18/%E7%AE%97%E6%B3%95/"/>
    <id>http://example.com/2023/12/18/%E7%AE%97%E6%B3%95/</id>
    <published>2023-12-18T11:27:53.000Z</published>
    <updated>2024-01-11T06:44:18.762Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-P1000-超级玛丽游戏"><a href="#1-P1000-超级玛丽游戏" class="headerlink" title="1.P1000 超级玛丽游戏"></a>1.P1000 超级玛丽游戏</h1><p><a href="https://www.luogu.com.cn/problem/P1000">P1000 超级玛丽游戏 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;                ********\n               ************\n               ####....#.\n             #..###.....##....\n             ###.......######              ###            ###\n                ...........               #...#          #...#\n               ##*#######                 #.#.#          #.#.#\n            ####*******######             #.#.#          #.#.#\n           ...#***.****.*###....          #...#          #...#\n           ....**********##.....           ###            ###\n           ....****    *****....\n             ####        ####\n           ######        ######\n##############################################################\n#...#......#.##...#......#.##...#......#.##------------------#\n###########################################------------------#\n#..#....#....##..#....#....##..#....#....#####################\n##########################################    #----------#\n#.....#......##.....#......##.....#......#    #----------#\n##########################################    #----------#\n#.#..#....#..##.#..#....#..##.#..#....#..#    #----------#\n##########################################    ############&quot;</span>)&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="2-P1001-A-B-Problem"><a href="#2-P1001-A-B-Problem" class="headerlink" title="2.P1001 A+B Problem"></a>2.P1001 A+B Problem</h1><p><a href="https://www.luogu.com.cn/problem/P1001">P1001 A+B Problem - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line"><span class="keyword">var</span> a <span class="type">int</span></span><br><span class="line"><span class="keyword">var</span> b <span class="type">int</span></span><br><span class="line">_,_=fmt.Scanln(&amp;a,&amp;b)</span><br><span class="line"><span class="keyword">var</span> sum = a+b</span><br><span class="line">fmt.Println(sum)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="3-P4327-COCI2006-2007-1-Okviri"><a href="#3-P4327-COCI2006-2007-1-Okviri" class="headerlink" title="3.P4327 [COCI2006-2007#1] Okviri"></a>3.P4327 [COCI2006-2007#1] Okviri</h1><p>[P4327 <a href="https://www.luogu.com.cn/problem/P4327">COCI2006-2007#1] Okviri - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">   <span class="string">&quot;fmt&quot;</span></span><br><span class="line">   <span class="string">&quot;strings&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">var</span> input <span class="type">string</span></span><br><span class="line">   fmt.Scan(&amp;input)</span><br><span class="line">   input = strings.ToUpper(input)</span><br><span class="line">   <span class="keyword">for</span> g, _ := <span class="keyword">range</span> input &#123;</span><br><span class="line"></span><br><span class="line">      fmt.Print(<span class="string">&quot;.&quot;</span>)</span><br><span class="line">      <span class="keyword">if</span> (g+<span class="number">1</span>)%<span class="number">3</span> == <span class="number">0</span> &#123;</span><br><span class="line">         fmt.Print(<span class="string">&quot;.*.&quot;</span>)</span><br><span class="line">         <span class="keyword">continue</span></span><br><span class="line">      &#125;</span><br><span class="line">      fmt.Print(<span class="string">&quot;.#.&quot;</span>)</span><br><span class="line">   &#125;</span><br><span class="line">   fmt.Print(<span class="string">&quot;.&quot;</span>)</span><br><span class="line">   fmt.Println(<span class="string">&quot;&quot;</span>)</span><br><span class="line">   fmt.Print(<span class="string">&quot;.&quot;</span>)</span><br><span class="line">   <span class="keyword">for</span> g, _ := <span class="keyword">range</span> input &#123;</span><br><span class="line">      <span class="keyword">if</span> (g+<span class="number">1</span>)%<span class="number">3</span> == <span class="number">0</span> &#123;</span><br><span class="line">         fmt.Print(<span class="string">&quot;*.*.&quot;</span>)</span><br><span class="line">         <span class="keyword">continue</span></span><br><span class="line">      &#125;</span><br><span class="line">      fmt.Print(<span class="string">&quot;#.#.&quot;</span>)</span><br><span class="line">   &#125;</span><br><span class="line">   fmt.Println(<span class="string">&quot;&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   fmt.Print(<span class="string">&quot;#&quot;</span>)</span><br><span class="line">   <span class="keyword">for</span> g, va := <span class="keyword">range</span> input &#123;</span><br><span class="line">      <span class="keyword">if</span> (g+<span class="number">2</span>)%<span class="number">3</span> == <span class="number">0</span> || (g+<span class="number">1</span>)%<span class="number">3</span>==<span class="number">0</span>&#123;</span><br><span class="line">         <span class="keyword">if</span> g+<span class="number">1</span>==<span class="built_in">len</span>(input)&amp;&amp;(g+<span class="number">1</span>)%<span class="number">3</span>!=<span class="number">0</span> &#123;</span><br><span class="line">            fmt.Printf(<span class="string">&quot;.%c.#&quot;</span>, va)</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">         &#125;</span><br><span class="line">         fmt.Printf(<span class="string">&quot;.%c.*&quot;</span>, va)</span><br><span class="line">         <span class="keyword">continue</span></span><br><span class="line">      &#125;</span><br><span class="line">      fmt.Printf(<span class="string">&quot;.%c.#&quot;</span>,va)</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   fmt.Println(<span class="string">&quot;&quot;</span>)</span><br><span class="line">   fmt.Print(<span class="string">&quot;.&quot;</span>)</span><br><span class="line">   <span class="keyword">for</span> g, _ := <span class="keyword">range</span> input &#123;</span><br><span class="line">      <span class="keyword">if</span> (g+<span class="number">1</span>)%<span class="number">3</span> == <span class="number">0</span> &#123;</span><br><span class="line">         fmt.Print(<span class="string">&quot;*.*.&quot;</span>)</span><br><span class="line">         <span class="keyword">continue</span></span><br><span class="line">      &#125;</span><br><span class="line">      fmt.Print(<span class="string">&quot;#.#.&quot;</span>)</span><br><span class="line">   &#125;</span><br><span class="line">   fmt.Println(<span class="string">&quot;&quot;</span>)</span><br><span class="line">   <span class="keyword">for</span> g, _ := <span class="keyword">range</span> input &#123;</span><br><span class="line"></span><br><span class="line">      fmt.Print(<span class="string">&quot;.&quot;</span>)</span><br><span class="line">      <span class="keyword">if</span> (g+<span class="number">1</span>)%<span class="number">3</span> == <span class="number">0</span> &#123;</span><br><span class="line">         fmt.Print(<span class="string">&quot;.*.&quot;</span>)</span><br><span class="line">         <span class="keyword">continue</span></span><br><span class="line">      &#125;</span><br><span class="line">      fmt.Print(<span class="string">&quot;.#.&quot;</span>)</span><br><span class="line">   &#125;</span><br><span class="line">   fmt.Print(<span class="string">&quot;.&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>真的麻烦啊我超，差点没死了，不过就是控制语句的充分利用，成功了就觉得其实没什么难度了😶。</p><h1 id="4-P1003-NOIP2011-提高组-铺地毯"><a href="#4-P1003-NOIP2011-提高组-铺地毯" class="headerlink" title="4.P1003 [NOIP2011 提高组] 铺地毯"></a>4.P1003 [NOIP2011 提高组] 铺地毯</h1><p>[P1003 <a href="https://www.luogu.com.cn/problem/P1003">NOIP2011 提高组] 铺地毯 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (<span class="string">&quot;fmt&quot;</span>)</span><br><span class="line"><span class="keyword">type</span> di <span class="keyword">struct</span> &#123;ditans []*ditan&#125;<span class="comment">//这里定义的是数组类型的结构体嵌套？</span></span><br><span class="line"><span class="keyword">type</span> ditan <span class="keyword">struct</span> &#123;</span><br><span class="line">   a <span class="type">int</span></span><br><span class="line">   b <span class="type">int</span></span><br><span class="line">   g <span class="type">int</span></span><br><span class="line">   k <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">creatditan</span><span class="params">(a,b,g,k <span class="type">int</span>)</span></span> *ditan &#123;</span><br><span class="line">    ditan:=ditan&#123;a,b,g,k&#125;</span><br><span class="line">    <span class="keyword">return</span> &amp;ditan</span><br><span class="line">&#125;<span class="comment">//输入数据输出一个ditan类型的结构体</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(dit *di)</span></span>addditan(a,b,g,k <span class="type">int</span>)&#123;newditan:=creatditan(a,b,g,k)</span><br><span class="line">dit.ditans=<span class="built_in">append</span>(dit.ditans,newditan)</span><br><span class="line">&#125;<span class="comment">//把ditan加到di里，就可以数组调用了。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">var</span> (</span><br><span class="line">   n <span class="type">int</span></span><br><span class="line">   l <span class="type">int</span></span><br><span class="line">   a, b, g, k <span class="type">int</span></span><br><span class="line">   )</span><br><span class="line">   fmt.Scan(&amp;n)</span><br><span class="line">   <span class="keyword">var</span> newditan di</span><br><span class="line">   <span class="keyword">for</span> l = <span class="number">0</span>; l &lt; n; l++ &#123;fmt.Scan(&amp;a, &amp;b, &amp;g, &amp;k)</span><br><span class="line">   newditan.addditan(a, b, g, k)</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">var</span> (x,y <span class="type">int</span>)</span><br><span class="line">    fmt.Scan(&amp;x,&amp;y)</span><br><span class="line">   <span class="keyword">var</span> q = <span class="number">0</span></span><br><span class="line">   <span class="keyword">for</span> num,bb:=<span class="keyword">range</span> newditan.ditans&#123;</span><br><span class="line">      <span class="keyword">if</span> (x&gt;=bb.a || x&lt;=(bb.g+bb.a))||(y&gt;=bb.b || y&lt;=(bb.k+bb.b))&#123;</span><br><span class="line">         q+=<span class="number">1</span></span><br><span class="line">         fmt.Print(n-num)</span><br><span class="line">         <span class="keyword">break</span>&#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> q==<span class="number">0</span> &#123;fmt.Print(<span class="number">-1</span>)&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这第一种方法，对结构体嵌套的那个算个扩展，实际下边的方法对于切片的使用更合适。</p><p>还有第二个方法</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">   <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Carpet <span class="keyword">struct</span> &#123;</span><br><span class="line">x1, y1, x2, y2 <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">var</span> x,y <span class="type">int</span></span><br><span class="line">n := <span class="number">0</span></span><br><span class="line">fmt.Scan(&amp;n)</span><br><span class="line">carpets := <span class="built_in">make</span>([]Carpet, n)<span class="comment">//这里可以直接定义一个数组类型的结构体。比上边方便多了</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ &#123;</span><br><span class="line">fmt.Scan(&amp;carpets[i].x1, &amp;carpets[i].y1, &amp;carpets[i].x2, &amp;carpets[i].y2)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Scan(&amp;x, &amp;y)</span><br><span class="line"></span><br><span class="line">maxCovered := <span class="number">-1</span></span><br><span class="line">covered := <span class="literal">false</span></span><br><span class="line"><span class="keyword">for</span> i := n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i-- &#123;</span><br><span class="line"><span class="keyword">if</span> x &gt;= carpets[i].x1 &amp;&amp; x &lt;= (carpets[i].x2+carpets[i].x1) &amp;&amp; y &gt;= carpets[i].y1 &amp;&amp; y &lt;= (carpets[i].y2+carpets[i].y1) &#123;</span><br><span class="line">covered = <span class="literal">true</span></span><br><span class="line">maxCovered = i + <span class="number">1</span></span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> covered &#123;</span><br><span class="line">fmt.Println(maxCovered)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">fmt.Println(<span class="number">-1</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下边的方法更简单，因为上边的是我从区块链学的，忘了怎么整这个切片了😔。</p><h1 id="5-P1035-NOIP2002-普及组-级数求和"><a href="#5-P1035-NOIP2002-普及组-级数求和" class="headerlink" title="5.P1035 [NOIP2002 普及组] 级数求和"></a>5.P1035 [NOIP2002 普及组] 级数求和</h1><p>[P1035 <a href="https://www.luogu.com.cn/problem/P1035">NOIP2002 普及组] 级数求和 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> k <span class="type">float64</span></span><br><span class="line">    <span class="keyword">var</span> num <span class="type">float64</span></span><br><span class="line">    <span class="keyword">var</span> n <span class="type">float64</span> = <span class="number">1</span></span><br><span class="line">    fmt.Scan(&amp;k)</span><br><span class="line">    <span class="keyword">for</span> ; ; n++ &#123;</span><br><span class="line">       num += (<span class="number">1</span> / n)</span><br><span class="line">       <span class="keyword">if</span> num &gt; k &#123;</span><br><span class="line">          fmt.Println(n)</span><br><span class="line">          <span class="keyword">break</span></span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这道题很简单啊，错误点就是会一直循环这是因为我们定义的数据类型是整形数据，改成浮点型就好了。</p><h1 id="6-P1046-NOIP2005-普及组-陶陶摘苹果"><a href="#6-P1046-NOIP2005-普及组-陶陶摘苹果" class="headerlink" title="6.P1046 [NOIP2005 普及组] 陶陶摘苹果"></a>6.P1046 [NOIP2005 普及组] 陶陶摘苹果</h1><p>[P1046 <a href="https://www.luogu.com.cn/problem/P1046">NOIP2005 普及组] 陶陶摘苹果 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> x1, x2, x3, x4, x5, x6, x7, x8, x9, x10 <span class="type">int</span></span><br><span class="line">    fmt.Scan(&amp;x1, &amp;x2, &amp;x3, &amp;x4, &amp;x5, &amp;x6, &amp;x7, &amp;x8, &amp;x9, &amp;x10)</span><br><span class="line">    a := []<span class="type">int</span>&#123;x1, x2, x3, x4, x5, x6, x7, x8, x9, x10&#125;</span><br><span class="line">    <span class="keyword">var</span> high <span class="type">int</span></span><br><span class="line">    <span class="keyword">var</span> n <span class="type">int</span></span><br><span class="line">    fmt.Scan(&amp;high)</span><br><span class="line">    <span class="keyword">for</span> _, h := <span class="keyword">range</span> a &#123;</span><br><span class="line">       <span class="keyword">if</span> high &gt;= h &#123;</span><br><span class="line">          n++</span><br><span class="line">       &#125; <span class="keyword">else</span> <span class="keyword">if</span> high+<span class="number">30</span> &gt;= h &#123;</span><br><span class="line">          n++</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Print(n)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>很简单的一题，没什么强调的。</p><h1 id="7-P1047-NOIP2005-普及组-校门外的树"><a href="#7-P1047-NOIP2005-普及组-校门外的树" class="headerlink" title="7.P1047 [NOIP2005 普及组] 校门外的树"></a>7.P1047 [NOIP2005 普及组] 校门外的树</h1><p>[P1047 <a href="https://www.luogu.com.cn/problem/P1047">NOIP2005 普及组] 校门外的树 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> l, m <span class="type">int</span></span><br><span class="line">    fmt.Scan(&amp;l, &amp;m)</span><br><span class="line">    <span class="keyword">var</span> a, b <span class="type">int</span></span><br><span class="line">    list := <span class="built_in">make</span>([]<span class="type">int</span>, l+<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">for</span> ; m &gt; <span class="number">0</span>; m-- &#123;</span><br><span class="line">       a = <span class="number">0</span></span><br><span class="line">       b = <span class="number">0</span></span><br><span class="line">       fmt.Scan(&amp;a, &amp;b)</span><br><span class="line">       <span class="keyword">for</span> ; a &lt;= b; a++ &#123;</span><br><span class="line">          list[a] = <span class="number">1</span></span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> num <span class="type">int</span></span><br><span class="line">    <span class="keyword">for</span> _, n := <span class="keyword">range</span> list &#123;</span><br><span class="line">       num += n</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Print(l + <span class="number">1</span> - num)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这道题如果用那种划分范围的比大小太麻烦了，这种用切片的方法好像更好一点。</p><p>这道题出现一个错误就是定义list切片那一行，不然树木总数不一样。因为容量是从1开始的如果不加1的话就少一个了。</p><h1 id="8-P1075-NOIP2012-普及组-质因数分解"><a href="#8-P1075-NOIP2012-普及组-质因数分解" class="headerlink" title="8.P1075 [NOIP2012 普及组] 质因数分解"></a>8.P1075 [NOIP2012 普及组] 质因数分解</h1><p>[P1075 <a href="https://www.luogu.com.cn/problem/P1075">NOIP2012 普及组] 质因数分解 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></p><p>傻方法但是超时</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">zhishu</span><span class="params">(int2 <span class="type">int</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> int2 &lt;= <span class="number">1</span> &#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">2</span>; i &lt; int2; i++ &#123;</span><br><span class="line">       <span class="keyword">if</span> int2%i == <span class="number">0</span> &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">maxzhishu</span><span class="params">(int2 <span class="type">int</span>)</span></span> (<span class="type">int</span>, <span class="type">bool</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> n := int2; n &gt;= <span class="number">0</span>; n-- &#123;</span><br><span class="line">       <span class="keyword">if</span> zhishu(n) &#123;</span><br><span class="line">          <span class="keyword">if</span> int2%n == <span class="number">0</span> &#123;</span><br><span class="line">             <span class="keyword">if</span> zhishu(int2 / n) &#123;</span><br><span class="line">                <span class="keyword">return</span> n, <span class="literal">true</span></span><br><span class="line">             &#125;</span><br><span class="line">          &#125;</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>, <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> num <span class="type">int</span></span><br><span class="line">    fmt.Scan(&amp;num)</span><br><span class="line">    num, <span class="type">bool</span> := maxzhishu(num)</span><br><span class="line">    <span class="keyword">if</span> <span class="type">bool</span> &#123;</span><br><span class="line">       fmt.Print(num)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>二解，其实我觉得他这个不太合适这个题。可能题目有问题。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> n, i <span class="type">int64</span></span><br><span class="line">    fmt.Scan(&amp;n)</span><br><span class="line">    <span class="keyword">for</span> i = <span class="number">2</span>; i &lt;= n; i++ &#123;</span><br><span class="line">       <span class="keyword">if</span> n%i == <span class="number">0</span> &#123;</span><br><span class="line">          fmt.Println(n / i)</span><br><span class="line">          <span class="keyword">break</span></span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="9-P1085-NOIP2004-普及组-不高兴的津津"><a href="#9-P1085-NOIP2004-普及组-不高兴的津津" class="headerlink" title="9.P1085 [NOIP2004 普及组] 不高兴的津津"></a>9.P1085 [NOIP2004 普及组] 不高兴的津津</h1><p>[P1085 <a href="https://www.luogu.com.cn/problem/P1085">NOIP2004 普及组] 不高兴的津津 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> a, b, num <span class="type">int</span></span><br><span class="line">    <span class="keyword">var</span> n []<span class="type">int</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= <span class="number">7</span>; i++ &#123;</span><br><span class="line">       fmt.Scan(&amp;a, &amp;b)</span><br><span class="line">       num = a + b</span><br><span class="line">       n = <span class="built_in">append</span>(n, num)</span><br><span class="line">    &#125;</span><br><span class="line">    max := <span class="number">8</span></span><br><span class="line">    xingqi := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> we, time := <span class="keyword">range</span> n &#123;</span><br><span class="line">       <span class="keyword">if</span> time &gt; max &#123;</span><br><span class="line">          max = time</span><br><span class="line">          xingqi = we + <span class="number">1</span></span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> max &gt; <span class="number">8</span> &#123;</span><br><span class="line">       fmt.Print(xingqi)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">       fmt.Print(<span class="number">0</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意比较大小，没有难度。</p><h1 id="10-P1089-NOIP2004-提高组-津津的储蓄计划"><a href="#10-P1089-NOIP2004-提高组-津津的储蓄计划" class="headerlink" title="10.P1089 [NOIP2004 提高组] 津津的储蓄计划"></a>10.P1089 [NOIP2004 提高组] 津津的储蓄计划</h1><p>[P1089 <a href="https://www.luogu.com.cn/problem/P1089">NOIP2004 提高组] 津津的储蓄计划 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> money <span class="type">int</span></span><br><span class="line">    <span class="keyword">var</span> sum <span class="type">int</span></span><br><span class="line">    <span class="keyword">var</span> lost <span class="type">int</span></span><br><span class="line">    <span class="keyword">var</span> a [<span class="number">12</span>]<span class="type">int</span></span><br><span class="line">    i := <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> ; i &lt;= <span class="number">12</span>; i++ &#123;</span><br><span class="line">       fmt.Scan(&amp;money)</span><br><span class="line">       lost = lost + <span class="number">300</span> - money</span><br><span class="line">       <span class="keyword">if</span> lost &gt;= <span class="number">100</span> &#123;</span><br><span class="line">          sum += lost - lost%<span class="number">100</span></span><br><span class="line">          lost = lost % <span class="number">100</span></span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span> lost &lt; <span class="number">0</span> &#123;</span><br><span class="line">          a[i] = <span class="number">1</span></span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    q := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> w, nu := <span class="keyword">range</span> a &#123;</span><br><span class="line">       <span class="keyword">if</span> nu == <span class="number">1</span> &#123;</span><br><span class="line">          fmt.Print(-w)</span><br><span class="line">          <span class="keyword">return</span></span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span> nu == <span class="number">0</span> &#123;</span><br><span class="line">          q++</span><br><span class="line">          <span class="keyword">if</span> q == <span class="number">12</span> &#123;</span><br><span class="line">             <span class="keyword">var</span> over1 <span class="type">float64</span> = <span class="type">float64</span>(lost)</span><br><span class="line">             <span class="keyword">var</span> over <span class="type">float64</span> = <span class="type">float64</span>(sum)</span><br><span class="line">             fmt.Print(<span class="number">1.2</span>*over + over1)</span><br><span class="line">          &#125;</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重点在类型转换和最后要加上12月没用完的钱呢。</p><h1 id="11-P1150-Peter-的烟"><a href="#11-P1150-Peter-的烟" class="headerlink" title="11.P1150 Peter 的烟"></a>11.P1150 Peter 的烟</h1><p><a href="https://www.luogu.com.cn/problem/P1150">P1150 Peter 的烟 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> n, k <span class="type">int</span></span><br><span class="line">    fmt.Scan(&amp;n, &amp;k)</span><br><span class="line">    <span class="keyword">var</span> sum <span class="type">int</span></span><br><span class="line">    <span class="keyword">var</span> l, o <span class="type">int</span></span><br><span class="line">    o = n</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">       <span class="keyword">if</span> o &lt; k &#123;</span><br><span class="line">          o += l</span><br><span class="line">          l = <span class="number">0</span></span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span> o &lt; k &#123;</span><br><span class="line">          <span class="keyword">break</span></span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span> o &gt;= k &#123;</span><br><span class="line">          o -= k</span><br><span class="line">          l++</span><br><span class="line">          sum++</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Print(n + sum)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>没难度，就是有点绕弯。</p><h1 id="12-P1151-子数整数"><a href="#12-P1151-子数整数" class="headerlink" title="12.P1151 子数整数"></a>12.P1151 子数整数</h1><p><a href="https://www.luogu.com.cn/problem/P1151#submit">P1151 子数整数 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> k <span class="type">int</span></span><br><span class="line">    fmt.Scan(&amp;k)</span><br><span class="line">    <span class="keyword">var</span> o <span class="type">int</span> = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">10000</span>; i &lt;= <span class="number">30000</span>; i++ &#123;</span><br><span class="line">       <span class="keyword">var</span> s1, s2, s3 <span class="type">int</span></span><br><span class="line">       s1 = (i - i%<span class="number">100</span>) / <span class="number">100</span></span><br><span class="line">       s2 = ((i % <span class="number">10000</span>) - (i%<span class="number">10000</span>)%<span class="number">10</span>) / <span class="number">10</span></span><br><span class="line">       s3 = i % <span class="number">1000</span></span><br><span class="line">       <span class="keyword">if</span> s1%k == <span class="number">0</span> &amp;&amp; s2%k == <span class="number">0</span> &amp;&amp; s3%k == <span class="number">0</span> &#123;</span><br><span class="line">          fmt.Println(i)</span><br><span class="line">          o++</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> o == <span class="number">0</span> &#123;</span><br><span class="line">       fmt.Print(<span class="string">&quot;No&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>没难度</p><h1 id="13-P1152-欢乐的跳"><a href="#13-P1152-欢乐的跳" class="headerlink" title="13.P1152 欢乐的跳"></a>13.P1152 欢乐的跳</h1><p><a href="https://www.luogu.com.cn/problem/P1152">P1152 欢乐的跳 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isAvailable</span><span class="params">(alpha []<span class="type">int</span>, str <span class="type">int</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(alpha); i++ &#123;</span><br><span class="line">       <span class="keyword">if</span> alpha[i] == str &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> n, num <span class="type">int</span></span><br><span class="line">    fmt.Scan(&amp;n)</span><br><span class="line">    list := <span class="built_in">make</span>([]<span class="type">int</span>, n)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt;= n<span class="number">-1</span>; i++ &#123;</span><br><span class="line">       fmt.Scan(&amp;num)</span><br><span class="line">       list[i] = num</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> cha []<span class="type">int</span></span><br><span class="line">    <span class="keyword">var</span> chazhi <span class="type">int</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt;= n<span class="number">-2</span>; i++ &#123;</span><br><span class="line">       chazhi = list[i+<span class="number">1</span>] - list[i]</span><br><span class="line">       cha = <span class="built_in">append</span>(cha, chazhi)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> x, y := <span class="keyword">range</span> cha &#123;</span><br><span class="line">       <span class="keyword">if</span> y &lt; <span class="number">0</span> &#123;</span><br><span class="line">          cha[x] = -y</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> t <span class="type">int</span></span><br><span class="line">    <span class="keyword">for</span> m := <span class="number">1</span>; m &lt;= n<span class="number">-1</span>; m++ &#123;</span><br><span class="line">       <span class="keyword">if</span> isAvailable(cha, m) &#123;</span><br><span class="line">          t = t + <span class="number">1</span></span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span> isAvailable(cha, m) == <span class="literal">false</span> &#123;</span><br><span class="line">          fmt.Println(<span class="string">&quot;Not jolly&quot;</span>)</span><br><span class="line">          <span class="keyword">return</span></span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> t &gt;= n<span class="number">-1</span> &#123;</span><br><span class="line">       fmt.Print(<span class="string">&quot;Jolly&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>没难度，添加个函数就过了。</p><h1 id="14-P1161-开灯"><a href="#14-P1161-开灯" class="headerlink" title="14.P1161 开灯"></a>14.P1161 开灯</h1><p><a href="https://www.luogu.com.cn/problem/P1161">P1161 开灯 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> n <span class="type">int</span></span><br><span class="line">    fmt.Scan(&amp;n)</span><br><span class="line">    <span class="keyword">var</span> t <span class="type">float64</span></span><br><span class="line">    <span class="keyword">var</span> a <span class="type">float64</span></span><br><span class="line">    light := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">int</span>]<span class="type">int</span>)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ &#123;</span><br><span class="line">       fmt.Scan(&amp;a, &amp;t)</span><br><span class="line">       <span class="keyword">for</span> n := <span class="number">1.0</span>; n &lt;= t; n++ &#123;</span><br><span class="line">          b := <span class="type">int</span>(a * n)</span><br><span class="line">          <span class="keyword">if</span> light[b] == <span class="number">1</span> &#123;</span><br><span class="line">             light[b] = <span class="number">0</span></span><br><span class="line">             <span class="keyword">continue</span></span><br><span class="line">          &#125;</span><br><span class="line">          light[b] = <span class="number">1</span></span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> k, l := <span class="keyword">range</span> light &#123;</span><br><span class="line">       <span class="keyword">if</span> l == <span class="number">1</span> &#123;</span><br><span class="line">          fmt.Println(k)</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从未有如此顺利的一道题，一次直接过，我只能说这题用映射真的没毛病。</p><h1 id="15-P1179-NOIP2010-普及组-数字统计"><a href="#15-P1179-NOIP2010-普及组-数字统计" class="headerlink" title="15.P1179 [NOIP2010 普及组] 数字统计"></a>15.P1179 [NOIP2010 普及组] 数字统计</h1><p>[P1179 <a href="https://www.luogu.com.cn/problem/P1179">NOIP2010 普及组] 数字统计 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> l, r, n, a <span class="type">int</span></span><br><span class="line">    fmt.Scan(&amp;l, &amp;r)</span><br><span class="line">    <span class="keyword">for</span> e := r; e &gt;= <span class="number">10</span>; &#123;</span><br><span class="line">       e = e / <span class="number">10</span></span><br><span class="line">       a++</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> ; l &lt;= r; l++ &#123;</span><br><span class="line">       q := l</span><br><span class="line">       <span class="keyword">if</span> q%<span class="number">10</span> == <span class="number">2</span> &#123;</span><br><span class="line">          n++</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= a; i++ &#123;</span><br><span class="line">          q = q / <span class="number">10</span></span><br><span class="line">          <span class="keyword">if</span> q%<span class="number">10</span> == <span class="number">2</span> &#123;</span><br><span class="line">             n++</span><br><span class="line">          &#125;</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(n)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到最后超时了，本来那个计算a的for循环是在下边的for里边的，不过感觉现在这个还是有好多计算是没用的，不过效率居然提高了一半多。</p><h1 id="16-P1200-USACO1-1-你的飞碟在这儿-Your-Ride-Is-Here"><a href="#16-P1200-USACO1-1-你的飞碟在这儿-Your-Ride-Is-Here" class="headerlink" title="16.P1200 [USACO1.1] 你的飞碟在这儿 Your Ride Is Here"></a>16.P1200 [USACO1.1] 你的飞碟在这儿 Your Ride Is Here</h1><p>[P1200 <a href="https://www.luogu.com.cn/problem/P1200">USACO1.1] 你的飞碟在这儿 Your Ride Is Here - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;math&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    map1 := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>)</span><br><span class="line">    map1[<span class="string">&quot;A&quot;</span>] = <span class="number">1</span></span><br><span class="line">    map1[<span class="string">&quot;B&quot;</span>] = <span class="number">2</span></span><br><span class="line">    map1[<span class="string">&quot;C&quot;</span>] = <span class="number">3</span></span><br><span class="line">    map1[<span class="string">&quot;D&quot;</span>] = <span class="number">4</span></span><br><span class="line">    map1[<span class="string">&quot;E&quot;</span>] = <span class="number">5</span></span><br><span class="line">    map1[<span class="string">&quot;F&quot;</span>] = <span class="number">6</span></span><br><span class="line">    map1[<span class="string">&quot;G&quot;</span>] = <span class="number">7</span></span><br><span class="line">    map1[<span class="string">&quot;H&quot;</span>] = <span class="number">8</span></span><br><span class="line">    map1[<span class="string">&quot;I&quot;</span>] = <span class="number">9</span></span><br><span class="line">    map1[<span class="string">&quot;J&quot;</span>] = <span class="number">10</span></span><br><span class="line">    map1[<span class="string">&quot;K&quot;</span>] = <span class="number">11</span></span><br><span class="line">    map1[<span class="string">&quot;L&quot;</span>] = <span class="number">12</span></span><br><span class="line">    map1[<span class="string">&quot;M&quot;</span>] = <span class="number">13</span></span><br><span class="line">    map1[<span class="string">&quot;N&quot;</span>] = <span class="number">14</span></span><br><span class="line">    map1[<span class="string">&quot;O&quot;</span>] = <span class="number">15</span></span><br><span class="line">    map1[<span class="string">&quot;P&quot;</span>] = <span class="number">16</span></span><br><span class="line">    map1[<span class="string">&quot;Q&quot;</span>] = <span class="number">17</span></span><br><span class="line">    map1[<span class="string">&quot;R&quot;</span>] = <span class="number">18</span></span><br><span class="line">    map1[<span class="string">&quot;S&quot;</span>] = <span class="number">19</span></span><br><span class="line">    map1[<span class="string">&quot;T&quot;</span>] = <span class="number">20</span></span><br><span class="line">    map1[<span class="string">&quot;U&quot;</span>] = <span class="number">21</span></span><br><span class="line">    map1[<span class="string">&quot;V&quot;</span>] = <span class="number">22</span></span><br><span class="line">    map1[<span class="string">&quot;W&quot;</span>] = <span class="number">23</span></span><br><span class="line">    map1[<span class="string">&quot;X&quot;</span>] = <span class="number">24</span></span><br><span class="line">    map1[<span class="string">&quot;Y&quot;</span>] = <span class="number">25</span></span><br><span class="line">    map1[<span class="string">&quot;Z&quot;</span>] = <span class="number">26</span></span><br><span class="line">    <span class="keyword">var</span> hui, dui <span class="type">string</span></span><br><span class="line">    fmt.Scan(&amp;hui)</span><br><span class="line">    fmt.Scan(&amp;dui)</span><br><span class="line">    huin := <span class="number">1</span></span><br><span class="line">    duin := <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> _, Q := <span class="keyword">range</span> hui &#123;</span><br><span class="line">       P := <span class="type">string</span>(Q)</span><br><span class="line">       huin *= map1[P]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> _, Q := <span class="keyword">range</span> dui &#123;</span><br><span class="line">       P := <span class="type">string</span>(Q)</span><br><span class="line">       duin *= map1[P]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> duif = <span class="type">float64</span>(duin)</span><br><span class="line">    <span class="keyword">var</span> huif = <span class="type">float64</span>(huin)</span><br><span class="line">    <span class="keyword">if</span> math.Mod(duif, <span class="number">47</span>) == math.Mod(huif, <span class="number">47</span>) &#123;</span><br><span class="line">       fmt.Println(<span class="string">&quot;GO&quot;</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">       fmt.Println(<span class="string">&quot;STAY&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>类型转换多一点</p><h1 id="17-P1304-哥德巴赫猜想"><a href="#17-P1304-哥德巴赫猜想" class="headerlink" title="17.P1304 哥德巴赫猜想"></a>17.P1304 哥德巴赫猜想</h1><p><a href="https://www.luogu.com.cn/problem/P1304">P1304 哥德巴赫猜想 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">zhishu</span><span class="params">(n <span class="type">int</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> n &lt;= <span class="number">1</span> &#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">2</span>; i &lt; n; i++ &#123;</span><br><span class="line">       <span class="keyword">if</span> n%i == <span class="number">0</span> &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">zhishuhe</span><span class="params">(int2 <span class="type">int</span>)</span></span> (<span class="type">int</span>, <span class="type">int</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">2</span>; i &lt;= int2; i++ &#123;</span><br><span class="line">       <span class="keyword">if</span> zhishu(i) &amp;&amp; zhishu(int2-i) &#123;</span><br><span class="line">          <span class="keyword">return</span> i, (int2 - i)</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> N <span class="type">int</span></span><br><span class="line">    fmt.Scan(&amp;N)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">4</span>; i &lt;= N; i += <span class="number">2</span> &#123;</span><br><span class="line">       x, y := zhishuhe(i)</span><br><span class="line">       fmt.Print(i, <span class="string">&quot;=&quot;</span>, x, <span class="string">&quot;+&quot;</span>, y)</span><br><span class="line">       fmt.Println()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>写一个判断是否是质数的函数就ok了</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;1-P1000-超级玛丽游戏&quot;&gt;&lt;a href=&quot;#1-P1000-超级玛丽游戏&quot; class=&quot;headerlink&quot; title=&quot;1.P1000 超级玛丽游戏&quot;&gt;&lt;/a&gt;1.P1000 超级玛丽游戏&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://www.l</summary>
      
    
    
    
    <category term="算法" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="goland" scheme="http://example.com/tags/goland/"/>
    
    <category term="算法" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Badger学习使用</title>
    <link href="http://example.com/2023/12/18/Badger%E5%AD%A6%E4%B9%A0%E4%BD%BF%E7%94%A8/"/>
    <id>http://example.com/2023/12/18/Badger%E5%AD%A6%E4%B9%A0%E4%BD%BF%E7%94%A8/</id>
    <published>2023-12-18T08:49:04.000Z</published>
    <updated>2023-12-22T12:14:50.788Z</updated>
    
    <content type="html"><![CDATA[<h2 id="BADGER简单实用"><a href="#BADGER简单实用" class="headerlink" title="BADGER简单实用"></a>BADGER简单实用</h2><h5 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h5><p>一种kv引擎，KV 引擎是一种键值存储引擎，用于存储键值对。其中，键是唯一的标识符，值是任意数据类型。KV 引擎通常用于缓存、数据库等场景。是 go 生态中比较生产级的存储引擎。</p><h5 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h5><p>指令输入</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go get github.com/dgraph-io/badger</span><br></pre></td></tr></table></figure><p>在这里我的安装出了一些错误，所以我是自己下载的然后自己安装的，如果你也出错了可以<a href="https://gitee.com/mirrors/Badger/repository/archive/main.zip">下载仓库 · Gitee 极速下载&#x2F;Badger - Gitee.com</a>下载之后，通过goland的命令行cd到你下载&#x2F;badger里，然后命令行输入go install就好了。</p><h4 id="数据库操作"><a href="#数据库操作" class="headerlink" title="数据库操作"></a>数据库操作</h4><h5 id="打开数据库"><a href="#打开数据库" class="headerlink" title="打开数据库"></a>打开数据库</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Open</span><span class="params">(path <span class="type">string</span>)</span></span> (*badger.DB, <span class="type">error</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> _, err := os.Stat(path); os.IsNotExist(err) &#123;</span><br><span class="line">os.MkdirAll(path, <span class="number">0755</span>)</span><br><span class="line">&#125;</span><br><span class="line">opts := badger.DefaultOptions(path)</span><br><span class="line">opts.Dir = path</span><br><span class="line">opts.ValueDir = path</span><br><span class="line">opts.SyncWrites = <span class="literal">false</span></span><br><span class="line">opts.ValueThreshold = <span class="number">256</span></span><br><span class="line">opts.CompactL0OnClose = <span class="literal">true</span></span><br><span class="line">db, err := badger.Open(opts)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Println(<span class="string">&quot;badger open failed&quot;</span>, <span class="string">&quot;path&quot;</span>, path, <span class="string">&quot;err&quot;</span>, err)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> db, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>用于打开或创建Badger数据库的函数。</p><p>函数名为<code>Open</code>，接受一个字符串类型的参数<code>path</code>，表示数据库文件的路径。函数返回一个指向<code>badger.DB</code>类型的指针和一个错误信息。</p><p>函数首先使用<code>os.Stat(path)</code>检查指定路径是否存在。如果不存在，则使用<code>os.MkdirAll(path, 0755)</code>创建该路径及其所有父目录，并设置权限为755。</p><p>接下来，函数创建一个<code>badger.DefaultOptions(path)</code>对象，用于配置Badger数据库的选项。这些选项包括：</p><ul><li><code>Dir</code>: 数据库文件所在的目录。</li><li><code>ValueDir</code>: 存储值的目录。</li><li><code>SyncWrites</code>: 是否同步写入磁盘。设置为<code>false</code>可以提高性能，但可能会降低数据的一致性。</li><li><code>ValueThreshold</code>: 触发L0压缩的阈值。当存储的值数量超过这个阈值时，会触发L0压缩以释放空间。</li><li><code>CompactL0OnClose</code>: 是否在关闭数据库时自动进行L0压缩。设置为<code>true</code>可以在程序结束时自动压缩，减少磁盘空间的使用。</li></ul><p>然后，函数使用<code>badger.Open(opts)</code>打开或创建数据库，并将结果赋值给变量<code>db</code>。如果打开过程中出现错误，函数会记录错误信息，并返回<code>nil</code>和错误信息。</p><p>最后，函数返回指向数据库的指针和<code>nil</code>作为错误信息，表示成功打开了数据库。</p><h5 id="内存模式-无盘模式"><a href="#内存模式-无盘模式" class="headerlink" title="内存模式&#x2F;无盘模式"></a>内存模式&#x2F;无盘模式</h5><p>默认Badger 所有数据都保存在磁盘上。它还支持纯内存模式。当 Badger 在内存模式下运行时，所有数据都存储在内存中。在内存模式下读写速度要快得多，但在崩溃或关闭的情况下，存储在 Badger 中的所有数据都会丢失。要在内存模式下打开 badger，设置InMemory选项。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">opts := badger.DefaultOptions(path).WithInMemory(<span class="literal">true</span>)</span><br></pre></td></tr></table></figure><h5 id="关闭数据库"><a href="#关闭数据库" class="headerlink" title="关闭数据库"></a>关闭数据库</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Close</span><span class="params">()</span></span> &#123;</span><br><span class="line">err := badgerDB.Close()</span><br><span class="line"><span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line">log.Println(<span class="string">&quot;database closed&quot;</span>, <span class="string">&quot;err&quot;</span>, err)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">log.Println(<span class="string">&quot;failed to close database&quot;</span>, <span class="string">&quot;err&quot;</span>, err)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>的作用是关闭一个名为<code>badgerDB</code>的数据库连接。在函数内部，首先调用<code>badgerDB.Close()</code>方法来关闭数据库连接，并将返回的错误信息存储在变量<code>err</code>中。然后，通过判断<code>err</code>是否为<code>nil</code>来确定关闭操作是否成功。如果<code>err</code>为<code>nil</code>，则表示关闭操作成功，使用<code>log.Println</code>打印一条日志信息，显示”database closed”和错误信息；否则，表示关闭操作失败，同样使用<code>log.Println</code>打印一条日志信息，显示”failed to close database”和错误信息。</p><h4 id="存储操作"><a href="#存储操作" class="headerlink" title="存储操作"></a>存储操作</h4><h5 id="写入数据"><a href="#写入数据" class="headerlink" title="写入数据"></a>写入数据</h5><p>保存键值对，使用下面Txn.Set()方法。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Set</span><span class="params">(key []<span class="type">byte</span>, value []<span class="type">byte</span>)</span></span> &#123;</span><br><span class="line">wb := badgerDB.NewWriteBatch()</span><br><span class="line"><span class="keyword">defer</span> wb.Cancel()</span><br><span class="line">err := wb.SetEntry(badger.NewEntry(key, value).WithMeta(<span class="number">0</span>))</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Println(<span class="string">&quot;Failed to write data to cache.&quot;</span>,<span class="string">&quot;key&quot;</span>, <span class="type">string</span>(key), <span class="string">&quot;value&quot;</span>, <span class="type">string</span>(value), <span class="string">&quot;err&quot;</span>, err)</span><br><span class="line">&#125;</span><br><span class="line">err = wb.Flush()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Println(<span class="string">&quot;Failed to flush data to cache.&quot;</span>,<span class="string">&quot;key&quot;</span>, <span class="type">string</span>(key), <span class="string">&quot;value&quot;</span>, <span class="type">string</span>(value), <span class="string">&quot;err&quot;</span>, err)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这段代码是一个用于将键值对存储到Badger数据库中的函数。函数名为<code>Set</code>，接受两个参数：<code>key</code>和<code>value</code>，它们都是字节切片类型。</p><p>函数内部首先创建了一个<code>badgerDB.WriteBatch()</code>对象，命名为<code>wb</code>。然后使用<code>defer wb.Cancel()</code>来确保在函数执行完毕后取消批处理操作。</p><p>接下来，通过调用<code>wb.SetEntry(badger.NewEntry(key, value).WithMeta(0))</code>将键值对存储到数据库中。这里使用了<code>badger.NewEntry(key, value)</code>来创建一个键值对条目，并通过<code>.WithMeta(0)</code>设置元数据为0。</p><p>如果存储过程中出现错误，会捕获异常并打印日志信息，包括”Failed to write data to cache.”、键、值和错误信息。</p><p>最后，调用<code>wb.Flush()</code>将批处理中的所有更改刷新到数据库中。如果刷新过程中出现错误，同样会捕获异常并打印日志信息，包括”Failed to flush data to cache.”、键、值和错误信息。</p><p>请注意，这段代码中的<code>badgerDB</code>是一个未定义的变量，你需要在使用之前进行初始化或导入相应的库。</p><p><em>通过使用<code>defer</code>关键字，可以在函数执行完毕后自动调用<code>wb.Cancel()</code>方法来释放这些资源，避免资源泄漏和系统性能下降。</em></p><h5 id="设置TTL的写入数据"><a href="#设置TTL的写入数据" class="headerlink" title="设置TTL的写入数据"></a>设置TTL的写入数据</h5><p>Badger 允许在键上设置可选的生存时间 (TTL) 值。一旦 TTL 过去，密钥将不再可检索，并且将有资格进行垃圾收集。 可以使用和API 方法将 TTL 设置为<code>time.Duration</code>值。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SetWithTTL</span><span class="params">(key []<span class="type">byte</span>, value []<span class="type">byte</span>, ttl <span class="type">int64</span>)</span></span> &#123;</span><br><span class="line">wb := badgerDB.NewWriteBatch()</span><br><span class="line"><span class="keyword">defer</span> wb.Cancel()</span><br><span class="line">err := wb.SetEntry(badger.NewEntry(key, value).WithMeta(<span class="number">0</span>).WithTTL(time.Duration(ttl * time.Second.Nanoseconds())))</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Println(<span class="string">&quot;Failed to write data to cache.&quot;</span>,<span class="string">&quot;key&quot;</span>, <span class="type">string</span>(key), <span class="string">&quot;value&quot;</span>, <span class="type">string</span>(value), <span class="string">&quot;err&quot;</span>, err)</span><br><span class="line">&#125;</span><br><span class="line">err = wb.Flush()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Println(<span class="string">&quot;Failed to flush data to cache.&quot;</span>,<span class="string">&quot;key&quot;</span>, <span class="type">string</span>(key), <span class="string">&quot;value&quot;</span>, <span class="type">string</span>(value), <span class="string">&quot;err&quot;</span>, err)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>名为<code>SetWithTTL</code>的函数，它接受三个参数：<code>key</code>、<code>value</code>和<code>ttl</code>。该函数的作用是将键值对存储到Badger数据库中，并设置一个过期时间（TTL）。</p><p>函数内部首先创建了一个<code>badgerDB.WriteBatch()</code>对象，命名为<code>wb</code>。然后使用<code>defer wb.Cancel()</code>来确保在函数执行完毕后取消批处理操作。</p><p>接下来，通过调用<code>wb.SetEntry()</code>方法将键值对存储到数据库中。在该方法中，使用<code>badger.NewEntry(key, value)</code>创建一个键值对条目，并通过<code>.WithMeta(0)</code>设置元数据为0。然后，使用<code>.WithTTL(time.Duration(ttl * time.Second.Nanoseconds()))</code>设置过期时间为传入的<code>ttl</code>参数所表示的时间。</p><p>如果在存储过程中出现错误，会捕获异常并打印日志信息，包括”Failed to write data to cache.”、键、值和错误信息。</p><p>最后，调用<code>wb.Flush()</code>将批处理中的更改刷新到数据库中。如果刷新过程中出现错误，同样会捕获异常并打印日志信息，包括”Failed to flush data to cache.”、键、值和错误信息。</p><p>请注意，这段代码中的<code>badgerDB</code>是一个未定义的变量，需要在使用之前进行初始化或导入相应的库。</p><h5 id="读取数据"><a href="#读取数据" class="headerlink" title="读取数据"></a>读取数据</h5><p>要读取数据，我们可以使用以下<code>Txn.Get()</code>方法</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Get</span><span class="params">(key []<span class="type">byte</span>)</span></span> <span class="type">string</span> &#123;</span><br><span class="line"><span class="keyword">var</span> ival []<span class="type">byte</span></span><br><span class="line">err := badgerDB.View(<span class="function"><span class="keyword">func</span><span class="params">(txn *badger.Txn)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">item, err := txn.Get(key)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line">ival, err = item.ValueCopy(<span class="literal">nil</span>)</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Println(<span class="string">&quot;Failed to read data from the cache.&quot;</span>,<span class="string">&quot;key&quot;</span>, <span class="type">string</span>(key), <span class="string">&quot;error&quot;</span>, err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="type">string</span>(ival)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接受一个字节切片作为参数（key），并返回一个字符串。这个函数的主要目的是从名为badgerDB的数据库中读取数据。</p><p>函数首先声明了一个空的字节切片ival，用于存储从数据库中获取的值。然后，它调用badgerDB的View方法，该方法接受一个匿名函数作为参数。这个匿名函数接受一个badger.Txn类型的参数txn，并返回一个错误。</p><p>在匿名函数内部，首先尝试从数据库中获取与给定键关联的项目。如果发生错误，函数将立即返回错误。否则，它将使用item.ValueCopy方法将项目的值复制到ival切片中。如果在复制过程中发生错误，函数也将返回错误。</p><p>最后，如果在整个过程中发生任何错误，函数将使用log.Println打印一条错误消息，包括键和错误信息。如果没有错误，函数将返回ival切片转换为字符串的结果。</p><h5 id="存在键"><a href="#存在键" class="headerlink" title="存在键"></a>存在键</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Has</span><span class="params">(key []<span class="type">byte</span>)</span></span> (<span class="type">bool</span>, <span class="type">error</span>) &#123;</span><br><span class="line"><span class="keyword">var</span> exist <span class="type">bool</span> = <span class="literal">false</span></span><br><span class="line">err := badgerDB.View(<span class="function"><span class="keyword">func</span><span class="params">(txn *badger.Txn)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">_, err := txn.Get(key)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">exist = <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// align with leveldb, if the key doesn&#x27;t exist, leveldb returns nil</span></span><br><span class="line"><span class="keyword">if</span> strings.HasSuffix(err.Error(), <span class="string">&quot;not found&quot;</span>) &#123;</span><br><span class="line">err = <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> exist, err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>名为<code>Has</code>的函数，它接受一个字节切片类型的参数<code>key</code>，并返回一个布尔值和一个错误。该函数的作用是检查给定的键是否存在于数据库中。</p><p>函数内部首先声明了一个布尔变量<code>exist</code>并将其初始化为<code>false</code>。然后，使用<code>badgerDB.View</code>方法来遍历数据库中的每个事务。在每个事务中，通过调用<code>txn.Get(key)</code>来获取与给定键关联的值。如果获取成功，则将<code>exist</code>设置为<code>true</code>。如果在获取过程中发生错误，则直接返回该错误。</p><p>最后，根据错误信息判断是否找到了对应的键。如果错误信息以”not found”结尾，说明没有找到对应的键，此时将错误设置为<code>nil</code>。最终，函数返回<code>exist</code>和<code>err</code>两个值，其中<code>exist</code>表示键是否存在，<code>err</code>表示可能发生的错误。</p><h5 id="删除键"><a href="#删除键" class="headerlink" title="删除键"></a>删除键</h5><p>使用<code>Txn.Delete()</code>方法删除 key。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Delete</span><span class="params">(key []<span class="type">byte</span>)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">wb := badgerDB.NewWriteBatch()</span><br><span class="line"><span class="keyword">defer</span> wb.Cancel()</span><br><span class="line"><span class="keyword">return</span> wb.Delete(key)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码是一个用于删除键值对的函数。它使用了BadgerDB数据库，并使用<code>Delete</code>方法来删除指定的键。</p><p>函数的参数是<code>key</code>，它是一个字节切片（<code>[]byte</code>），表示要删除的键。</p><p>函数内部首先创建了一个<code>WriteBatch</code>对象<code>wb</code>，然后使用<code>defer wb.Cancel()</code>确保在函数执行完毕后取消批处理操作。最后，通过调用<code>wb.Delete(key)</code>来删除指定的键，并返回错误信息。</p><p>请注意，这段代码中的<code>badgerDB</code>是一个未定义的变量，你需要在使用之前将其初始化为一个有效的BadgerDB实例。</p><h4 id="查询操作"><a href="#查询操作" class="headerlink" title="查询操作"></a>查询操作</h4><h5 id="遍历key和value"><a href="#遍历key和value" class="headerlink" title="遍历key和value"></a>遍历key和value</h5><p>要迭代键，我们可以使用<code>Iterator</code>，可以使用 <code>Txn.NewIterator()</code>方法获得。迭代以按字节排序的字典顺序发生。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">IteratorKeysAndValues</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">err := badgerDB.View(<span class="function"><span class="keyword">func</span><span class="params">(txn *badger.Txn)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">opts := badger.DefaultIteratorOptions</span><br><span class="line">opts.PrefetchSize = <span class="number">10</span></span><br><span class="line">it := txn.NewIterator(opts)</span><br><span class="line"><span class="keyword">defer</span> it.Close()</span><br><span class="line"><span class="keyword">for</span> it.Rewind(); it.Valid(); it.Next() &#123;</span><br><span class="line">item := it.Item()</span><br><span class="line">k := item.Key()</span><br><span class="line">err := item.Value(<span class="function"><span class="keyword">func</span><span class="params">(v []<span class="type">byte</span>)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;key=%s, value=%s\n&quot;</span>, k, v)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Println(<span class="string">&quot;Failed to iterator keys and values from the cache.&quot;</span>,<span class="string">&quot;error&quot;</span>, err)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>名为<code>IteratorKeysAndValues</code>。它的作用是遍历BadgerDB数据库中的所有键值对，并打印出每个键和对应的值。</p><p>函数内部使用了<code>badgerDB.View</code>方法来创建一个事务视图，然后使用<code>txn.NewIterator</code>方法创建一个新的迭代器对象<code>it</code>。通过设置迭代器的选项<code>opts</code>，可以指定预取大小为10。</p><p>接下来，函数使用<code>it.Rewind()</code>将迭代器重置到第一个元素，然后使用<code>it.Valid()</code>判断是否还有下一个元素。如果有，就使用<code>it.Next()</code>移动到下一个元素。在每次迭代中，函数使用<code>it.Item()</code>获取当前元素的键值对，并将其存储在变量<code>item</code>中。</p><p>然后，函数使用<code>item.Key()</code>获取键，并将其存储在变量<code>k</code>中。接着，函数使用<code>item.Value()</code>获取值，并将其存储在一个匿名函数中。在这个匿名函数中，使用<code>fmt.Printf</code>打印出键和值。</p><p>如果在获取值的过程中发生错误，函数会返回该错误。如果迭代完成，函数会返回<code>nil</code>。</p><p>最后，函数使用<code>log.Println</code>记录日志信息，如果迭代过程中发生错误，会输出”Failed to iterator keys and values from the cache.”以及错误信息。</p><h5 id="遍历keys"><a href="#遍历keys" class="headerlink" title="遍历keys"></a>遍历keys</h5><p>Badger 支持一种独特的迭代模式，称为key-only迭代。它比常规迭代快几个数量级，因为它只涉及对 LSM 树的访问，它通常完全驻留在 RAM 中。要启用仅键迭代，您需要将该IteratorOptions.PrefetchValues 字段设置为false. 这也可用于在迭代期间对选定键进行稀疏读取，item.Value()仅在需要时调用。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">IteratorKeys</span><span class="params">()</span></span>&#123;</span><br><span class="line">    err := badgerDB.View(<span class="function"><span class="keyword">func</span><span class="params">(txn *badger.Txn)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">        opts := badger.DefaultIteratorOptions</span><br><span class="line">        opts.PrefetchValues = <span class="literal">false</span></span><br><span class="line">        it := txn.NewIterator(opts)</span><br><span class="line">        <span class="keyword">defer</span> it.Close()</span><br><span class="line">        <span class="keyword">for</span> it.Rewind(); it.Valid(); it.Next() &#123;</span><br><span class="line">            item := it.Item()</span><br><span class="line">            k := item.Key()</span><br><span class="line">            fmt.Printf(<span class="string">&quot;key=%s\n&quot;</span>, k)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Println(<span class="string">&quot;Failed to iterator keys from the cache.&quot;</span>,<span class="string">&quot;error&quot;</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码是一个名为<code>IteratorKeys</code>的函数，它用于遍历BadgerDB数据库中的所有键。函数内部使用了<code>badgerDB.View</code>方法来创建一个事务视图，然后使用<code>txn.NewIterator</code>方法创建一个新的迭代器对象<code>it</code>。通过设置迭代器的选项<code>opts</code>，可以指定预取值（<code>PrefetchValues</code>）为<code>false</code>。</p><p>在迭代过程中，函数使用<code>it.Rewind()</code>将迭代器重置到第一个元素，然后使用<code>it.Valid()</code>判断是否还有下一个元素。如果有，就使用<code>it.Next()</code>移动到下一个元素。在每次迭代中，函数使用<code>it.Item()</code>获取当前元素的键值对，并将其存储在变量<code>item</code>中。然后，使用<code>item.Key()</code>获取键，并将其存储在变量<code>k</code>中。最后，使用<code>fmt.Printf</code>打印出键。</p><p>如果迭代过程中发生错误，函数会返回该错误。如果迭代完成，函数会返回<code>nil</code>。</p><p>如果在执行过程中出现错误，函数会使用<code>log.Println</code>记录日志信息，并输出”Failed to iterator keys from the cache.”以及错误信息。</p><h5 id="前缀扫描"><a href="#前缀扫描" class="headerlink" title="前缀扫描"></a>前缀扫描</h5><p>要遍历一个键前缀，您可以组合<code>Seek()</code>and <code>ValidForPrefix()</code>：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SeekWithPrefix</span><span class="params">(prefixStr <span class="type">string</span>)</span></span>&#123;</span><br><span class="line">err := badgerDB.View(<span class="function"><span class="keyword">func</span><span class="params">(txn *badger.Txn)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">it := txn.NewIterator(badger.DefaultIteratorOptions)</span><br><span class="line"><span class="keyword">defer</span> it.Close()</span><br><span class="line">prefix := []<span class="type">byte</span>(prefixStr)</span><br><span class="line"><span class="keyword">for</span> it.Seek(prefix); it.ValidForPrefix(prefix); it.Next() &#123;</span><br><span class="line">item := it.Item()</span><br><span class="line">k := item.Key()</span><br><span class="line">err := item.Value(<span class="function"><span class="keyword">func</span><span class="params">(v []<span class="type">byte</span>)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;key=%s, value=%s\n&quot;</span>, k, v)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Println(<span class="string">&quot;Failed to seek prefix from the cache.&quot;</span>, <span class="string">&quot;prefix&quot;</span>, prefixStr,<span class="string">&quot;error&quot;</span>, err)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码是一个名为<code>SeekWithPrefix</code>的函数，它接受一个字符串参数<code>prefixStr</code>。该函数使用BadgerDB数据库进行操作，并遍历所有以给定前缀开头的键值对。</p><p>函数内部首先创建一个迭代器对象<code>it</code>，然后使用<code>txn.NewIterator(badger.DefaultIteratorOptions)</code>方法初始化迭代器。接下来，将<code>prefixStr</code>转换为字节切片<code>prefix</code>，并使用<code>it.Seek(prefix)</code>方法从第一个匹配的前缀开始遍历。</p><p>在循环中，每次迭代都会检查当前项是否仍然具有相同的前缀，这是通过调用<code>it.ValidForPrefix(prefix)</code>实现的。如果当前项仍然具有相同的前缀，则继续执行循环体中的代码。</p><p>在循环体中，首先获取当前项的键和值，分别存储在变量<code>k</code>和<code>v</code>中。然后，使用<code>item.Value()</code>方法获取值，并将其打印出来。最后，返回<code>nil</code>表示成功处理了当前项。</p><p>如果在处理过程中发生错误，函数会立即返回错误信息。否则，在循环结束后返回<code>nil</code>表示成功完成遍历。</p><p>如果在执行过程中出现任何错误，函数会使用<code>log.Println()</code>记录日志信息，包括前缀字符串、错误信息等。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;BADGER简单实用&quot;&gt;&lt;a href=&quot;#BADGER简单实用&quot; class=&quot;headerlink&quot; title=&quot;BADGER简单实用&quot;&gt;&lt;/a&gt;BADGER简单实用&lt;/h2&gt;&lt;h5 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerli</summary>
      
    
    
    
    <category term="区块链" scheme="http://example.com/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
    
    <category term="区块链" scheme="http://example.com/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
    <category term="goland" scheme="http://example.com/tags/goland/"/>
    
    <category term="数据库" scheme="http://example.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>UTXO代码的加入</title>
    <link href="http://example.com/2023/12/03/fileUTXO%E4%BB%A3%E7%A0%81%E7%9A%84%E5%8A%A0%E5%85%A5/"/>
    <id>http://example.com/2023/12/03/fileUTXO%E4%BB%A3%E7%A0%81%E7%9A%84%E5%8A%A0%E5%85%A5/</id>
    <published>2023-12-03T05:28:37.000Z</published>
    <updated>2023-12-13T12:59:11.245Z</updated>
    
    <content type="html"><![CDATA[<h1 id="交易信息与UTXO模型"><a href="#交易信息与UTXO模型" class="headerlink" title="交易信息与UTXO模型"></a>交易信息与UTXO模型</h1><p>区块链中的货币存储是记录交易的过程，而非记录最终的货币数量。平时使用支付宝和微信支付时，货币的存储在中央，所以调用和更改很容易，在确保中心诚实可信的情况下，我们的货币才是安全的，但是一旦它被攻破或者服务器出现问题，那么交易就会被终止，我们的货币也处在一种不安全的状态。uxto记录的交易过程拥有一个存在输入和输出的账本，剩余的货币则会在创建一个输出到自己的过程。</p><p>首先创建交易信息的两部分，input和output。</p><p>首先创建一个transaction文件夹，用于分类，装我们要用的交易内容一类。</p><p>首先创建inoutput.go创建结构体作交易账本。分为两部分。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> TXoutput <span class="keyword">struct</span> &#123;</span><br><span class="line">   Value <span class="type">int</span></span><br><span class="line">   Toaddress []<span class="type">byte</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> TXintput <span class="keyword">struct</span>&#123;</span><br><span class="line">   TXid []<span class="type">byte</span></span><br><span class="line">   Outidx <span class="type">int</span></span><br><span class="line">   Fromaddress []<span class="type">byte</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输入的有txid是上一次交易的信息，还有有发起人的地址和位于上次交易的第几条。输出的是输出多少币和接收者的地址。</p><p>创建transaction.go，放入本次交易的结构体</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Transaction <span class="keyword">struct</span> &#123;</span><br><span class="line">Id []<span class="type">byte</span></span><br><span class="line">Inputs []TXintput</span><br><span class="line">Outputs []TXoutput</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em>首字母大写才能在别的file里边用这些参数，不然没办法引用的。</em></p><p>transaction里由本身的哈希值和输入输出的交易。inouts则会记载上一次交易中对本id进行的outputs。txoutput则可以实现找零，即多出来的币要交易给自己。</p><p>首先计算每个transaction的哈希值。然后返回充当id。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(tx *Transaction)</span></span>TXhash() []<span class="type">byte</span>  &#123;</span><br><span class="line">   <span class="keyword">var</span> encoded bytes.Buffer</span><br><span class="line">   <span class="keyword">var</span> hash [<span class="number">32</span>]<span class="type">byte</span></span><br><span class="line">   encoder:=gob.NewEncoder(&amp;encoded)</span><br><span class="line">   err:=encoder.Encode(tx)</span><br><span class="line">   utils.Handle(err)</span><br><span class="line">   hash=sha256.Sum256(encoded.Bytes())</span><br><span class="line">   <span class="keyword">return</span> hash[:]</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span>  <span class="params">(tx* Transaction)</span></span>Setid()  &#123;</span><br><span class="line">   tx.Id=tx.TXhash()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em>var encoded bytes.Buffer创建一个字节缓冲区，用于事后的编码和哈希值的计算。而handle我们之前已经说过了，是处理错误的函数</em></p><p>第二步setid将计算好的哈希值返回给结构体。</p><p>之前创建了初始区块，现在丰富一下初始区块的交易信息作为内容，之前的date得淘汰了。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BaseTX</span> <span class="params">(toaddress []<span class="type">byte</span>)</span></span> *Transaction  &#123;</span><br><span class="line">   txin:=TXintput&#123;[]<span class="type">byte</span>&#123;&#125;,<span class="number">-1</span>,[]<span class="type">byte</span>&#123;&#125;&#125;</span><br><span class="line">   txout:=TXoutput&#123;constcoe.Initcoin,toaddress&#125;</span><br><span class="line">   tx:=Transaction&#123;[]<span class="type">byte</span>(<span class="string">&quot;god&quot;</span>),[]TXintput&#123;txin&#125;,[]TXoutput&#123;txout&#125;&#125;</span><br><span class="line">    <span class="keyword">return</span> &amp;tx</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(tx *Transaction )</span></span>Isbase() <span class="type">bool</span>&#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="built_in">len</span>(tx.Inputs)==<span class="number">1</span> &amp;&amp; tx.Inputs[<span class="number">0</span>].Outidx==<span class="number">-1</span></span><br></pre></td></tr></table></figure><p>创建一个basetx的函数，输入第一笔交易要给的地址，因为第一笔交易之前没有交易，所以-1表示。constcoe则是我们定义的常量用作我们创建时的总的比特币数目，我们转到之前就创建的constcoe.go中设置。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Difficulty = <span class="number">10</span></span><br><span class="line"><span class="keyword">const</span> Initcoin=<span class="number">500</span></span><br></pre></td></tr></table></figure><p>isbase则判断是否是初始交易，用作之后的计算utxo的辅助。只用判断长度是不是1，和内容的outidx是不是-1就好了。</p><p>我们上边设置了第一笔交易的内容，id我们也可以自己设置。这是一种特权。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(in *TXintput)</span></span>Fromaddressright(address []<span class="type">byte</span>)  <span class="type">bool</span>&#123;</span><br><span class="line">   <span class="keyword">return</span> bytes.Equal(in.Fromaddress,address)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(out *TXoutput)</span></span>Toaddressright(address []<span class="type">byte</span>)  <span class="type">bool</span>&#123;</span><br><span class="line"><span class="keyword">return</span> bytes.Equal(out.Toaddress,address)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>转到inoutput.go创建上边的俩个函数，以后计算utxo时能起到辅助作用。</p><p>现在代码写完了，重构一下之前的内容。首先是结构体block。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Block <span class="keyword">struct</span> &#123;</span><br><span class="line">   Timestamp <span class="type">int64</span></span><br><span class="line">   Hash      []<span class="type">byte</span></span><br><span class="line">   PrevHash  []<span class="type">byte</span></span><br><span class="line">   Target []<span class="type">byte</span></span><br><span class="line">   Nonce <span class="type">int64</span></span><br><span class="line">   transactions []*transaaction.Transaction</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在返回区块哈希的函数中，我们创建一个函数来处理交易信息，让它成为一个序列。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Block)</span></span>Backtrasactionsummary() []<span class="type">byte</span> &#123;</span><br><span class="line">   txids:=<span class="built_in">make</span>([][]<span class="type">byte</span>,<span class="number">0</span>)</span><br><span class="line">   <span class="keyword">for</span> _,tx:=<span class="keyword">range</span> b.transactions&#123;</span><br><span class="line">      txids=<span class="built_in">append</span>(txids,tx.Id)</span><br><span class="line">   &#125;</span><br><span class="line">  summary:=bytes.Join(txids,[]<span class="type">byte</span>&#123;&#125;)</span><br><span class="line">  <span class="keyword">return</span> summary</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Block)</span></span> SetHash() &#123;</span><br><span class="line">   information := bytes.Join([][]<span class="type">byte</span>&#123;utils.ToHexInt(b.Timestamp), b.PrevHash, b.Target,utils.ToHexInt(b.Nonce),b.Backtrasactionsummary()&#125;, []<span class="type">byte</span>&#123;&#125;)</span><br><span class="line">   hash := sha256.Sum256(information)</span><br><span class="line">   b.Hash = hash[:]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>内容就是先创建一个空切片用来装集合起来的交易数据，遍历整个交易数据，将输入输出的哈希值也就是id集合起来进行哈希值的计算。</p><p>用到的append函数和join函数都与切片的操作有关系，append函数如果原始切片有足够的容量，新元素会被添加到原切片的后面；如果没有足够容量，则会重新分配内存并拷贝原有元素和新元素。此外，<code>append</code>函数还可以用于合并多个数组或切片。它是一个内置函数，无需引入任何包即可使用。join函数不是Go语言的标准库函数，因此可能需要根据具体的应用场景来实现。一般来说，<code>join</code>可能用于将多个字符串或其他类型的元素连接成一个单独的字符串或元素。</p><p>在这里的append输出切片没办法勇总哈希值计算，所以用bytes.join转为字节切片再输出。</p><p>然后修改CreateBlock与GenesisBlock两个函数。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CreateBlock</span><span class="params">(prevhash []<span class="type">byte</span>, txs []*transaaction.Transaction)</span></span> *Block &#123;</span><br><span class="line">   block := Block&#123;time.Now().Unix(), []<span class="type">byte</span>&#123;&#125;, prevhash, []<span class="type">byte</span>&#123;&#125;, <span class="number">0</span>, txs&#125;</span><br><span class="line">   block.Target = block.GetTarget()</span><br><span class="line">   block.Nonce=block.FindNonce()</span><br><span class="line">   block.SetHash()</span><br><span class="line">   <span class="keyword">return</span> &amp;block</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GenesisBlock</span><span class="params">()</span></span> *Block &#123;</span><br><span class="line">tx:=transaaction.BaseTX([]<span class="type">byte</span>(<span class="string">&quot;yangyan&quot;</span>))</span><br><span class="line">   <span class="keyword">return</span> CreateBlock([]<span class="type">byte</span>&#123;&#125;, []*transaaction.Transaction&#123;tx&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们在创建创世区块的同时一并创建了初始交易信息，并且把所有的币都转了。</p><p>现在转到proofofwork.go修改getbse4nonce函数。</p><p>函数用作合成带随机数的数据。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Block)</span></span> GetBase4Nonce(nonce <span class="type">int64</span>) []<span class="type">byte</span> &#123;</span><br><span class="line">data := bytes.Join([][]<span class="type">byte</span>&#123;</span><br><span class="line">utils.ToHexInt(b.Timestamp),</span><br><span class="line">b.PrevHash,</span><br><span class="line">utils.ToHexInt(<span class="type">int64</span>(nonce)),</span><br><span class="line">b.Target,</span><br><span class="line">b.Backtrasactionsummary(),</span><br><span class="line">&#125;,</span><br><span class="line">[]<span class="type">byte</span>&#123;&#125;,</span><br><span class="line">)</span><br><span class="line"><span class="keyword">return</span> data</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改AddBlock与CreateBlockChain两个函数。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(bc *BlockChain)</span></span> AddBlock(txs []*transaaction.Transaction) &#123;</span><br><span class="line">   newBlock := CreateBlock(bc.Blocks[<span class="built_in">len</span>(bc.Blocks)<span class="number">-1</span>].Hash, txs)</span><br><span class="line">   bc.Blocks = <span class="built_in">append</span>(bc.Blocks, newBlock)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CreateBlockChain</span><span class="params">()</span></span> *BlockChain &#123;</span><br><span class="line">   blockchain := BlockChain&#123;&#125;</span><br><span class="line">   blockchain.Blocks = <span class="built_in">append</span>(blockchain.Blocks, GenesisBlock())</span><br><span class="line">   <span class="keyword">return</span> &amp;blockchain</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来如果创建createtransaction这样的函数，创建交易信息重点就在于找到足够的前置交易信息来支撑本次交易。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(bc *BlockChain)</span></span>Findunspentransactions(address []<span class="type">byte</span>)[]transaaction.Transaction  &#123;</span><br><span class="line"><span class="keyword">var</span> unspenttxs []transaaction.Transaction</span><br><span class="line">    spenttxs:=<span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>][]<span class="type">int</span>)</span><br><span class="line">   <span class="keyword">for</span> idx:=<span class="built_in">len</span>(bc.Blocks)<span class="number">-1</span>;idx&gt;=<span class="number">0</span>;idx-- &#123;</span><br><span class="line">      block:=bc.Blocks[idx]</span><br><span class="line">      <span class="keyword">for</span> _,tx:=<span class="keyword">range</span> block.transactions&#123;</span><br><span class="line">         txid:=hex.EncodeToString(tx.Id)</span><br><span class="line">   interoutputs:</span><br><span class="line">      <span class="keyword">for</span> outidx,out:=<span class="keyword">range</span> tx.Outputs&#123;</span><br><span class="line">         <span class="keyword">if</span> spenttxs[txid]!=<span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> _,spentout:=<span class="keyword">range</span> spenttxs[txid]&#123;</span><br><span class="line">               <span class="keyword">if</span> spentout == outidx&#123;</span><br><span class="line">                  <span class="keyword">continue</span>  interoutputs</span><br><span class="line">               &#125;</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">if</span> out.Toaddressright(address)&#123;</span><br><span class="line">            unspenttxs=<span class="built_in">append</span>(unspenttxs,*tx)</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">         <span class="keyword">if</span> !tx.Isbase() &#123;</span><br><span class="line">            <span class="keyword">for</span> _,in:=<span class="keyword">range</span> tx.Inputs&#123;</span><br><span class="line">               <span class="keyword">if</span> in.Fromaddressright(address)&#123;</span><br><span class="line">                  intxid:=hex.EncodeToString(in.TXid)</span><br><span class="line">                  spenttxs[intxid]=<span class="built_in">append</span>(spenttxs[intxid],in.Outidx)</span><br><span class="line">               &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line"><span class="keyword">return</span> unspenttxs</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码解读就是先创建一个没有花费的结构体集合和一个用于装已经花费的映射，映射里是id映射前置第几比交易。进行区块的倒循环，遍历没一个区块的id。然后遍历输出的地址在映射里是不是能找得到，找得到的话切片里也对的上也是前置交易的第几比交易，那么就是已经花费并且已经记录的交易。如果不一样那么看是不是输入到这个地址，如果是那就是没被花费的。判断是否是初始交易如果不是即遍历前置交易，如果是对应的地址就代表已经花费，则计入映射和来自前置交易第几比交易。</p><p><em>有点乱，理解一下就懂了</em></p><p>利用findunspenttransactions函数返回的没消费的交易，我们可以计算一个地址的所有uxto。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(bc *BlockChain)</span></span> FindUTXOs(address []<span class="type">byte</span>) (<span class="type">int</span>, <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>) &#123;</span><br><span class="line">   unspentOuts := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>)</span><br><span class="line">   unspentTxs := bc.Findunspentransactions(address)</span><br><span class="line">   accumulated := <span class="number">0</span></span><br><span class="line"></span><br><span class="line">Work:</span><br><span class="line">   <span class="keyword">for</span> _, tx := <span class="keyword">range</span> unspentTxs &#123;</span><br><span class="line">      txID := hex.EncodeToString(tx.Id)</span><br><span class="line">      <span class="keyword">for</span> outIdx, out := <span class="keyword">range</span> tx.Outputs &#123;</span><br><span class="line">         <span class="keyword">if</span> out.Toaddressright(address) &#123;</span><br><span class="line">            accumulated += out.Value</span><br><span class="line">            unspentOuts[txID] = outIdx<span class="comment">//如果一笔交易有好多次转向这个地址的交易，只会记录最后一笔的outidx</span></span><br><span class="line">            <span class="keyword">continue</span> Work</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> accumulated, unspentOuts</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>遍历没有花费的交易里边的outputs，遍历一下把value汇总一下，地址添加到索引里。每个交易只能有一个输出跟给定的地址相关联。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(bc *BlockChain)</span></span>Findspendableoutputs(address []<span class="type">byte</span>,amount <span class="type">int</span>)(<span class="type">int</span>,<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>) &#123;</span><br><span class="line">unspentouts := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>)</span><br><span class="line">unspenttxs := bc.Findunspentransactions(address)</span><br><span class="line">accumulated:=<span class="number">0</span></span><br><span class="line"></span><br><span class="line">work:</span><br><span class="line"><span class="keyword">for</span> _,tx:=<span class="keyword">range</span> unspenttxs&#123;</span><br><span class="line">txid:=hex.EncodeToString(tx.Id)</span><br><span class="line"><span class="keyword">for</span> outidx,out:=<span class="keyword">range</span> tx.Outputs&#123;</span><br><span class="line"><span class="keyword">if</span> out.Toaddressright(address)&amp;&amp;accumulated&lt;amount&#123;</span><br><span class="line">accumulated+=out.Value</span><br><span class="line">unspentouts[txid]=outidx</span><br><span class="line"><span class="keyword">if</span> accumulated&gt;=amount&#123;<span class="keyword">break</span> work</span><br><span class="line">                                          &#125;</span><br><span class="line"><span class="keyword">continue</span> work</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> accumulated,unspentouts</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>只需要找到资产总量大于本次交易转账的一部分utxo就可以了，没必要每一笔都计算在内。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(bc *BlockChain)</span></span>Creatransaction(from,to []<span class="type">byte</span>,amount <span class="type">int</span>)(*transaaction.Transaction,<span class="type">bool</span>)  &#123;</span><br><span class="line">   <span class="keyword">var</span> inputs []transaaction.TXintput</span><br><span class="line">   <span class="keyword">var</span> outputs []transaaction.TXoutput</span><br><span class="line">   acc,validoutputs:=bc.Findspendableoutputs(from,amount)</span><br><span class="line">   <span class="keyword">if</span> acc&lt;amount&#123;</span><br><span class="line">      fmt.Println(<span class="string">&quot;不够&quot;</span>)</span><br><span class="line">      <span class="keyword">return</span> &amp;transaaction.Transaction&#123;&#125;,<span class="literal">false</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">for</span> txid,outidx:=<span class="keyword">range</span> validoutputs &#123;</span><br><span class="line">      txid,err:=hex.DecodeString(txid)</span><br><span class="line">      utils.Handle(err)</span><br><span class="line">      intput:=transaaction.TXintput&#123;txid,outidx,from&#125;</span><br><span class="line">      inputs=<span class="built_in">append</span>(inputs,intput)</span><br><span class="line">   &#125;</span><br><span class="line">   outputs = <span class="built_in">append</span>(outputs, transaaction.TXoutput&#123;amount, to&#125;)</span><br><span class="line">   <span class="keyword">if</span> acc &gt; amount &#123;</span><br><span class="line">      outputs = <span class="built_in">append</span>(outputs, transaaction.TXoutput&#123;acc - amount, from&#125;)</span><br><span class="line">   &#125;</span><br><span class="line">   tx := transaaction.Transaction&#123;<span class="literal">nil</span>, inputs, outputs&#125;</span><br><span class="line">   tx.Setid()</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> &amp;tx, <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这一段函数比较简单，先小于再等于再大于，小于就报错返回不够，等于就直接输出，大于就在等于的基础上添加一笔将剩余币返回给自己的程序。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(bc *BlockChain)</span></span>Mine(txs []*transaaction.Transaction)  &#123;</span><br><span class="line">   bc.AddBlock(txs)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段函数模拟矿工的打包过程</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   txPool := <span class="built_in">make</span>([]*transaaction.Transaction, <span class="number">0</span>)</span><br><span class="line">   <span class="keyword">var</span> tempTx *transaaction.Transaction</span><br><span class="line">   <span class="keyword">var</span> ok <span class="type">bool</span></span><br><span class="line">   <span class="keyword">var</span> property <span class="type">int</span></span><br><span class="line">   chain := blockchain.CreateBlockChain()</span><br><span class="line">   property, _ = chain.FindUTXOs([]<span class="type">byte</span>(<span class="string">&quot;yangyan&quot;</span>))</span><br><span class="line">   fmt.Println(<span class="string">&quot;Balance of yangyan: &quot;</span>, property)</span><br><span class="line"></span><br><span class="line">   tempTx, ok = chain.Creatransaction([]<span class="type">byte</span>(<span class="string">&quot;yangyan&quot;</span>), []<span class="type">byte</span>(<span class="string">&quot;K&quot;</span>), <span class="number">100</span>)</span><br><span class="line">   <span class="keyword">if</span> ok &#123;</span><br><span class="line">      txPool = <span class="built_in">append</span>(txPool, tempTx)</span><br><span class="line">   &#125;</span><br><span class="line">   chain.Mine(txPool)</span><br><span class="line">   txPool = <span class="built_in">make</span>([]*transaaction.Transaction, <span class="number">0</span>)</span><br><span class="line">   property, _ = chain.FindUTXOs([]<span class="type">byte</span>(<span class="string">&quot;Leo Cao&quot;</span>))</span><br><span class="line">   fmt.Println(<span class="string">&quot;Balance of yangyan: &quot;</span>, property)</span><br><span class="line"></span><br><span class="line">   tempTx, ok = chain.Creatransaction([]<span class="type">byte</span>(<span class="string">&quot;K&quot;</span>), []<span class="type">byte</span>(<span class="string">&quot;E&quot;</span>), <span class="number">200</span>) <span class="comment">// this transaction is invalid</span></span><br><span class="line">   <span class="keyword">if</span> ok &#123;</span><br><span class="line">      txPool = <span class="built_in">append</span>(txPool, tempTx)</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   tempTx, ok = chain.Creatransaction([]<span class="type">byte</span>(<span class="string">&quot;K&quot;</span>), []<span class="type">byte</span>(<span class="string">&quot;E&quot;</span>), <span class="number">50</span>)</span><br><span class="line">   <span class="keyword">if</span> ok &#123;</span><br><span class="line">      txPool = <span class="built_in">append</span>(txPool, tempTx)</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   tempTx, ok = chain.Creatransaction([]<span class="type">byte</span>(<span class="string">&quot;yangyan&quot;</span>), []<span class="type">byte</span>(<span class="string">&quot;E&quot;</span>), <span class="number">100</span>)</span><br><span class="line">   <span class="keyword">if</span> ok &#123;</span><br><span class="line">      txPool = <span class="built_in">append</span>(txPool, tempTx)</span><br><span class="line">   &#125;</span><br><span class="line">   chain.Mine(txPool)</span><br><span class="line">   txPool = <span class="built_in">make</span>([]*transaaction.Transaction, <span class="number">0</span>)</span><br><span class="line">   property, _ = chain.FindUTXOs([]<span class="type">byte</span>(<span class="string">&quot;yangyan&quot;</span>))</span><br><span class="line">   fmt.Println(<span class="string">&quot;Balance of Leo Cao: &quot;</span>, property)</span><br><span class="line">   property, _ = chain.FindUTXOs([]<span class="type">byte</span>(<span class="string">&quot;K&quot;</span>))</span><br><span class="line">   fmt.Println(<span class="string">&quot;Balance of Krad: &quot;</span>, property)</span><br><span class="line">   property, _ = chain.FindUTXOs([]<span class="type">byte</span>(<span class="string">&quot;E&quot;</span>))</span><br><span class="line">   fmt.Println(<span class="string">&quot;Balance of Exia: &quot;</span>, property)</span><br><span class="line"></span><br><span class="line">   <span class="keyword">for</span> _, block := <span class="keyword">range</span> chain.Blocks &#123;</span><br><span class="line">      fmt.Printf(<span class="string">&quot;Timestamp: %d\n&quot;</span>, block.Timestamp)</span><br><span class="line">      fmt.Printf(<span class="string">&quot;hash: %x\n&quot;</span>, block.Hash)</span><br><span class="line">      fmt.Printf(<span class="string">&quot;Previous hash: %x\n&quot;</span>, block.PrevHash)</span><br><span class="line">      fmt.Printf(<span class="string">&quot;nonce: %d\n&quot;</span>, block.Nonce)</span><br><span class="line">      fmt.Println(<span class="string">&quot;Proof of Work validation:&quot;</span>, block.ValidatePoW())</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//展示一下双花问题</span></span><br><span class="line"></span><br><span class="line">   tempTx, ok = chain.Creatransaction([]<span class="type">byte</span>(<span class="string">&quot;Krad&quot;</span>), []<span class="type">byte</span>(<span class="string">&quot;E&quot;</span>), <span class="number">30</span>)</span><br><span class="line">   <span class="keyword">if</span> ok &#123;</span><br><span class="line">      txPool = <span class="built_in">append</span>(txPool, tempTx)</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   tempTx, ok = chain.Creatransaction([]<span class="type">byte</span>(<span class="string">&quot;Krad&quot;</span>), []<span class="type">byte</span>(<span class="string">&quot;yangyan&quot;</span>), <span class="number">30</span>)</span><br><span class="line">   <span class="keyword">if</span> ok &#123;</span><br><span class="line">      txPool = <span class="built_in">append</span>(txPool, tempTx)</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   chain.Mine(txPool)</span><br><span class="line">   txPool = <span class="built_in">make</span>([]*transaaction.Transaction, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">   <span class="keyword">for</span> _, block := <span class="keyword">range</span> chain.Blocks &#123;</span><br><span class="line">      fmt.Printf(<span class="string">&quot;Timestamp: %d\n&quot;</span>, block.Timestamp)</span><br><span class="line">      fmt.Printf(<span class="string">&quot;hash: %x\n&quot;</span>, block.Hash)</span><br><span class="line">      fmt.Printf(<span class="string">&quot;Previous hash: %x\n&quot;</span>, block.PrevHash)</span><br><span class="line">      fmt.Printf(<span class="string">&quot;nonce: %d\n&quot;</span>, block.Nonce)</span><br><span class="line">      fmt.Println(<span class="string">&quot;Proof of Work validation:&quot;</span>, block.ValidatePoW())</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   property, _ = chain.FindUTXOs([]<span class="type">byte</span>(<span class="string">&quot;yangyan&quot;</span>))</span><br><span class="line">   fmt.Println(<span class="string">&quot;Balance of Leo Cao: &quot;</span>, property)</span><br><span class="line">   property, _ = chain.FindUTXOs([]<span class="type">byte</span>(<span class="string">&quot;K&quot;</span>))</span><br><span class="line">   fmt.Println(<span class="string">&quot;Balance of Krad: &quot;</span>, property)</span><br><span class="line">   property, _ = chain.FindUTXOs([]<span class="type">byte</span>(<span class="string">&quot;E&quot;</span>))</span><br><span class="line">   fmt.Println(<span class="string">&quot;Balance of Exia: &quot;</span>, property)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是调试的过程</p><ol><li>创建一个空的交易池（txPool）和一个临时交易变量（tempTx）。</li><li>创建一个区块链实例（chain）。</li><li>查找名为”yangyan”的地址的UTXOs（未使用的交易输出），并打印其余额。</li><li>尝试创建一个从”yangyan”到”K”的转账交易，金额为100，如果成功则将其添加到交易池中。</li><li>对交易池中的交易进行挖矿操作。</li><li>清空交易池，再次查找”L”的地址的UTXOs，并打印其余额。</li><li>尝试创建一个无效的交易，从”K”到”E”的转账交易，金额为200，如果成功则将其添加到交易池中。</li><li>尝试创建一个有效的交易，从”K”到”E”的转账交易，金额为50，如果成功则将其添加到交易池中。</li><li>尝试创建一个有效的交易，从”yangyan”到”E”的转账交易，金额为100，如果成功则将其添加到交易池中。</li><li>对交易池中的交易进行挖矿操作。</li><li>清空交易池。</li><li>遍历区块链中的所有区块，打印每个区块的时间戳、哈希值、前一个区块的哈希值、随机数以及工作量证明验证结果。</li><li>尝试创建一个从”K”到”E”的转账交易，金额为30，如果成功则将其添加到交易池中。</li><li>尝试创建一个从”K”到”yangyan”的转账交易，金额为30，如果成功则将其添加到交易池中。</li><li>对交易池中的交易进行挖矿操作。</li><li>清空交易池。</li><li>遍历区块链中的所有区块，打印每个区块的时间戳、哈希值、前一个区块的哈希值、随机数以及工作量证明验证结果。</li><li>查找各个地址的UTXOs，并打印其余额。</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;交易信息与UTXO模型&quot;&gt;&lt;a href=&quot;#交易信息与UTXO模型&quot; class=&quot;headerlink&quot; title=&quot;交易信息与UTXO模型&quot;&gt;&lt;/a&gt;交易信息与UTXO模型&lt;/h1&gt;&lt;p&gt;区块链中的货币存储是记录交易的过程，而非记录最终的货币数量。平时使用</summary>
      
    
    
    
    <category term="区块链" scheme="http://example.com/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
    
    <category term="区块链" scheme="http://example.com/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
    <category term="goland" scheme="http://example.com/tags/goland/"/>
    
  </entry>
  
  <entry>
    <title>简单区块链的pow验证机制的添加</title>
    <link href="http://example.com/2023/12/02/%E7%AE%80%E5%8D%95%E5%8C%BA%E5%9D%97%E9%93%BE%E7%9A%84pow%E9%AA%8C%E8%AF%81%E6%9C%BA%E5%88%B6%E7%9A%84%E6%B7%BB%E5%8A%A0/"/>
    <id>http://example.com/2023/12/02/%E7%AE%80%E5%8D%95%E5%8C%BA%E5%9D%97%E9%93%BE%E7%9A%84pow%E9%AA%8C%E8%AF%81%E6%9C%BA%E5%88%B6%E7%9A%84%E6%B7%BB%E5%8A%A0/</id>
    <published>2023-12-02T13:04:48.000Z</published>
    <updated>2023-12-06T08:13:25.561Z</updated>
    
    <content type="html"><![CDATA[<h4 id="pow工作量证明机制"><a href="#pow工作量证明机制" class="headerlink" title="pow工作量证明机制"></a>pow工作量证明机制</h4><p>工作量证明机制加到区块链里就是整个随机数，随机数在矿工挖矿时决定了下一个区块会给到谁的手里，随机数加到数据里边然后进行哈希值的计算，看看是不是在一个范围里边。</p><p><em>进行pow扩展之前先给代码规范一下，创建一些文件夹进行代码的管理</em></p><p>先整个文件夹constcoe然后整个全局变量，用来装挖矿的难度。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//constcoe.go</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> constcoe</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">Difficulty = <span class="number">12</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>整个函数包。先整个错误函数，错误直接停止。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Handle</span><span class="params">(err <span class="type">error</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Panic(err)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>把int64位转字节串函数移动过来和那个结构体什么的。</p><p>候选区块加入到区块链是需要pow证明的，如果一个区块可以控制下一个区块是不是自己的时候，他就有了可以双重支付的能力。如果用了工作量证明机制，就可以避免这种情况的发生，首先矿工会筛选交易，然后因为存在随机值，谁也不能确定到底谁会获得下一个区块，这时候就可以解决双花问题了。</p><p>首先我们要增加一些区块的头部信息。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Block <span class="keyword">struct</span> &#123;</span><br><span class="line">Timestamp <span class="type">int64</span></span><br><span class="line">Hash      []<span class="type">byte</span></span><br><span class="line">PrevHash  []<span class="type">byte</span></span><br><span class="line">Target    []<span class="type">byte</span> <span class="comment">//This line is new</span></span><br><span class="line">Nonce     <span class="type">int64</span>  <span class="comment">//This line is new</span></span><br><span class="line">Data      []<span class="type">byte</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>target作为结果哈希值的比较难度。nonce作为计算哈希值的随机数。</p><p>创建一个proofofwork.go，内容放我们之前说的pow共识机制。</p><p>首先我们需要一个可以返回目标难度值得函数，我们使用之前设定的一个常量difficulty来构造目标难度，<em>在实际区块链中目标难度之会根据网络情况定时进行调整</em>。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Block)</span></span> GetTarget() []<span class="type">byte</span> &#123;</span><br><span class="line">target := big.NewInt(<span class="number">1</span>)</span><br><span class="line">target.Lsh(target, <span class="type">uint</span>(<span class="number">256</span>-constcoe.Difficulty))</span><br><span class="line"><span class="keyword">return</span> target.Bytes()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em>Lsh函数就是向左移位，移的越多目标难度值越大，哈希取值落在的空间就更多也就越容易找到符合条件的nonce。</em></p><p>下面的函数是用作输入一段nonce值，进行区块的哈希值运算。不同的nonce值会返回不同的哈希值</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Block)</span></span> GetBase4Nonce(nonce <span class="type">int64</span>) []<span class="type">byte</span> &#123;</span><br><span class="line">data := bytes.Join([][]<span class="type">byte</span>&#123;</span><br><span class="line">utils.ToHexInt(b.Timestamp),</span><br><span class="line">b.PrevHash,</span><br><span class="line">utils.ToHexInt(<span class="type">int64</span>(nonce)),</span><br><span class="line">b.Target,</span><br><span class="line">b.Data,</span><br><span class="line">&#125;,</span><br><span class="line">[]<span class="type">byte</span>&#123;&#125;,</span><br><span class="line">)</span><br><span class="line"><span class="keyword">return</span> data</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在对于任意一个区块，我们都能去寻找一个合适的nonce了。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Block)</span></span> FindNonce() <span class="type">int64</span> &#123;</span><br><span class="line"><span class="keyword">var</span> intHash big.Int</span><br><span class="line"><span class="keyword">var</span> intTarget big.Int</span><br><span class="line"><span class="keyword">var</span> hash [<span class="number">32</span>]<span class="type">byte</span></span><br><span class="line"><span class="keyword">var</span> nonce <span class="type">int64</span></span><br><span class="line">nonce = <span class="number">0</span></span><br><span class="line">intTarget.SetBytes(b.Target)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> nonce &lt; math.MaxInt64 &#123;</span><br><span class="line">data := b.GetBase4Nonce(nonce)</span><br><span class="line">hash = sha256.Sum256(data)</span><br><span class="line">intHash.SetBytes(hash[:])</span><br><span class="line"><span class="keyword">if</span> intHash.Cmp(&amp;intTarget) == <span class="number">-1</span> &#123;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">nonce++</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> nonce</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>比较两个整数的大小。如果<code>intHash.Cmp(&amp;intTarget)</code>返回-1，表示<code>intHash</code>小于<code>intTarget</code>。</p><p>这是一个验证的函数，用作验证是否随机数正确</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Block)</span></span> ValidatePoW() <span class="type">bool</span> &#123;</span><br><span class="line"><span class="keyword">var</span> intHash big.Int</span><br><span class="line"><span class="keyword">var</span> intTarget big.Int</span><br><span class="line"><span class="keyword">var</span> hash [<span class="number">32</span>]<span class="type">byte</span></span><br><span class="line">intTarget.SetBytes(b.Target)</span><br><span class="line">data := b.GetBase4Nonce(b.Nonce)</span><br><span class="line">hash = sha256.Sum256(data)</span><br><span class="line">intHash.SetBytes(hash[:])</span><br><span class="line"><span class="keyword">if</span> intHash.Cmp(&amp;intTarget) == <span class="number">-1</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>PoW我们已经实现了。回到block.go，调整以下函数。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Block)</span></span> SetHash() &#123;</span><br><span class="line">information := bytes.Join([][]<span class="type">byte</span>&#123;utils.ToHexInt(b.Timestamp), b.PrevHash, b.Target, utils.ToHexInt(b.Nonce), b.Data&#125;, []<span class="type">byte</span>&#123;&#125;)</span><br><span class="line">hash := sha256.Sum256(information)</span><br><span class="line">b.Hash = hash[:]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CreateBlock</span><span class="params">(prevhash, data []<span class="type">byte</span>)</span></span> *Block &#123;</span><br><span class="line">block := Block&#123;time.Now().Unix(), []<span class="type">byte</span>&#123;&#125;, prevhash, []<span class="type">byte</span>&#123;&#125;, <span class="number">0</span>, data&#125;</span><br><span class="line">block.Target = block.GetTarget()</span><br><span class="line">block.Nonce = block.FindNonce()</span><br><span class="line">block.SetHash()</span><br><span class="line"><span class="keyword">return</span> &amp;block</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后就可以启动系统了，通过更改difficulty来调整难度。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;pow工作量证明机制&quot;&gt;&lt;a href=&quot;#pow工作量证明机制&quot; class=&quot;headerlink&quot; title=&quot;pow工作量证明机制&quot;&gt;&lt;/a&gt;pow工作量证明机制&lt;/h4&gt;&lt;p&gt;工作量证明机制加到区块链里就是整个随机数，随机数在矿工挖矿时决定了下一个区块</summary>
      
    
    
    
    <category term="区块链" scheme="http://example.com/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
    
    <category term="区块链" scheme="http://example.com/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
    <category term="goland" scheme="http://example.com/tags/goland/"/>
    
  </entry>
  
  <entry>
    <title>goland-goroutine和channel：并发的基础</title>
    <link href="http://example.com/2023/11/29/filegoland-goroutine%E5%92%8Cchannel%EF%BC%9A%E5%B9%B6%E5%8F%91%E7%9A%84%E5%9F%BA%E7%A1%80/"/>
    <id>http://example.com/2023/11/29/filegoland-goroutine%E5%92%8Cchannel%EF%BC%9A%E5%B9%B6%E5%8F%91%E7%9A%84%E5%9F%BA%E7%A1%80/</id>
    <published>2023-11-29T13:37:11.000Z</published>
    <updated>2023-12-06T07:51:52.480Z</updated>
    
    <content type="html"><![CDATA[<h3 id="goroutine和channel：并发的基础"><a href="#goroutine和channel：并发的基础" class="headerlink" title="goroutine和channel：并发的基础"></a>goroutine和channel：并发的基础</h3><h4 id="啥是并发"><a href="#啥是并发" class="headerlink" title="啥是并发"></a>啥是并发</h4><p>听说很有特点的就是goland的并发，所写的代码都按照顺序执行，也就是上一句代码执行完，才会执行下一句，这样的代码逻辑简单，也符合我们的阅读习惯。但这样是不够的，因为计算机很强大，如果只让它干完一件事情再干另外一件事情就太浪费了。比如一款音乐软件，使用它听音乐的时候还想让它下载歌曲，同一时刻做了两件事，在编程中，这就是并发。并发可以让你编写的程序在同一时刻多做几件事情。</p><h4 id="进程和线程"><a href="#进程和线程" class="headerlink" title="进程和线程"></a>进程和线程</h4><h5 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h5><p>操作系统中，进程是非常重要的概念。当你启动一个软件，操作同会自动创建一个进程，进程是如阿健的工作空间，它包含了软件运行所需的所有资源。</p><h5 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h5><p>线程是进程的执行空间，一个进程可以有多个线程，线程被操作系统调度执行，一些计算机桑德行为就会有多个线程被操作系统同时调度执行的情况，这就是线程的并发。</p><h4 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h4><p>Go语言中没有线程的概念，只有协程，也称为goroutine。相比线程来说，协程更加轻量，一个程序可以随意启动成千上万个goroutine。</p><p>goroutine被Go runtime所调度，这一点与线程不一样。也就是说，Go语言的并发是由Go自己调度的，自己决定同时执行多少个goroutine、什么时候执行哪几个。这些对于我们开发者来说完全透明，只需要在编码的时候告诉Go语言要启动几个goroutine，至于如何调度执行，我们不用关心。</p><p>启动一个goroutine非常简单，go语言为我们提供了go关键字，相比其他语言简单许多。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">go</span> fmt.Println(<span class="string">&quot;sad&quot;</span>)</span><br><span class="line">fmt.Println(<span class="string">&quot;qwe&quot;</span>)</span><br><span class="line">time.Sleep(time.Second)</span><br></pre></td></tr></table></figure><p>这样启动一个协程，调用fmt.println函数打印sad。所以这段代码有两个协程，一个是main的，一个是go挂剪子启动的。</p><p>语法就是go之后跟一个方法或者函数的调用。</p><p>上边代码的输出情况是qwe 然后sad，</p><p>示例中的time.Sleep(time.Second)表示等待一秒，这里是让main goroutine等一秒，不然main goroutine执行完毕程序就退出了</p><p>意思就是另外找个线路执行我的sad，所以先后顺序看情况吧可能。</p><h4 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h4><p>如果很多个协程，他们怎么通信呢？这就是channel要结局的问题</p><h5 id="声明一个管道"><a href="#声明一个管道" class="headerlink" title="声明一个管道"></a>声明一个管道</h5><p>声明一个管道很简单</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pipe:<span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">string</span>)</span><br></pre></td></tr></table></figure><p>chan是一个关键字，表示是channel类型。后面的string表示channel里的数据是string。通过channel声明可以看到，chan是一个集合类型。</p><p>定义好一个管道就可以操作了。</p><p>它只有两种操作，接受和发送</p><p>1)接收：获取chan中的值，操作符为＜-chan。</p><p>2)发送：向chan发送值，把值放在chan中，操作符为chan＜-。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line">ch:=<span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">string</span>)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">   fmt.Println(<span class="string">&quot;asd00&quot;</span>)</span><br><span class="line">   ch &lt;-<span class="string">&quot;okokok&quot;</span></span><br><span class="line">&#125;()</span><br><span class="line">fmt.Println(<span class="string">&quot;我是协程&quot;</span>)</span><br><span class="line">v:=&lt;-ch</span><br><span class="line">fmt.Println(<span class="string">&quot;接受chan中的值是：&quot;</span>,v)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序不会在新的goroutine完成之前退出了，因为通过make创建的chan中没有值，而main goroutine又想从chan中获取值，获取不到就一直等待，等到另一个goroutine向chan发送值为止。</p><p>因为最后一个print里的是想要接受v的值，但是v此时此刻没有值，所以一直等到另一个协程给v输送值。</p><h5 id="无缓冲管道"><a href="#无缓冲管道" class="headerlink" title="无缓冲管道"></a>无缓冲管道</h5><p>在上面的示例中，使用make创建的chan就是一个无缓冲管道，它的容量是0，不能存储任何数据。所以无缓冲管道只起到传输数据的作用，数据并不会在管道中做任何停留。这也意味着，无缓冲管道的发送和接收操作是同时进行的，它也可以称为同步管道。</p><h5 id="有缓冲管道"><a href="#有缓冲管道" class="headerlink" title="有缓冲管道"></a>有缓冲管道</h5><p>有缓冲通道是类似于一个可阻塞的队列，内部的元素先进先出。通过make第二个参数可以指定容量，进而创建一个有缓冲的管道。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ch:=<span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>,<span class="number">5</span>)</span><br></pre></td></tr></table></figure><p>我创建了一个容量为5的管道，内部的元素类型是int，也就是说管道内部存放5个类型的int元素，先进先出。</p><p>一个有缓冲管道具备以下特点：</p><p>1)有缓冲管道的内部有一个缓冲队列。</p><p>2)发送操作是向队列的尾部插入元素，如果队列已满，则阻塞等待，直到另一个goroutine执行接收操作释放队列的空间。</p><p>3)接收操作是从队列的头部获取元素并把它从队列中删除，如果队列为空，则阻塞等待，直到另一个goroutine执行，发送操作插入新的元素。</p><p><em>缓冲管道类似一个队列，可以获取他的容量和里面元素的个数和容量。</em></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ch:=<span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>,<span class="number">5</span>)</span><br><span class="line">ch&lt;<span class="number">-2</span></span><br><span class="line">ch&lt;<span class="number">-3</span></span><br><span class="line">fmt.Println(<span class="built_in">cap</span>(ch),<span class="built_in">len</span>(ch))</span><br></pre></td></tr></table></figure><p><strong>无缓冲管道其实就是一个容量大小为0的管道。比如make(chan int，0)。</strong></p><h5 id="关闭通道"><a href="#关闭通道" class="headerlink" title="关闭通道"></a>关闭通道</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">close</span>(ch)</span><br></pre></td></tr></table></figure><p>如果一个管道被关闭，就不能向里面发送数据了，如果发送的话，会引起panic异常。但是我们还可以接收管道里的数据，如果管道里没有数据的话，接收的数据是元素类型的零值。</p><h5 id="单向通道"><a href="#单向通道" class="headerlink" title="单向通道"></a>单向通道</h5><p>maybe有时候我们的特殊需求限制一个管道只能接受不能发送，或者限制一个管道只能发送不能接收，就叫做单向管道</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">onlysend:=<span class="built_in">make</span>(<span class="keyword">chan</span>&lt;- <span class="type">int</span>,<span class="number">5</span>)</span><br><span class="line">onlyreceive:=<span class="built_in">make</span>(&lt;-<span class="keyword">chan</span> <span class="type">int</span>,<span class="number">5</span>)</span><br></pre></td></tr></table></figure><p>单向管道的声明也很简单，只需要在声明的时候带上＜-操作符即可。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">conter</span><span class="params">(out <span class="keyword">chan</span>&lt;- <span class="type">int</span>)</span></span>  &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数体内所用的参数out是一个只能发送的管道，所以函数体内只能对out函数进行发送操作，如果执行接受操作就不能编译通过了。</p><h4 id="select-channel示例"><a href="#select-channel示例" class="headerlink" title="select+channel示例"></a>select+channel示例</h4><p>假设要从网上下载一个文件，我启动了3个goroutine进行下载，并把结果发送到3个channel（管道）中。其中，哪个先下载好，就会使用哪个channel的结果。</p><p>在这种情况下，如果我们尝试获取第一个channel的结果，程序就会被阻塞，无法获取剩下两个channel的结果，也无法判断哪个先下载好。这个时候就需要用到多路复用操作了，在Go语言中，通过select语句可以实现多路复用</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> urls = []<span class="type">string</span>&#123;<span class="string">&quot;http://example.com/file1&quot;</span>, <span class="string">&quot;http://example.com/file2&quot;</span>, <span class="string">&quot;http://example.com/file3&quot;</span>&#125;</span><br><span class="line"><span class="keyword">var</span> resultChannels = <span class="built_in">make</span>([]<span class="keyword">chan</span> <span class="type">string</span>, <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">3</span>; i++ &#123;</span><br><span class="line"><span class="keyword">go</span> downloadFile(urls[i], resultChannels[i])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">3</span>; i++ &#123;</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> result := &lt;-resultChannels[i]:</span><br><span class="line">fmt.Println(<span class="string">&quot;Downloaded file:&quot;</span>, result)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">    </span><br></pre></td></tr></table></figure><p>在上面的代码中，我们定义了一个<code>downloadFile</code>函数来模拟文件下载任务，并将结果发送到对应的通道中。在<code>main</code>函数中，我们创建了3个通道，并启动了3个goroutine来执行下载任务。然后，我们使用<code>select</code>语句来监听每个通道，当某个通道有数据时，就立即获取到结果并打印出来。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;goroutine和channel：并发的基础&quot;&gt;&lt;a href=&quot;#goroutine和channel：并发的基础&quot; class=&quot;headerlink&quot; title=&quot;goroutine和channel：并发的基础&quot;&gt;&lt;/a&gt;goroutine和channel</summary>
      
    
    
    
    <category term="goland" scheme="http://example.com/categories/goland/"/>
    
    
    <category term="goland" scheme="http://example.com/tags/goland/"/>
    
  </entry>
  
  <entry>
    <title>初识区块链-动手制作一个简单的区块链</title>
    <link href="http://example.com/2023/11/27/file%E5%88%9D%E8%AF%86%E5%8C%BA%E5%9D%97%E9%93%BE-%E5%8A%A8%E6%89%8B%E5%88%B6%E4%BD%9C%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    <id>http://example.com/2023/11/27/file%E5%88%9D%E8%AF%86%E5%8C%BA%E5%9D%97%E9%93%BE-%E5%8A%A8%E6%89%8B%E5%88%B6%E4%BD%9C%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E5%8C%BA%E5%9D%97%E9%93%BE/</id>
    <published>2023-11-27T14:58:45.000Z</published>
    <updated>2023-12-06T07:51:24.149Z</updated>
    
    <content type="html"><![CDATA[<h4 id="尝试制作一个简单的区块链"><a href="#尝试制作一个简单的区块链" class="headerlink" title="尝试制作一个简单的区块链"></a>尝试制作一个简单的区块链</h4><p><em>其实主要是对于go的基础语法刚刚学完所以拿来练手</em></p><p>1.用struct函数制作一个块，块在区块链中用来储存数据信息，它内部包含上一个区块的hash值连接上一个区块，包含头部信息总结区块，然后再区块数据的存放区存放要保存的重要数据。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Block <span class="keyword">struct</span> &#123;</span><br><span class="line">   Timestamp <span class="type">int64</span><span class="comment">//时间戳</span></span><br><span class="line">   Hash []<span class="type">byte</span><span class="comment">//本身哈希值</span></span><br><span class="line">   PrevHash []<span class="type">byte</span><span class="comment">//指向上一个区块</span></span><br><span class="line">   Data []<span class="type">byte</span><span class="comment">//属性</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.得到区块之后我们就可以定义一条区块链了。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> BlockChain <span class="keyword">struct</span> &#123;</span><br><span class="line">   Blocks []*Block</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我们可以看到区块链就是区块的一个集合。创建一个切片用来储存每个区块。</p><p>掌握了块和区块链就可以给区块家电细节，观察他们是如何连接起来的。对于一个区块而言，可以通过哈希算法概括全部的信心，哈希值就是区块的id值，同时用来检查区块所包含的信息的完整性。</p><p>3.hash函数</p><p>首先创造一个函数，接受区块的信息。区块的信息要讲所有的信息合并成一条字节串供计算哈希值。join函数是bytes包中的一个函数，用作将许多的切片连接在一起。</p><p>然后利用哈希计算出哈希值，</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Block)</span></span> SetHash() &#123;</span><br><span class="line">   information :=bytes.Join([][]<span class="type">byte</span>&#123;ToHexInt(b.Timestamp),b.PrevHash,b.Data&#125;,[]<span class="type">byte</span>&#123;&#125;)</span><br><span class="line">    <span class="comment">//information是把区块各项属性串联之后的字节串</span></span><br><span class="line">    <span class="comment">//bytes.join可以把多个字符串链接</span></span><br><span class="line">   hash:=sha256.Sum256(information)</span><br><span class="line">    b.Hash=hash[:]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>TOHexInt我们自定义一个函数用作将int类型转换byte类型。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ToHexInt</span><span class="params">(num <span class="type">int64</span>)</span></span> []<span class="type">byte</span> &#123;</span><br><span class="line">   buff := <span class="built_in">new</span>(bytes.Buffer)</span><br><span class="line">   err := binary.Write(buff, binary.BigEndian, num)</span><br><span class="line">   <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      log.Panic(err)</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span>  buff.Bytes()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建bytes.Buffer变量的主要用途是用于高效地处理字节数据。</p><p>大端字节序（Big Endian）是指最高位字节在内存中的低地址处，低位字节在高地址处。与之相对的是小端字节序（Little Endian），即最低位字节在内存中的低地址处，高位字节在高地址处。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">log.Panic(err)</span><br></pre></td></tr></table></figure><p><em>用来停止程序输出错误。</em></p><p>如果需要频繁进行字符串拼接操作，使用普通的字符串拼接方式会导致效率低下。这时就可以使用缓冲区（Buffer）来优化。因为<code>bytes.Buffer</code>是一个具有读取和写入方法的可变大小的字节缓冲区。例如，可以先将需要拼接的字符串写入到缓冲区中，当缓冲区满了或者需要将缓冲区的内容输出时，再进行实际的IO操作。这样就可以大大提高程序的运行效率。</p><p>而缓冲区是一个可以接受多个值的通道，用作可变大小的切片，不强制必须完成发送和接受。</p><p>4.区块创建与创始区块</p><p> 可以获得区块的哈希值了，我们就能够创建区块了。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CreateBlock</span><span class="params">(prevhash, data []<span class="type">byte</span>)</span></span> *Block &#123;</span><br><span class="line">block := Block&#123;time.Now().Unix(), []<span class="type">byte</span>&#123;&#125;, prevhash, data&#125;</span><br><span class="line">block.SetHash()</span><br><span class="line"><span class="keyword">return</span> &amp;block</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一定要引用前一个区块的哈希值。</p><p>新的区块要有时间戳和上一个区块的哈希值，以及这个区块的数据</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GenesisBlock</span><span class="params">()</span></span> *Block &#123;</span><br><span class="line">genesisWords := <span class="string">&quot;Hello, blockchain!&quot;</span></span><br><span class="line"><span class="keyword">return</span> CreateBlock([]<span class="type">byte</span>&#123;&#125;, []<span class="type">byte</span>(genesisWords))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创世区块里存放hello这段信息，构建函数使得区块链可以根据其他的信息创建区块进行储存。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(bc *BlockChain)</span></span> AddBlock(data <span class="type">string</span>) &#123;</span><br><span class="line">newBlock := CreateBlock(bc.Blocks[<span class="built_in">len</span>(bc.Blocks)<span class="number">-1</span>].Hash, []<span class="type">byte</span>(data))</span><br><span class="line">bc.Blocks = <span class="built_in">append</span>(bc.Blocks, newBlock)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>append用来在列表末尾添加一个或者多个元素。</p><p>创建区块链函数，首先把创世区块作为第一个区块</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CreateBlockChain</span><span class="params">()</span></span> *BlockChain &#123;</span><br><span class="line">blockchain := BlockChain&#123;&#125;</span><br><span class="line">blockchain.Blocks = <span class="built_in">append</span>(blockchain.Blocks, GenesisBlock())</span><br><span class="line"><span class="keyword">return</span> &amp;blockchain</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运作一下。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">blockchain := CreateBlockChain()<span class="comment">// 创建一个区块链对象</span></span><br><span class="line">time.Sleep(time.Second)<span class="comment">// 等待一段时间（1秒）</span></span><br><span class="line">blockchain.AddBlock(<span class="string">&quot;A&quot;</span>)</span><br><span class="line">time.Sleep(time.Second)<span class="comment">// 等待一段时间（1秒）</span></span><br><span class="line">blockchain.AddBlock(<span class="string">&quot;B&quot;</span>)</span><br><span class="line">time.Sleep(time.Second)<span class="comment">// 等待一段时间（1秒）</span></span><br><span class="line">blockchain.AddBlock(<span class="string">&quot;C&quot;</span>)</span><br><span class="line">time.Sleep(time.Second)<span class="comment">// 等待一段时间（1秒）</span></span><br><span class="line"><span class="comment">//遍历区块</span></span><br><span class="line"><span class="keyword">for</span> _, block := <span class="keyword">range</span> blockchain.Blocks &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;Timestamp: %d\n&quot;</span>, block.Timestamp)</span><br><span class="line">fmt.Printf(<span class="string">&quot;hash: %x\n&quot;</span>, block.Hash)</span><br><span class="line">fmt.Printf(<span class="string">&quot;Previous hash: %x\n&quot;</span>, block.PrevHash)</span><br><span class="line">fmt.Printf(<span class="string">&quot;data: %s\n&quot;</span>, block.Data)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;尝试制作一个简单的区块链&quot;&gt;&lt;a href=&quot;#尝试制作一个简单的区块链&quot; class=&quot;headerlink&quot; title=&quot;尝试制作一个简单的区块链&quot;&gt;&lt;/a&gt;尝试制作一个简单的区块链&lt;/h4&gt;&lt;p&gt;&lt;em&gt;其实主要是对于go的基础语法刚刚学完所以拿来练手&lt;/</summary>
      
    
    
    
    <category term="区块链" scheme="http://example.com/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
    
    <category term="区块链" scheme="http://example.com/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
    <category term="goland" scheme="http://example.com/tags/goland/"/>
    
  </entry>
  
  <entry>
    <title>goland-错误</title>
    <link href="http://example.com/2023/11/26/goland-%E9%94%99%E8%AF%AF/"/>
    <id>http://example.com/2023/11/26/goland-%E9%94%99%E8%AF%AF/</id>
    <published>2023-11-26T08:33:26.000Z</published>
    <updated>2023-12-06T07:56:45.872Z</updated>
    
    <content type="html"><![CDATA[<h4 id="错误"><a href="#错误" class="headerlink" title="错误"></a>错误</h4><p>在Go语言中，错误是通过内置的error接口表示的。</p><p>只有一个Error()方法用来返回具体的错误信息。</p><h5 id="error工厂函数"><a href="#error工厂函数" class="headerlink" title="error工厂函数"></a>error工厂函数</h5><p>除了可以使用其他函数，自己定义的函数也可以发挥错误信息给调用者。</p><p>add函数会在a或者b任何一个为负数的情况下，返回一个错误信息；如果a、b都不为负数，错误信息部分会返回nil，这也是常见的做法。所以调用者可以通过错误信息是否为nil进行判断。下面的add函数示例是使用errors.New这个工厂函数来生成错误信息的。errors.New函数接收一个字符串参数，返回一个error接口。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span>  <span class="title">add</span><span class="params">(a,b <span class="type">int</span>)</span></span> (<span class="type">int</span>,<span class="type">error</span>)&#123;</span><br><span class="line">   <span class="keyword">if</span> a&lt;<span class="number">0</span>||b&lt;<span class="number">0</span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>,errors.New(<span class="string">&quot;a.b不能为负数&quot;</span>)</span><br><span class="line">   &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      <span class="keyword">return</span> a+b,<span class="literal">nil</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">sum,err:=add(<span class="number">-1</span>,<span class="number">2</span>)</span><br><span class="line"><span class="keyword">if</span> err!=<span class="literal">nil</span>&#123;</span><br><span class="line">   fmt.Println(err)</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">   fmt.Println(sum)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="自定义error"><a href="#自定义error" class="headerlink" title="自定义error"></a>自定义error</h5><p>上面的工厂函数返回错误信息只能穿第一个字符串，如果i昂要携带更多信息，姿势自定义error。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> commonerror <span class="keyword">struct</span> &#123;</span><br><span class="line">   errorcode <span class="type">int</span><span class="comment">//错误编号</span></span><br><span class="line">   errormsg <span class="type">string</span><span class="comment">//报错内容</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ce *commonerror)</span></span> Error()<span class="type">string</span> &#123;</span><br><span class="line">   <span class="keyword">return</span> ce.errormsg</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span>  <span class="title">add</span><span class="params">(a,b <span class="type">int</span>)</span></span> (<span class="type">int</span>,<span class="type">error</span>)&#123;</span><br><span class="line">   <span class="keyword">if</span> a&lt;<span class="number">0</span>||b&lt;<span class="number">0</span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>,&amp;commonerror&#123;</span><br><span class="line">         errormsg: <span class="string">&quot;asd&quot;</span>,</span><br><span class="line">         errorcode:<span class="number">1</span>&#125;</span><br><span class="line">   &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      <span class="keyword">return</span> a+b,<span class="literal">nil</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>意思就是我程序犯错，commonerror就会把内容写成asd和1。</p><h5 id="error断言"><a href="#error断言" class="headerlink" title="error断言"></a>error断言</h5><p>拥有了自定义的error，携带了更多的错误信息后，就可以使用这些信息。需要先把返回的error接口转换为自定义的错误类型。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">sum,err:=add(<span class="number">-1</span>,<span class="number">20</span>)</span><br><span class="line"><span class="keyword">if</span> cm,ok:=err.(*commonerror);ok&#123;</span><br><span class="line">   fmt.Println(<span class="string">&quot;错误代码&quot;</span>,cm.errorcode,<span class="string">&quot;错误信息&quot;</span>,cm.errormsg)</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">   fmt.Println(sum)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>意思就是实现了error接口，我们可以自定义error的效果。</p><p>读起来真是不太理解，找半天我的Error用在哪了，原来是实现了底层的接口，我干。😓</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cm,ok:=err.(*commonerror)</span><br></pre></td></tr></table></figure><p>更是重量级，这是个类型断言，如果err是这个的类型，就给赋值cm。不然就输出sum了。</p><p>不实现那个Error接口就不能返回error值，就不能自定义了。</p><hr><p><em>存个档，错误太抽象了。现在用不到太多，以下的部分以后再来探索吧——2023.11.29</em></p><h5 id="错误嵌套"><a href="#错误嵌套" class="headerlink" title="错误嵌套"></a>错误嵌套</h5><h6 id="error-wrapping功能"><a href="#error-wrapping功能" class="headerlink" title="error wrapping功能"></a>error wrapping功能</h6><h6 id="errors-unwrap函数"><a href="#errors-unwrap函数" class="headerlink" title="errors.unwrap函数"></a>errors.unwrap函数</h6><h6 id="errors-ls函数"><a href="#errors-ls函数" class="headerlink" title="errors.ls函数"></a>errors.ls函数</h6><h6 id="errors-As函数"><a href="#errors-As函数" class="headerlink" title="errors.As函数"></a>errors.As函数</h6><h6 id="defer函数"><a href="#defer函数" class="headerlink" title="defer函数"></a>defer函数</h6><h6 id="panic函数"><a href="#panic函数" class="headerlink" title="panic函数"></a>panic函数</h6>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;错误&quot;&gt;&lt;a href=&quot;#错误&quot; class=&quot;headerlink&quot; title=&quot;错误&quot;&gt;&lt;/a&gt;错误&lt;/h4&gt;&lt;p&gt;在Go语言中，错误是通过内置的error接口表示的。&lt;/p&gt;
&lt;p&gt;只有一个Error()方法用来返回具体的错误信息。&lt;/p&gt;
&lt;h5 id</summary>
      
    
    
    
    <category term="goland" scheme="http://example.com/categories/goland/"/>
    
    
    <category term="goland" scheme="http://example.com/tags/goland/"/>
    
  </entry>
  
  <entry>
    <title>goland-struct和interface</title>
    <link href="http://example.com/2023/11/23/goland-struct%E5%92%8Cinterface/"/>
    <id>http://example.com/2023/11/23/goland-struct%E5%92%8Cinterface/</id>
    <published>2023-11-23T04:30:38.000Z</published>
    <updated>2023-12-06T07:51:00.711Z</updated>
    
    <content type="html"><![CDATA[<h4 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h4><h5 id="结构体的定义"><a href="#结构体的定义" class="headerlink" title="结构体的定义"></a>结构体的定义</h5><p>这里我们定义了一个结构体类型，名称为IPhone，含有字段name</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Phone <span class="keyword">struct</span> &#123;</span><br><span class="line">  name <span class="type">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在定义结构体时，字段的声明方法与平时声明一个变量是一样的，都是变量名在前，类型在后，只不过在结构体中，变量名称为成员名或字段名。</p><h5 id="声明和使用"><a href="#声明和使用" class="headerlink" title="声明和使用"></a>声明和使用</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">p:=IPhone&#123;</span><br><span class="line">   name: <span class="string">&quot;ASD&quot;</span>&#125;</span><br><span class="line">fmt.Println(p.name)</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p:=IPhone&#123;&quot;ASD&quot;&#125;</span><br></pre></td></tr></table></figure><p>两种情况都可以编译通过，甚至可以只声明其中的一部分，那么没声明的部分就默认零值</p><h5 id="结构体的字段"><a href="#结构体的字段" class="headerlink" title="结构体的字段"></a>结构体的字段</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> IPhone <span class="keyword">struct</span> &#123;</span><br><span class="line">   name <span class="type">string</span></span><br><span class="line">   aa kk</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> kk <span class="keyword">struct</span> &#123;</span><br><span class="line">   id <span class="type">int</span></span><br></pre></td></tr></table></figure><p>用代码描述现实中的实体会更匹配，复用程度也更高。对于嵌套结构体字段的结构体，其初始化与正常的结构体大同小异，只需要根据字段对应的类型初始化即可。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">p:=IPhone&#123;</span><br><span class="line">name: <span class="string">&quot;s&quot;</span>,</span><br><span class="line">aa: kk&#123;</span><br><span class="line"><span class="number">6</span>&#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>利用点操作符调用字段的值</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fmt.Println(p.aa.id)</span><br></pre></td></tr></table></figure><h4 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h4><h5 id="接口的定义"><a href="#接口的定义" class="headerlink" title="接口的定义"></a>接口的定义</h5><p>接口要做的是定义好约定，告诉调用方自己可以做什么，但调用方不用知道它的内部实现。</p><p>接口的定义与结构体稍微有些差别，虽然都以type关键字开始，但接口的关键字是interface。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Phone <span class="keyword">interface</span> &#123;</span><br><span class="line">   speak()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义一个接口Phone 拥有speak方法，Phone接口告诉调用者他拥有方法speak，至于谁speak如何speak调用者不用关心，这是由接口实现者来做的。</p><h5 id="接口的实现"><a href="#接口的实现" class="headerlink" title="接口的实现"></a>接口的实现</h5><p>接口的实现者必须是一个具体的类型</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a IPhone)</span></span> speak() <span class="type">string</span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;iiii&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里用Iphone来做示例，让他实现Phone接口。</p><p>给Iphone定义一个方法，这个方法与接口里的方法的签名一样，这样的结构体Iphone就实现了这个Phone的接口，接口并没有通过任何的关键词来实现，所以go的接口是隐式实现的。</p><p><strong>如果一个接口有许多个方法，那么需要实现接口的每个方法才是实现了这个接口。</strong></p><p>实现了接口之后我们就可以使用它了。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">print</span><span class="params">(p Phone)</span></span>&#123;</span><br><span class="line">fmt.Println(p.speak())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义一个接口可以用来打印实现Phone接口的函数，它接受一个Phone接口类型的参数，然后打印出，不用考虑具体的类型实现。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a:=IPhone&#123;<span class="string">&quot;ASD&quot;</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(a)</span><br></pre></td></tr></table></figure><h5 id="值和指针类型接收者"><a href="#值和指针类型接收者" class="headerlink" title="值和指针类型接收者"></a>值和指针类型接收者</h5><p>有值类型接收者和指针类型接收者两种。二者都可以调用方法，因为Go语言编译器自动做了转换，所以值类型接收者和指针类型接收者是等价的。但是在接口的实现中，值类型接收者和指针类型接收者不一样。</p><p>把实现过程改成指针，依旧可以编译运行正常。这就证明了以值类型接收者实现接口的时候，不管是类型本身，还是该类型的指针类型，都实现了该接口。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(&amp;a)</span><br></pre></td></tr></table></figure><p>实例中接收者（a Iphone）实现了Phone接口，那么Iphone和他的指针类型*Iphone都实现了Phone接口。</p><p>接下来把接收者改为指针类型。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a *IPhone)</span></span> speak() <span class="type">string</span>&#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="string">&quot;iiii&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改成指针赖兴接收者后会发现，实例中的print（a），没办法编译成功，错误是IPhone没有实现Phone接口，这就证明了以指针类型接收者实现接口的时候，只有对应的指针类型才被认为实现了接口。</p><p>可以这样解读：当值类型作为接收者时，person类型和<em>person类型都实现了该接口。当指针类型作为接收者时，只有</em>person类型实现了该接口。可以发现，实现接口的类型都有*person，这也表明指针类型比较万能，不管哪一种接收者，它都能实现该接口。</p><h6 id="接口的理解是一个困难的过程-以下是我理解接口的过程和程序。"><a href="#接口的理解是一个困难的过程-以下是我理解接口的过程和程序。" class="headerlink" title="接口的理解是一个困难的过程,以下是我理解接口的过程和程序。"></a>接口的理解是一个困难的过程,以下是我理解接口的过程和程序。</h6><p>1.使用接口和不使用接口的两种方式：</p><ol><li>使用接口：</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Doer <span class="keyword">interface</span> &#123;</span><br><span class="line">    Do()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Foo <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f Foo)</span></span> Do() &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;Foo does something.&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Bar <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b Bar)</span></span> Do() &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;Bar does something else.&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">DoSomething</span><span class="params">(d Doer)</span></span> &#123;</span><br><span class="line">    d.Do()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    f := Foo&#123;&#125;</span><br><span class="line">    b := Bar&#123;&#125;</span><br><span class="line"></span><br><span class="line">    DoSomething(f)</span><br><span class="line">    DoSomething(b)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，我们定义了一个接口 <code>Doer</code> 和两个结构体 <code>Foo</code> 和 <code>Bar</code>。<code>Foo</code> 和 <code>Bar</code> 分别实现了 <code>Doer</code> 接口。在 <code>DoSomething</code> 函数中，我们接收一个 <code>Doer</code> 类型的参数，并调用其 <code>Do</code> 方法。这样，我们可以在 <code>main</code> 函数中传入 <code>Foo</code> 或 <code>Bar</code> 的实例，从而使得代码具有更好的灵活性。</p><ol start="2"><li>不使用接口：</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Foo <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f Foo)</span></span> Do() &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;Foo does something.&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Bar <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b Bar)</span></span> Do() &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;Bar does something else.&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">DoSomethingWithFoo</span><span class="params">(f Foo)</span></span> &#123;</span><br><span class="line">    f.Do()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">DoSomethingWithBar</span><span class="params">(b Bar)</span></span> &#123;</span><br><span class="line">    b.Do()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    f := Foo&#123;&#125;</span><br><span class="line">    b := Bar&#123;&#125;</span><br><span class="line"></span><br><span class="line">    DoSomethingWithFoo(f)</span><br><span class="line">    DoSomethingWithBar(b)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，我们没有使用接口。取而代之的是，我们为 <code>Foo</code> 和 <code>Bar</code> 分别定义了两个函数 <code>DoSomethingWithFoo</code> 和 <code>DoSomethingWithBar</code>。这样，我们也可以在 <code>main</code> 函数中调用这些函数，但相比于使用接口的方式，这种设计缺乏灵活性，因为每个函数只能处理一种类型的值。</p><p>通过以上两个示例的对比，我们可以看到，使用接口可以使得我们的代码更具有抽象性、可替换性和灵活性。在需要抽象、可替换性或灵活性的场景中，使用接口是一个不错的选择。</p><p><em>实现接口的作用是让用户的代码更具可读性，相同的代码出现的频率变低，更低的耦合度。</em></p><h5 id="工厂函数"><a href="#工厂函数" class="headerlink" title="工厂函数"></a>工厂函数</h5><p>工厂函数一般用于创建自定义的结构体，便于使用者调用。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">new</span><span class="params">(a <span class="type">string</span>)</span></span> *IPhone&#123;</span><br><span class="line">   <span class="keyword">return</span> &amp;IPhone&#123;name: a&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我定义了一个工厂函数new,接受一个string的类型的参数，用于表示手机的名字，同时返回一个*Iphone。</p><p>通过工厂函数创建自定义结构的方式，让调用者不用太关注结构体内部的字段，只用传给工厂函数就可以了。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Animal <span class="keyword">interface</span> &#123;</span><br><span class="line">    Speak() <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Dog <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d Dog)</span></span> Speak() <span class="type">string</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Woof!&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Cat <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c Cat)</span></span> Speak() <span class="type">string</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Meow!&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CreateAnimal</span><span class="params">(kind <span class="type">string</span>)</span></span> Animal &#123;</span><br><span class="line">    <span class="keyword">switch</span> kind &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;dog&quot;</span>:</span><br><span class="line">        <span class="keyword">return</span> Dog&#123;&#125;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;cat&quot;</span>:</span><br><span class="line">        <span class="keyword">return</span> Cat&#123;&#125;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    dog := CreateAnimal(<span class="string">&quot;dog&quot;</span>)</span><br><span class="line">    fmt.Println(dog.Speak()) <span class="comment">// 输出：Woof!</span></span><br><span class="line"></span><br><span class="line">    cat := CreateAnimal(<span class="string">&quot;cat&quot;</span>)</span><br><span class="line">    fmt.Println(cat.Speak()) <span class="comment">// 输出：Meow!</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们并不需要在意结构体内部的字段，只需要传给工厂函数就行了。</p><h4 id="继承和组合"><a href="#继承和组合" class="headerlink" title="继承和组合"></a>继承和组合</h4><p>在Go语言中没有继承的概念，所以结构体、接口之间也没有父子关系，Go语言提倡的是组合，利用组合达到代码复用的目的，这也更灵活。类型的组合就是可以称之为嵌套。</p><p>当然可以。以下是一个使用 Go 语言实现的简单嵌套示例。这个例子定义了一个嵌套结构体，用于表示学生和课程信息。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Student <span class="keyword">struct</span> &#123;</span><br><span class="line">    Name <span class="type">string</span></span><br><span class="line">    Age <span class="type">int</span></span><br><span class="line">    Course []Course</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Course <span class="keyword">struct</span> &#123;</span><br><span class="line">    Name <span class="type">string</span></span><br><span class="line">    Credit <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们先定义了一个名为 <code>Student</code> 的结构体，其中包含了姓名（Name）、年龄（Age）和课程（Course）信息。课程信息是由一个嵌套结构体 <code>Course</code> 表示。</p><h4 id="类型断言"><a href="#类型断言" class="headerlink" title="类型断言"></a>类型断言</h4><p>有了接口和实现接口的类型，就会有类型断言。类型断言用来判断一个接口的值是否是实现该接口的某个具体类型。类型断言（Type Assertion）用于确定一个接口变量（interface{}）实际指向的类型。类型断言的语法形式如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">value, ok := <span class="keyword">interface</span>&#123;&#125;.(T)</span><br></pre></td></tr></table></figure><p>其中的 <code>value</code> 是类型为 <code>T</code> 的值，<code>ok</code> 是一个布尔值，表示断言是否成功。如果断言成功，<code>ok</code> 为 <code>true</code>，<code>value</code> 包含接口变量实际指向的值；如果断言失败，<code>ok</code> 为 <code>false</code>，<code>value</code> 为 <code>T</code> 类型的零值。</p><p>以下是一个使用类型断言的示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> x <span class="keyword">interface</span>&#123;&#125; = <span class="string">&quot;Hello, World!&quot;</span></span><br><span class="line"></span><br><span class="line">    s, ok := x.(<span class="type">string</span>)</span><br><span class="line">    <span class="keyword">if</span> ok &#123;</span><br><span class="line">        fmt.Println(s)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;断言失败&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    i, ok := x.(<span class="type">int</span>)</span><br><span class="line">    <span class="keyword">if</span> ok &#123;</span><br><span class="line">        fmt.Println(i)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;断言失败&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，我们首先定义了一个接口变量 <code>x</code>，并将其赋值为字符串 “Hello, World!”。然后，我们使用类型断言尝试将该接口变量转换为字符串类型和整数类型。成功时，<code>ok</code> 为 <code>true</code>，<code>value</code> 包含实际值；失败时，<code>ok</code> 为 <code>false</code>，<code>value</code> 为相应类型的零值。。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;结构体&quot;&gt;&lt;a href=&quot;#结构体&quot; class=&quot;headerlink&quot; title=&quot;结构体&quot;&gt;&lt;/a&gt;结构体&lt;/h4&gt;&lt;h5 id=&quot;结构体的定义&quot;&gt;&lt;a href=&quot;#结构体的定义&quot; class=&quot;headerlink&quot; title=&quot;结构体的定义&quot;&gt;&lt;</summary>
      
    
    
    
    <category term="goland" scheme="http://example.com/categories/goland/"/>
    
    
    <category term="goland" scheme="http://example.com/tags/goland/"/>
    
  </entry>
  
  <entry>
    <title>goland-函数和方法</title>
    <link href="http://example.com/2023/11/21/goland-%E5%87%BD%E6%95%B0%E5%92%8C%E6%96%B9%E6%B3%95/"/>
    <id>http://example.com/2023/11/21/goland-%E5%87%BD%E6%95%B0%E5%92%8C%E6%96%B9%E6%B3%95/</id>
    <published>2023-11-21T11:52:23.000Z</published>
    <updated>2023-12-06T07:50:26.577Z</updated>
    
    <content type="html"><![CDATA[<h4 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h4><h5 id="函数声明"><a href="#函数声明" class="headerlink" title="函数声明"></a>函数声明</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sum</span><span class="params">(a <span class="type">int</span>,b <span class="type">int</span>)</span></span> <span class="type">int</span>&#123;</span><br><span class="line">   <span class="keyword">return</span> a+b</span><br></pre></td></tr></table></figure><p><em>注意形参名后加类型</em></p><p>函数定义以下部分：</p><p>1.关键词func</p><p>2.函数名sum</p><p>3.函数参数a，b</p><p>4.返回值</p><p>5.代码实体</p><h5 id="多值返回"><a href="#多值返回" class="headerlink" title="多值返回"></a>多值返回</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sum</span><span class="params">(a <span class="type">int</span>,b <span class="type">int</span>)</span></span> (<span class="type">int</span>,<span class="type">error</span>)&#123;</span><br><span class="line">   <span class="keyword">return</span> a+b,errors.New(<span class="string">&quot;f&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em>error是go语言内置的错误信息</em></p><h5 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数"></a>可变参数</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sum</span><span class="params">(a ...<span class="type">int</span>)</span></span> <span class="type">int</span>&#123;</span><br><span class="line">   sum:=<span class="number">0</span></span><br><span class="line">   <span class="keyword">for</span> _,a:= <span class="keyword">range</span> params&#123;</span><br><span class="line">      sum +=a</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> sum</span><br></pre></td></tr></table></figure><p>该可变参数通过for range函数循环计算这些参数值和，可变参数类型其实就是切片，a的参数类型是【】int，所以可以通过for range进行循环。</p><p>注意：如果参数中有可变参数和普通参数，那么可变参数放在末尾。</p><h5 id="包级函数"><a href="#包级函数" class="headerlink" title="包级函数"></a>包级函数</h5><p>不落实我们使用的sum还是println，都是从属于一个包，sum函数属于main包，println属于fmt包，同一个包可以调用，当不同的包函数要调用，必须是属于共有的，也就是函数的首字母要大写。</p><p><em>go语言没有public和private来区别共有私有</em></p><h5 id="匿名函数和闭包"><a href="#匿名函数和闭包" class="headerlink" title="匿名函数和闭包"></a>匿名函数和闭包</h5><p>匿名函数就是没有名字的函数，这是它与正常函数的区别。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   sum:= <span class="function"><span class="keyword">func</span><span class="params">(a,b <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> a+b</span><br><span class="line">   &#125;</span><br><span class="line">   fmt.Println(sum(<span class="number">1</span>,<span class="number">2</span>))</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>sum就是弥明函数，有了匿名函数就可以在函数中进行函数嵌套，定义的匿名函数叫做内部函数，更重要的是，<strong>函数内定义的内部函数，可以用外部函数的变量，这种方式也叫做闭包</strong></p><h4 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h4><p>方法和函数的区别在于方法必须要有一个接收者，接收者是一个类型，这样方法就与这个类型绑定在一起，称为这个类型的方法</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="keyword">type</span> Age <span class="type">uint</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(age Age)</span></span>String()&#123;</span><br><span class="line">   fmt.Println(age)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">a:=Age(<span class="number">1</span>)</span><br><span class="line">a.String()</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如同于类一样，必须使用特定类型的接收者才能被调用</p><p>具有更好的可读性，简便性。</p><h5 id="值和指针类型的接收者"><a href="#值和指针类型的接收者" class="headerlink" title="值和指针类型的接收者"></a>值和指针类型的接收者</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(age *Age)</span></span>S()&#123;</span><br><span class="line">   *age=Age(<span class="number">30</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a := Age(<span class="number">25</span>)</span><br><span class="line">a.String()</span><br><span class="line">a.S()</span><br><span class="line">a.String()</span><br></pre></td></tr></table></figure><p>发现值变化了，因为指针对应的更改。</p><p>示例中的变量a并不是指针类型，而是go自动更改的。</p><p>也可以这样</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(&amp;a).S()</span><br></pre></td></tr></table></figure><p>所以使用时，根据自己的需求进行接收者类型的选择，调用者的类型会自己转变，大大提高效率。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;函数&quot;&gt;&lt;a href=&quot;#函数&quot; class=&quot;headerlink&quot; title=&quot;函数&quot;&gt;&lt;/a&gt;函数&lt;/h4&gt;&lt;h5 id=&quot;函数声明&quot;&gt;&lt;a href=&quot;#函数声明&quot; class=&quot;headerlink&quot; title=&quot;函数声明&quot;&gt;&lt;/a&gt;函数声明&lt;/h</summary>
      
    
    
    
    <category term="goland" scheme="http://example.com/categories/goland/"/>
    
    
    <category term="goland" scheme="http://example.com/tags/goland/"/>
    
  </entry>
  
  <entry>
    <title>goland-集合类型</title>
    <link href="http://example.com/2023/11/21/goland-%E9%9B%86%E5%90%88%E7%B1%BB%E5%9E%8B/"/>
    <id>http://example.com/2023/11/21/goland-%E9%9B%86%E5%90%88%E7%B1%BB%E5%9E%8B/</id>
    <published>2023-11-21T10:37:49.000Z</published>
    <updated>2023-12-06T07:50:15.679Z</updated>
    
    <content type="html"><![CDATA[<h4 id="数组的声明"><a href="#数组的声明" class="headerlink" title="数组的声明"></a>数组的声明</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">array:=[<span class="number">5</span>]<span class="type">string</span>&#123;<span class="string">&quot;s&quot;</span>,<span class="string">&quot;a&quot;</span>,<span class="string">&quot;a&quot;</span>,<span class="string">&quot;f&quot;</span>&#125;</span><br></pre></td></tr></table></figure><p><em>数组在内存中是连续存放的.每个元素有自己的下标i（ndex），从0开始</em></p><p>长度在定义时可以取消，它会根据内容数量自己进行计数。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">array:=[]<span class="type">string</span>&#123;<span class="string">&quot;s&quot;</span>,<span class="string">&quot;a&quot;</span>,<span class="string">&quot;a&quot;</span>,<span class="string">&quot;f&quot;</span>&#125;</span><br></pre></td></tr></table></figure><p><em>只用于所有元素都被初始化的场景，如果有特定的索引元素被初始化的情况，就不适合了</em></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">array:=[]<span class="type">string</span>&#123;<span class="number">1</span>:<span class="string">&quot;s&quot;</span>,<span class="number">3</span>:<span class="string">&quot;a&quot;</span>&#125;</span><br></pre></td></tr></table></figure><p>元素长度为4，不一定符合标准</p><h4 id="数组的循环"><a href="#数组的循环" class="headerlink" title="数组的循环"></a>数组的循环</h4><p>利用range进行遍历，i是索引值，v是具体值</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">array:=[]<span class="type">string</span>&#123;<span class="number">1</span>:<span class="string">&quot;s&quot;</span>,<span class="number">3</span>:<span class="string">&quot;a&quot;</span>&#125;</span><br><span class="line"><span class="keyword">for</span> i,v:=<span class="keyword">range</span> array&#123;</span><br><span class="line">   fmt.Printf(<span class="string">&quot;索引 :%d,对应 :%v\n&quot;</span>,i,v)</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>相比之下for range更为简便</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> _,v:=<span class="keyword">range</span> array &#123;</span><br><span class="line">   fmt.Printf(<span class="string">&quot;值:%v\n&quot;</span>,v)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em>_表示被丢弃的值</em></p><h4 id="切片"><a href="#切片" class="headerlink" title="切片"></a>切片</h4><p><em>底层就是数组，对数组的任意分割得到切片，动态数组</em></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">array:=[]<span class="type">string</span>&#123;<span class="string">&quot;s&quot;</span>,<span class="string">&quot;a&quot;</span>,<span class="string">&quot;q&quot;</span>,<span class="string">&quot;g&quot;</span>&#125;</span><br><span class="line">slice:= array[<span class="number">2</span>:<span class="number">4</span>]</span><br><span class="line">fmt.Println(slice)</span><br></pre></td></tr></table></figure><p><em>包含2不包含4索引下的值</em></p><p>切片和数组的操作是差不多的，同样可以经过索引定位值，只不过这里的值是重新从0开始定位的</p><h5 id="切片的修改"><a href="#切片的修改" class="headerlink" title="切片的修改"></a>切片的修改</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">array:=[]<span class="type">string</span>&#123;<span class="string">&quot;s&quot;</span>,<span class="string">&quot;a&quot;</span>,<span class="string">&quot;q&quot;</span>,<span class="string">&quot;g&quot;</span>&#125;</span><br><span class="line">slice:= array[<span class="number">2</span>:<span class="number">4</span>]</span><br><span class="line">slice[<span class="number">0</span>]=<span class="string">&quot;l&quot;</span></span><br><span class="line">fmt.Println(array)</span><br></pre></td></tr></table></figure><p>切片所运用的依旧是数组的底层数据，切片的值更改，相应的数组也会被修改</p><h5 id="切片的声明"><a href="#切片的声明" class="headerlink" title="切片的声明"></a>切片的声明</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">slice:=<span class="built_in">make</span>([]<span class="type">string</span>,<span class="number">1</span>,<span class="number">2</span>)</span><br></pre></td></tr></table></figure><p>1是长度，2是容量，意思是开阔一个容量为8的空间，但是只有一个有数据，其他的属于空闲状态</p><p>切片属于动态数组，相比于数组更为灵活，数组属于值类型，动态数组是指针类型</p><h5 id="切片的追加"><a href="#切片的追加" class="headerlink" title="切片的追加"></a>切片的追加</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> silce2:=<span class="built_in">append</span>(slice1,<span class="string">&quot;f&quot;</span>)</span><br><span class="line">silce2:=<span class="built_in">append</span>(slice1,<span class="string">&quot;f&quot;</span>,<span class="string">&quot;g&quot;</span>)</span><br><span class="line">silce2:=<span class="built_in">append</span>(slice1,slice3...)</span><br></pre></td></tr></table></figure><h4 id="映射"><a href="#映射" class="headerlink" title="映射"></a>映射</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nameAgeMap:=<span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>)</span><br></pre></td></tr></table></figure><p>key值是string类型，value则是int类型,然后可以进行操作了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nameAgeMap[&quot;SS&quot;=2]</span><br></pre></td></tr></table></figure><p> 验证是否存在，asd是value值，ok是key值</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">nameAgeMap:=<span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>)</span><br><span class="line">nameAgeMap[<span class="string">&quot;SS&quot;</span>]=<span class="number">2</span></span><br><span class="line">asd,ok:=nameAgeMap[<span class="string">&quot;SS&quot;</span>]</span><br><span class="line"><span class="keyword">if</span> ok&#123;</span><br><span class="line">   fmt.Println(asd)</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>map是可以用for range遍历的，主义的是遍历是无序的</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;数组的声明&quot;&gt;&lt;a href=&quot;#数组的声明&quot; class=&quot;headerlink&quot; title=&quot;数组的声明&quot;&gt;&lt;/a&gt;数组的声明&lt;/h4&gt;&lt;figure class=&quot;highlight go&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;p</summary>
      
    
    
    
    <category term="goland" scheme="http://example.com/categories/goland/"/>
    
    
    <category term="goland" scheme="http://example.com/tags/goland/"/>
    
  </entry>
  
  <entry>
    <title>goland-控制结构</title>
    <link href="http://example.com/2023/11/21/goland-%E6%8E%A7%E5%88%B6%E7%BB%93%E6%9E%84/"/>
    <id>http://example.com/2023/11/21/goland-%E6%8E%A7%E5%88%B6%E7%BB%93%E6%9E%84/</id>
    <published>2023-11-21T10:15:47.000Z</published>
    <updated>2023-12-06T07:49:54.740Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1-if语句"><a href="#1-if语句" class="headerlink" title="1.if语句"></a>1.if语句</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> 条件语句 &#123;</span><br><span class="line">   </span><br><span class="line">&#125;erse <span class="keyword">if</span> 条件语句&#123;</span><br><span class="line">   &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">      </span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h4 id="2-switch选择语句"><a href="#2-switch选择语句" class="headerlink" title="2.switch选择语句"></a>2.switch选择语句</h4><p>1.分支较多选择switch语句.默认从上到下逐一分析.一旦满足条件就会执行并且返回.自带break。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> i:=<span class="number">6</span>; &#123;</span><br><span class="line">   <span class="keyword">case</span> i&gt;<span class="number">10</span>:</span><br><span class="line">      fmt.Println(i)</span><br><span class="line">   <span class="keyword">case</span> i&gt;<span class="number">5</span> &amp;&amp; i&lt;<span class="number">10</span>:</span><br><span class="line">      fmt.Println(i)</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      fmt.Println(<span class="string">&quot;i&lt;=5&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.switch后带表达式.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> i:=<span class="number">6</span>;j</span><br></pre></td></tr></table></figure><p>假如设置</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> j=<span class="number">3.66</span></span><br></pre></td></tr></table></figure><p>那么</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> i:=<span class="number">6</span>;j &#123;</span><br><span class="line">   <span class="keyword">case</span> i&gt;<span class="number">10</span>:</span><br><span class="line">      fmt.Println(i)</span><br><span class="line">   <span class="keyword">case</span> i&gt;<span class="number">5</span> &amp;&amp; i&lt;<span class="number">10</span>:</span><br><span class="line">      fmt.Println(i)</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      fmt.Println(<span class="string">&quot;i&lt;=5&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>会整体报错.因为case后的值的类型必须是和；后的j类型一样</p><p>同样也可以是字符串类型等</p><p>3.switch语句较为强大</p><p>所以表达式可以很随意</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> <span class="number">1</span>&lt;<span class="number">5</span> &#123;</span><br><span class="line">   <span class="keyword">case</span> <span class="literal">true</span>:</span><br><span class="line">      fmt.Println(<span class="string">&quot;t&quot;</span>)</span><br><span class="line">   <span class="keyword">case</span> <span class="literal">false</span>:</span><br><span class="line">      fmt.Println(<span class="string">&quot;f&quot;</span>)</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      fmt.Println(<span class="string">&quot;n&quot;</span>)</span><br><span class="line"></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h4 id="3-for语句"><a href="#3-for语句" class="headerlink" title="3.for语句"></a>3.for语句</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> 简单语句;条件;更新语句 &#123;</span><br><span class="line">     </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;1-if语句&quot;&gt;&lt;a href=&quot;#1-if语句&quot; class=&quot;headerlink&quot; title=&quot;1.if语句&quot;&gt;&lt;/a&gt;1.if语句&lt;/h4&gt;&lt;figure class=&quot;highlight go&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter</summary>
      
    
    
    
    <category term="goland" scheme="http://example.com/categories/goland/"/>
    
    
    <category term="goland" scheme="http://example.com/tags/goland/"/>
    
  </entry>
  
  <entry>
    <title>goland-变量常量</title>
    <link href="http://example.com/2023/11/17/goland-%E5%8F%98%E9%87%8F%E5%B8%B8%E9%87%8F/"/>
    <id>http://example.com/2023/11/17/goland-%E5%8F%98%E9%87%8F%E5%B8%B8%E9%87%8F/</id>
    <published>2023-11-17T06:32:30.000Z</published>
    <updated>2023-12-06T07:50:49.533Z</updated>
    
    <content type="html"><![CDATA[<h4 id="变量常量"><a href="#变量常量" class="headerlink" title="变量常量"></a>变量常量</h4><h5 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h5><p>1.普通定义方法<!--方法定义的变量必须使用--></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> i <span class="type">int</span> = <span class="number">2</span></span><br></pre></td></tr></table></figure><p>2.默认int类型.go语言有类型推导的作用</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> i=<span class="number">10</span></span><br></pre></td></tr></table></figure><p>3.简短声明</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">i:=<span class="number">10</span></span><br></pre></td></tr></table></figure><p>4.一次多个声明</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span>(</span><br><span class="line">j <span class="type">int</span>=<span class="number">0</span></span><br><span class="line">k =<span class="number">0</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><h5 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h5><p>1.整形：分为有符号和无符号类型 有符号类型int,int8,int16…无符号类型uint,uint8…  差别在于有符号整形的表示可以为负数</p><p>2.浮点型：相较于float32而言float64是更常用的浮点型.相比之下精度更高.误差更小</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> f32 <span class="type">float32</span> =<span class="number">6.3663363663</span></span><br><span class="line"><span class="keyword">var</span> f64 <span class="type">float64</span> =<span class="number">5.662626</span></span><br><span class="line">fmt.Println(f32,f64)</span><br></pre></td></tr></table></figure><p><em>实行代码发现64位丢失数据更少</em></p><p>3.布尔类型</p><p>布尔类型只有false和true两种.也可用于一元操作符！ 二元操作符&amp;&amp;和||逻辑与和逻辑或</p><p>4.字符串</p><p>字符串类型通过string来声明.+号可以用来字符串的相加</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s1=<span class="string">&quot;sss&quot;</span></span><br><span class="line"><span class="keyword">var</span> s2 = <span class="string">&quot;aaa&quot;</span></span><br><span class="line"><span class="built_in">println</span>(s1+s2)</span><br></pre></td></tr></table></figure><h5 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pi:=&amp;i</span><br><span class="line"><span class="comment">//pi指向i的地址</span></span><br></pre></td></tr></table></figure><h5 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//const定义常量</span></span><br><span class="line"><span class="comment">//iota用来初始化常量的</span></span><br><span class="line"><span class="keyword">const</span>(</span><br><span class="line">one=<span class="number">1</span></span><br><span class="line">two=<span class="number">2</span></span><br><span class="line">three=<span class="number">3</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">const</span>(</span><br><span class="line">one=<span class="number">1</span>+itoa</span><br><span class="line">two </span><br><span class="line">three)</span><br><span class="line"><span class="comment">//两个代码效果是一样的</span></span><br></pre></td></tr></table></figure><h5 id="格式转换"><a href="#格式转换" class="headerlink" title="格式转换"></a>格式转换</h5><p><em>go进行使用和计算式同类型的变量必须进行转换</em></p><p>下面是int类型和string类型的转换方式</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> i=<span class="number">3</span></span><br><span class="line">s:=strconv.Itoa(i)</span><br><span class="line">d,err:=strconv.Atoi(s)</span><br><span class="line">fmt.Println(s,d,err)</span><br></pre></td></tr></table></figure><p>强制转换int和float类型</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">i2f:=<span class="type">float64</span>(i)</span><br><span class="line">f2i:=<span class="type">int</span>(f64)</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;变量常量&quot;&gt;&lt;a href=&quot;#变量常量&quot; class=&quot;headerlink&quot; title=&quot;变量常量&quot;&gt;&lt;/a&gt;变量常量&lt;/h4&gt;&lt;h5 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;headerlink&quot; title=&quot;定义&quot;&gt;&lt;/a&gt;定义&lt;/h</summary>
      
    
    
    
    <category term="goland" scheme="http://example.com/categories/goland/"/>
    
    
    <category term="goland" scheme="http://example.com/tags/goland/"/>
    
  </entry>
  
  <entry>
    <title>爬虫爬取b站视频</title>
    <link href="http://example.com/2023/11/15/%E7%88%AC%E8%99%AB%E7%88%AC%E5%8F%96b%E7%AB%99%E8%A7%86%E9%A2%91/"/>
    <id>http://example.com/2023/11/15/%E7%88%AC%E8%99%AB%E7%88%AC%E5%8F%96b%E7%AB%99%E8%A7%86%E9%A2%91/</id>
    <published>2023-11-15T04:25:28.000Z</published>
    <updated>2023-12-06T07:49:28.988Z</updated>
    
    <content type="html"><![CDATA[<h4 id="尝试用python爬取bilibili的视频。"><a href="#尝试用python爬取bilibili的视频。" class="headerlink" title="尝试用python爬取bilibili的视频。"></a><em>尝试用python爬取bilibili的视频</em>。</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> os<span class="comment">#用于操作系统的交换模块</span></span><br><span class="line"><span class="keyword">import</span> requests<span class="comment">#发送http请求模块</span></span><br><span class="line"><span class="keyword">import</span> json<span class="comment">#解析json</span></span><br><span class="line"><span class="keyword">import</span> re<span class="comment">#正则表达式</span></span><br><span class="line"><span class="keyword">from</span> pprint <span class="keyword">import</span> pprint<span class="comment">#美观打印输出json</span></span><br><span class="line"><span class="comment">#输入视频网址.只输入前半部分。</span></span><br><span class="line"><span class="comment">#网址格式最后到/BV****/</span></span><br><span class="line">url=<span class="string">r&#x27;https://www.bilibili.com/video/BV15H4y1o7UH/&#x27;</span></span><br><span class="line"><span class="comment">#设置请求头</span></span><br><span class="line">header=&#123;</span><br><span class="line">    <span class="string">&quot;User-Agent&quot;</span>:<span class="string">&quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/119.0.0.0 Safari/537.36 Edg/119.0.0.0&quot;</span>,</span><br><span class="line">    <span class="string">&quot;Preferer&quot;</span>:<span class="string">&quot;https://www.bilibili.com/&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">resp=requests.get(url=url,headers=header)<span class="comment">#获取http</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#print(resp.text)</span></span><br><span class="line"><span class="comment"># 获取网页.baseurl是视频地址</span></span><br><span class="line">obj=re.<span class="built_in">compile</span>(<span class="string">r&#x27;window.__playinfo__=(.*?)&lt;/script&gt;&#x27;</span>,re.S)</span><br><span class="line">html_data=re.findall(obj,resp.text)[<span class="number">0</span>]<span class="comment">#返回一个列表</span></span><br><span class="line"><span class="comment">#正则表达式对应匹配网页视频音频</span></span><br><span class="line"><span class="comment">#转字符串到json</span></span><br><span class="line"><span class="comment">#print(html_data)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">json_data=json.loads(html_data)</span><br><span class="line"><span class="comment">#pprint(json_data)</span></span><br><span class="line"><span class="comment">#格式化输出</span></span><br><span class="line"><span class="comment">#video和audio分别是视频和音频.爬取下来需要合成</span></span><br><span class="line">videos=json_data[<span class="string">&#x27;data&#x27;</span>][<span class="string">&#x27;dash&#x27;</span>][<span class="string">&#x27;video&#x27;</span>]<span class="comment">#列表</span></span><br><span class="line">video_url=videos[<span class="number">0</span>][<span class="string">&#x27;baseUrl&#x27;</span>]<span class="comment">#视频地址</span></span><br><span class="line">audios=json_data[<span class="string">&#x27;data&#x27;</span>][<span class="string">&#x27;dash&#x27;</span>][<span class="string">&#x27;audio&#x27;</span>]</span><br><span class="line">audios_url=audios[<span class="number">0</span>][<span class="string">&#x27;baseUrl&#x27;</span>]<span class="comment">#音频地址</span></span><br><span class="line"><span class="comment">#下载视频音频</span></span><br><span class="line">resp1=requests.get(url=video_url,headers=header)</span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;test.mp4&#x27;</span>,mode=<span class="string">&#x27;wb&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    f.write(resp1.content)</span><br><span class="line">resp2=requests.get(url=audios_url,headers=header)</span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span> (<span class="string">&#x27;test.mp3&#x27;</span>,mode=<span class="string">&#x27;wb&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    f.write(resp2.content)</span><br><span class="line"><span class="comment">#爬取完成合并视频音频</span></span><br><span class="line"><span class="comment">#利用ffmpeg合并</span></span><br><span class="line">command=<span class="string">r&#x27;ffmpeg -i test.mp4 -i test.mp3 -acodec copy -vcodec copy testout.mp4&#x27;</span></span><br><span class="line">os.system(command=command)</span><br></pre></td></tr></table></figure><p><em>然后左侧文件夹出现爬取的视频音频和合成的视频</em>。</p><h4 id="关于我代码过程中出现的错误和解决的过程"><a href="#关于我代码过程中出现的错误和解决的过程" class="headerlink" title="关于我代码过程中出现的错误和解决的过程"></a><strong>关于我代码过程中出现的错误和解决的过程</strong></h4><h5 id="1-网页开发者模式获取过程中难以找到请求头-刷新解决。"><a href="#1-网页开发者模式获取过程中难以找到请求头-刷新解决。" class="headerlink" title="1.网页开发者模式获取过程中难以找到请求头.刷新解决。"></a>1.网页开发者模式获取过程中难以找到请求头.刷新解决。</h5><h5 id="2-ffmpeg的环境搭建出问题-通过官网下载插件-将文件夹中bin位置添加到path变量中。"><a href="#2-ffmpeg的环境搭建出问题-通过官网下载插件-将文件夹中bin位置添加到path变量中。" class="headerlink" title="2.ffmpeg的环境搭建出问题.通过官网下载插件.将文件夹中bin位置添加到path变量中。"></a>2.ffmpeg的环境搭建出问题.通过官网下载插件.将文件夹中bin位置添加到path变量中。</h5><blockquote><p>1.cmd测试安装</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;ffmpeg</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>2.pip安装ffmpy</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install ffmpy</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>3.pip安装ffmpy3<br>（目前 ffmpy3 具有ffmpeg和ffprobe命令的包装器）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install ffmpy3</span><br></pre></td></tr></table></figure></blockquote><pre><code>* 我的问题这里就解决了.无法解决还有配置路径的方法*</code></pre><h5 id="3-代码容易出现拼写错误。"><a href="#3-代码容易出现拼写错误。" class="headerlink" title="3.代码容易出现拼写错误。"></a>3.代码容易出现拼写错误。</h5><h5 id="4-附加ffmpy的下载途径。"><a href="#4-附加ffmpy的下载途径。" class="headerlink" title="4.附加ffmpy的下载途径。"></a>4.附加ffmpy的下载途径。</h5><blockquote><p><a href="https://www.gyan.dev/ffmpeg/builds/#release-builds">Builds - CODEX FFMPEG @ gyan.dev</a></p><p><em>下载注意不要下载源码版本</em></p></blockquote><h5 id="5-出现中文乱码-设置调utl-8和电脑设置里的区域中勾选utl-8。"><a href="#5-出现中文乱码-设置调utl-8和电脑设置里的区域中勾选utl-8。" class="headerlink" title="5.出现中文乱码.设置调utl-8和电脑设置里的区域中勾选utl-8。"></a>5.出现中文乱码.设置调utl-8和电脑设置里的区域中勾选utl-8。</h5><h5 id="6-注意load和loads的用法load的是文件流另一个是字符串，注意甄别。"><a href="#6-注意load和loads的用法load的是文件流另一个是字符串，注意甄别。" class="headerlink" title="6.注意load和loads的用法load的是文件流另一个是字符串，注意甄别。"></a>6.注意load和loads的用法load的是文件流另一个是字符串，注意甄别。</h5><h5 id="7-首先正则表达式获取才能用相应的字符串代码进行操作。"><a href="#7-首先正则表达式获取才能用相应的字符串代码进行操作。" class="headerlink" title="7.首先正则表达式获取才能用相应的字符串代码进行操作。"></a>7.首先正则表达式获取才能用相应的字符串代码进行操作。</h5>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;尝试用python爬取bilibili的视频。&quot;&gt;&lt;a href=&quot;#尝试用python爬取bilibili的视频。&quot; class=&quot;headerlink&quot; title=&quot;尝试用python爬取bilibili的视频。&quot;&gt;&lt;/a&gt;&lt;em&gt;尝试用python爬取bi</summary>
      
    
    
    
    <category term="python" scheme="http://example.com/categories/python/"/>
    
    
    <category term="python" scheme="http://example.com/tags/python/"/>
    
    <category term="爬虫" scheme="http://example.com/tags/%E7%88%AC%E8%99%AB/"/>
    
  </entry>
  
</feed>
